var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const p$1 = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p$1();
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$1(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap$1 = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect2 of isArray(dep) ? dep : [...dep]) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger$1(target, "delete", key, void 0);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get,
  set: set$1,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger$1(target, "add", value, value);
  }
  return this;
}
function set$1$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger$1(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger$1(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger$1(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger$1(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$1(rawTarget);
    const isPair2 = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair2 ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
const stack = [];
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!isArray(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue.sort((a, b) => getId(a) - getId(b));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
let devtools;
let buffer = [];
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => a.trim());
    } else if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (false)
        ;
      result = normalizeVNode(render3.length > 1 ? render3(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render3(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch, o: { createElement } } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove2 } } = rendererInternals;
  const timeout = toNumber(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent2 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent2) {
        if (parent2.pendingBranch) {
          parent2.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent2 = parent2.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null, true);
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "post" });
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "sync" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  return () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap$1(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        hook(el, done);
        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        onLeave(el, done);
        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props, children } }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return slots.default;
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(() => [props.include, props.exclude], ([include, exclude]) => {
      include && pruneCache((name) => matches(include, name));
      exclude && pruneCache((name) => !matches(exclude, name));
    }, { flush: "post", deep: true });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return rawVNode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  cache.set(base, resolved);
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (isRef(ref2)) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type, ref: ref2, shapeFlag } = vnode;
    const domType = node.nodeType;
    vnode.el = node;
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          nextNode = onMismatch();
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (domType !== 1) {
          nextNode = onMismatch();
        } else {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.outerHTML;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(el, key, null, props[key], false, void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp2(el, "onClick", null, props.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match++;
        if (node.data === "]") {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
    const update = instance.update = effect2.run.bind(effect2);
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj) {
  const ret = {};
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => i.props,
  $attrs: (i) => i.attrs,
  $slots: (i) => i.slots,
  $refs: (i) => i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => () => queueJob(i.update),
  $nextTick: (i) => nextTick.bind(i.proxy),
  $watch: (i) => instanceWatch.bind(i)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
    return has2;
  }
});
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function mergeDefaults(raw, defaults) {
  const props = isArray(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
  for (const key in defaults) {
    const opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      props[key] = { default: defaults[key] };
    } else
      ;
  }
  return props;
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn$1(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (prev[i] !== memo[i]) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.2.33";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = () => performance.now();
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    const timeStamp = e.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydate) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydate);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      this._resolveDef();
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    if (this._resolved) {
      return;
    }
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2) => {
      const { props, styles } = def2;
      const hasOptions = !isArray(props);
      const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
      let numberProps;
      if (hasOptions) {
        for (const key in this._props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            this._props[key] = toNumber(this._props[key]);
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
          }
        }
      }
      this._numberProps = numberProps;
      for (const key of Object.keys(this)) {
        if (key[0] !== "_") {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of rawKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(resolve2);
    } else {
      resolve2(this._def);
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    if (this._numberProps && this._numberProps[key]) {
      value = toNumber(value);
    }
    this._setProp(camelize(key), value, false);
  }
  _getProp(key) {
    return this._props[key];
  }
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        instance.emit = (event, ...args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"];
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    trigger(target, "input");
  }
}
function trigger(el, type) {
  const e = document.createEvent("HTMLEvents");
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = toNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el) {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && toNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el._assign;
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map((o) => number ? toNumber(getValue(o)) : getValue(o));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
  let modelToUse;
  switch (el.tagName) {
    case "SELECT":
      modelToUse = vModelSelect;
      break;
    case "TEXTAREA":
      modelToUse = vModelText;
      break;
    default:
      switch (vnode.props && vnode.props.type) {
        case "checkbox":
          modelToUse = vModelCheckbox;
          break;
        case "radio":
          modelToUse = vModelRadio;
          break;
        default:
          modelToUse = vModelText;
      }
  }
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
const createSSRApp = (...args) => {
  const app2 = ensureHydrationRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const compile = () => {
};
var vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile,
  EffectScope,
  ReactiveEffect,
  customRef,
  effect,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  camelize,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString,
  toHandlerKey,
  BaseTransition,
  Comment,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs,
  useSSRContext,
  useSlots,
  useTransitionState,
  version,
  warn: warn$1,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId,
  Transition,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate,
  initDirectivesForSSR,
  render,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var vue3Apexcharts_common = { exports: {} };
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
var apexcharts_common = { exports: {} };
/*!
 * ApexCharts v3.35.0
 * (c) 2018-2022 ApexCharts
 * Released under the MIT License.
 */
(function(module, exports) {
  function t(t2, e2) {
    var i2 = Object.keys(t2);
    if (Object.getOwnPropertySymbols) {
      var a2 = Object.getOwnPropertySymbols(t2);
      e2 && (a2 = a2.filter(function(e3) {
        return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
      })), i2.push.apply(i2, a2);
    }
    return i2;
  }
  function e(e2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var a2 = arguments[i2] != null ? arguments[i2] : {};
      i2 % 2 ? t(Object(a2), true).forEach(function(t2) {
        o(e2, t2, a2[t2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(a2)) : t(Object(a2)).forEach(function(t2) {
        Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(a2, t2));
      });
    }
    return e2;
  }
  function i(t2) {
    return (i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    })(t2);
  }
  function a(t2, e2) {
    if (!(t2 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(t2, e2) {
    for (var i2 = 0; i2 < e2.length; i2++) {
      var a2 = e2[i2];
      a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, a2.key, a2);
    }
  }
  function r(t2, e2, i2) {
    return e2 && s(t2.prototype, e2), i2 && s(t2, i2), t2;
  }
  function o(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  function n(t2, e2) {
    if (typeof e2 != "function" && e2 !== null)
      throw new TypeError("Super expression must either be null or a function");
    t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && h2(t2, e2);
  }
  function l(t2) {
    return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
      return t3.__proto__ || Object.getPrototypeOf(t3);
    })(t2);
  }
  function h2(t2, e2) {
    return (h2 = Object.setPrototypeOf || function(t3, e3) {
      return t3.__proto__ = e3, t3;
    })(t2, e2);
  }
  function c(t2, e2) {
    if (e2 && (typeof e2 == "object" || typeof e2 == "function"))
      return e2;
    if (e2 !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return function(t3) {
      if (t3 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t3;
    }(t2);
  }
  function d(t2) {
    var e2 = function() {
      if (typeof Reflect == "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy == "function")
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (t3) {
        return false;
      }
    }();
    return function() {
      var i2, a2 = l(t2);
      if (e2) {
        var s2 = l(this).constructor;
        i2 = Reflect.construct(a2, arguments, s2);
      } else
        i2 = a2.apply(this, arguments);
      return c(this, i2);
    };
  }
  function g(t2, e2) {
    return function(t3) {
      if (Array.isArray(t3))
        return t3;
    }(t2) || function(t3, e3) {
      var i2 = t3 == null ? null : typeof Symbol != "undefined" && t3[Symbol.iterator] || t3["@@iterator"];
      if (i2 == null)
        return;
      var a2, s2, r2 = [], o2 = true, n2 = false;
      try {
        for (i2 = i2.call(t3); !(o2 = (a2 = i2.next()).done) && (r2.push(a2.value), !e3 || r2.length !== e3); o2 = true)
          ;
      } catch (t4) {
        n2 = true, s2 = t4;
      } finally {
        try {
          o2 || i2.return == null || i2.return();
        } finally {
          if (n2)
            throw s2;
        }
      }
      return r2;
    }(t2, e2) || p2(t2, e2) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function u(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return f(t3);
    }(t2) || function(t3) {
      if (typeof Symbol != "undefined" && t3[Symbol.iterator] != null || t3["@@iterator"] != null)
        return Array.from(t3);
    }(t2) || p2(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function p2(t2, e2) {
    if (t2) {
      if (typeof t2 == "string")
        return f(t2, e2);
      var i2 = Object.prototype.toString.call(t2).slice(8, -1);
      return i2 === "Object" && t2.constructor && (i2 = t2.constructor.name), i2 === "Map" || i2 === "Set" ? Array.from(t2) : i2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? f(t2, e2) : void 0;
    }
  }
  function f(t2, e2) {
    (e2 == null || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, a2 = new Array(e2); i2 < e2; i2++)
      a2[i2] = t2[i2];
    return a2;
  }
  var x = function() {
    function t2() {
      a(this, t2);
    }
    return r(t2, [{ key: "shadeRGBColor", value: function(t3, e2) {
      var i2 = e2.split(","), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = parseInt(i2[0].slice(4), 10), o2 = parseInt(i2[1], 10), n2 = parseInt(i2[2], 10);
      return "rgb(" + (Math.round((a2 - r2) * s2) + r2) + "," + (Math.round((a2 - o2) * s2) + o2) + "," + (Math.round((a2 - n2) * s2) + n2) + ")";
    } }, { key: "shadeHexColor", value: function(t3, e2) {
      var i2 = parseInt(e2.slice(1), 16), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = i2 >> 16, o2 = i2 >> 8 & 255, n2 = 255 & i2;
      return "#" + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - o2) * s2) + o2) + (Math.round((a2 - n2) * s2) + n2)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(e2, i2) {
      return t2.isColorHex(i2) ? this.shadeHexColor(e2, i2) : this.shadeRGBColor(e2, i2);
    } }], [{ key: "bind", value: function(t3, e2) {
      return function() {
        return t3.apply(e2, arguments);
      };
    } }, { key: "isObject", value: function(t3) {
      return t3 && i(t3) === "object" && !Array.isArray(t3) && t3 != null;
    } }, { key: "is", value: function(t3, e2) {
      return Object.prototype.toString.call(e2) === "[object " + t3 + "]";
    } }, { key: "listToArray", value: function(t3) {
      var e2, i2 = [];
      for (e2 = 0; e2 < t3.length; e2++)
        i2[e2] = t3[e2];
      return i2;
    } }, { key: "extend", value: function(t3, e2) {
      var i2 = this;
      typeof Object.assign != "function" && (Object.assign = function(t4) {
        if (t4 == null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var e3 = Object(t4), i3 = 1; i3 < arguments.length; i3++) {
          var a3 = arguments[i3];
          if (a3 != null)
            for (var s2 in a3)
              a3.hasOwnProperty(s2) && (e3[s2] = a3[s2]);
        }
        return e3;
      });
      var a2 = Object.assign({}, t3);
      return this.isObject(t3) && this.isObject(e2) && Object.keys(e2).forEach(function(s2) {
        i2.isObject(e2[s2]) && s2 in t3 ? a2[s2] = i2.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
      }), a2;
    } }, { key: "extendArray", value: function(e2, i2) {
      var a2 = [];
      return e2.map(function(e3) {
        a2.push(t2.extend(i2, e3));
      }), e2 = a2;
    } }, { key: "monthMod", value: function(t3) {
      return t3 % 12;
    } }, { key: "clone", value: function(e2) {
      if (t2.is("Array", e2)) {
        for (var a2 = [], s2 = 0; s2 < e2.length; s2++)
          a2[s2] = this.clone(e2[s2]);
        return a2;
      }
      if (t2.is("Null", e2))
        return null;
      if (t2.is("Date", e2))
        return e2;
      if (i(e2) === "object") {
        var r2 = {};
        for (var o2 in e2)
          e2.hasOwnProperty(o2) && (r2[o2] = this.clone(e2[o2]));
        return r2;
      }
      return e2;
    } }, { key: "log10", value: function(t3) {
      return Math.log(t3) / Math.LN10;
    } }, { key: "roundToBase10", value: function(t3) {
      return Math.pow(10, Math.floor(Math.log10(t3)));
    } }, { key: "roundToBase", value: function(t3, e2) {
      return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
    } }, { key: "parseNumber", value: function(t3) {
      return t3 === null ? t3 : parseFloat(t3);
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(t3) {
      var e2 = String(t3).split(/[eE]/);
      if (e2.length === 1)
        return e2[0];
      var i2 = "", a2 = t3 < 0 ? "-" : "", s2 = e2[0].replace(".", ""), r2 = Number(e2[1]) + 1;
      if (r2 < 0) {
        for (i2 = a2 + "0."; r2++; )
          i2 += "0";
        return i2 + s2.replace(/^-/, "");
      }
      for (r2 -= s2.length; r2--; )
        i2 += "0";
      return s2 + i2;
    } }, { key: "getDimensions", value: function(t3) {
      var e2 = getComputedStyle(t3, null), i2 = t3.clientHeight, a2 = t3.clientWidth;
      return i2 -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i2];
    } }, { key: "getBoundingClientRect", value: function(t3) {
      var e2 = t3.getBoundingClientRect();
      return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
    } }, { key: "getLargestStringFromArr", value: function(t3) {
      return t3.reduce(function(t4, e2) {
        return Array.isArray(e2) && (e2 = e2.reduce(function(t5, e3) {
          return t5.length > e3.length ? t5 : e3;
        })), t4.length > e2.length ? t4 : e2;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
      t3.substring(0, 1) !== "#" && (t3 = "#999999");
      var i2 = t3.replace("#", "");
      i2 = i2.match(new RegExp("(.{" + i2.length / 3 + "})", "g"));
      for (var a2 = 0; a2 < i2.length; a2++)
        i2[a2] = parseInt(i2[a2].length === 1 ? i2[a2] + i2[a2] : i2[a2], 16);
      return e2 !== void 0 && i2.push(e2), "rgba(" + i2.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(t3) {
      return parseFloat(t3.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(t3) {
      return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t3.length === 4 ? "#" + ("0" + parseInt(t3[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(t3) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
    } }, { key: "getPolygonPos", value: function(t3, e2) {
      for (var i2 = [], a2 = 2 * Math.PI / e2, s2 = 0; s2 < e2; s2++) {
        var r2 = {};
        r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i2.push(r2);
      }
      return i2;
    } }, { key: "polarToCartesian", value: function(t3, e2, i2, a2) {
      var s2 = (a2 - 90) * Math.PI / 180;
      return { x: t3 + i2 * Math.cos(s2), y: e2 + i2 * Math.sin(s2) };
    } }, { key: "escapeString", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i2 = t3.toString().slice();
      return i2 = i2.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e2);
    } }, { key: "negToZero", value: function(t3) {
      return t3 < 0 ? 0 : t3;
    } }, { key: "moveIndexInArray", value: function(t3, e2, i2) {
      if (i2 >= t3.length)
        for (var a2 = i2 - t3.length + 1; a2--; )
          t3.push(void 0);
      return t3.splice(i2, 0, t3.splice(e2, 1)[0]), t3;
    } }, { key: "extractNumber", value: function(t3) {
      return parseFloat(t3.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(t3, e2) {
      for (; (t3 = t3.parentElement) && !t3.classList.contains(e2); )
        ;
      return t3;
    } }, { key: "setELstyles", value: function(t3, e2) {
      for (var i2 in e2)
        e2.hasOwnProperty(i2) && (t3.style.key = e2[i2]);
    } }, { key: "isNumber", value: function(t3) {
      return !isNaN(t3) && parseFloat(Number(t3)) === t3 && !isNaN(parseInt(t3, 10));
    } }, { key: "isFloat", value: function(t3) {
      return Number(t3) === t3 && t3 % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1)
        return true;
    } }, { key: "isIE", value: function() {
      var t3 = window.navigator.userAgent, e2 = t3.indexOf("MSIE ");
      if (e2 > 0)
        return parseInt(t3.substring(e2 + 5, t3.indexOf(".", e2)), 10);
      if (t3.indexOf("Trident/") > 0) {
        var i2 = t3.indexOf("rv:");
        return parseInt(t3.substring(i2 + 3, t3.indexOf(".", i2)), 10);
      }
      var a2 = t3.indexOf("Edge/");
      return a2 > 0 && parseInt(t3.substring(a2 + 5, t3.indexOf(".", a2)), 10);
    } }]), t2;
  }(), b = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.setEasingFunctions();
    }
    return r(t2, [{ key: "setEasingFunctions", value: function() {
      var t3;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t3 = "-";
            break;
          case "easein":
            t3 = "<";
            break;
          case "easeout":
            t3 = ">";
            break;
          case "easeinout":
            t3 = "<>";
            break;
          case "swing":
            t3 = function(t4) {
              var e2 = 1.70158;
              return (t4 -= 1) * t4 * ((e2 + 1) * t4 + e2) + 1;
            };
            break;
          case "bounce":
            t3 = function(t4) {
              return t4 < 1 / 2.75 ? 7.5625 * t4 * t4 : t4 < 2 / 2.75 ? 7.5625 * (t4 -= 1.5 / 2.75) * t4 + 0.75 : t4 < 2.5 / 2.75 ? 7.5625 * (t4 -= 2.25 / 2.75) * t4 + 0.9375 : 7.5625 * (t4 -= 2.625 / 2.75) * t4 + 0.984375;
            };
            break;
          case "elastic":
            t3 = function(t4) {
              return t4 === !!t4 ? t4 : Math.pow(2, -10 * t4) * Math.sin((t4 - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
            break;
          default:
            t3 = "<>";
        }
        this.w.globals.easing = t3;
      }
    } }, { key: "animateLine", value: function(t3, e2, i2, a2) {
      t3.attr(e2).animate(a2).attr(i2);
    } }, { key: "animateMarker", value: function(t3, e2, i2, a2, s2, r2) {
      e2 || (e2 = 0), t3.attr({ r: e2, width: e2, height: e2 }).animate(a2, s2).attr({ r: i2, width: i2.width, height: i2.height }).afterAll(function() {
        r2();
      });
    } }, { key: "animateCircle", value: function(t3, e2, i2, a2, s2) {
      t3.attr({ r: e2.r, cx: e2.cx, cy: e2.cy }).animate(a2, s2).attr({ r: i2.r, cx: i2.cx, cy: i2.cy });
    } }, { key: "animateRect", value: function(t3, e2, i2, a2, s2) {
      t3.attr(e2).animate(a2).attr(i2).afterAll(function() {
        return s2();
      });
    } }, { key: "animatePathsGradually", value: function(t3) {
      var e2 = t3.el, i2 = t3.realIndex, a2 = t3.j, s2 = t3.fill, r2 = t3.pathFrom, o2 = t3.pathTo, n2 = t3.speed, l2 = t3.delay, h3 = this.w, c2 = 0;
      h3.config.chart.animations.animateGradually.enabled && (c2 = h3.config.chart.animations.animateGradually.delay), h3.config.chart.animations.dynamicAnimation.enabled && h3.globals.dataChanged && h3.config.chart.type !== "bar" && (c2 = 0), this.morphSVG(e2, i2, a2, h3.config.chart.type !== "line" || h3.globals.comboCharts ? s2 : "stroke", r2, o2, n2, l2 * c2);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(t3) {
        t3.el.classList.remove("apexcharts-element-hidden");
      });
    } }, { key: "animationCompleted", value: function(t3) {
      var e2 = this.w;
      e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), typeof e2.config.chart.events.animationEnd == "function" && e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
    } }, { key: "morphSVG", value: function(t3, e2, i2, a2, s2, r2, o2, n2) {
      var l2 = this, h3 = this.w;
      s2 || (s2 = t3.attr("pathFrom")), r2 || (r2 = t3.attr("pathTo"));
      var c2 = function(t4) {
        return h3.config.chart.type === "radar" && (o2 = 1), "M 0 ".concat(h3.globals.gridHeight);
      };
      (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = c2()), (!r2 || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c2()), h3.globals.shouldAnimate || (o2 = 1), t3.plot(s2).animate(1, h3.globals.easing, n2).plot(s2).animate(o2, h3.globals.easing, n2).plot(r2).afterAll(function() {
        x.isNumber(i2) ? i2 === h3.globals.series[h3.globals.maxValsInArrayIndex].length - 2 && h3.globals.shouldAnimate && l2.animationCompleted(t3) : a2 !== "none" && h3.globals.shouldAnimate && (!h3.globals.comboCharts && e2 === h3.globals.series.length - 1 || h3.globals.comboCharts) && l2.animationCompleted(t3), l2.showDelayedElements();
      });
    } }]), t2;
  }(), v = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "getDefaultFilter", value: function(t3, e2) {
      var i2 = this.w;
      t3.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), i2.config.states.normal.filter !== "none" ? this.applyFilter(t3, e2, i2.config.states.normal.filter.type, i2.config.states.normal.filter.value) : i2.config.chart.dropShadow.enabled && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
    } }, { key: "addNormalFilter", value: function(t3, e2) {
      var i2 = this.w;
      i2.config.chart.dropShadow.enabled && !t3.node.classList.contains("apexcharts-marker") && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
    } }, { key: "addLightenFilter", value: function(t3, e2, i2) {
      var a2 = this, s2 = this.w, r2 = i2.intensity;
      t3.unfilter(true);
      new window.SVG.Filter();
      t3.filter(function(t4) {
        var i3 = s2.config.chart.dropShadow;
        (i3.enabled ? a2.addShadow(t4, e2, i3) : t4).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r2 } });
      }), t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node);
    } }, { key: "addDarkenFilter", value: function(t3, e2, i2) {
      var a2 = this, s2 = this.w, r2 = i2.intensity;
      t3.unfilter(true);
      new window.SVG.Filter();
      t3.filter(function(t4) {
        var i3 = s2.config.chart.dropShadow;
        (i3.enabled ? a2.addShadow(t4, e2, i3) : t4).componentTransfer({ rgb: { type: "linear", slope: r2 } });
      }), t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node);
    } }, { key: "applyFilter", value: function(t3, e2, i2) {
      var a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.5;
      switch (i2) {
        case "none":
          this.addNormalFilter(t3, e2);
          break;
        case "lighten":
          this.addLightenFilter(t3, e2, { intensity: a2 });
          break;
        case "darken":
          this.addDarkenFilter(t3, e2, { intensity: a2 });
      }
    } }, { key: "addShadow", value: function(t3, e2, i2) {
      var a2 = i2.blur, s2 = i2.top, r2 = i2.left, o2 = i2.color, n2 = i2.opacity, l2 = t3.flood(Array.isArray(o2) ? o2[e2] : o2, n2).composite(t3.sourceAlpha, "in").offset(r2, s2).gaussianBlur(a2).merge(t3.source);
      return t3.blend(t3.source, l2);
    } }, { key: "dropShadow", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a2 = e2.top, s2 = e2.left, r2 = e2.blur, o2 = e2.color, n2 = e2.opacity, l2 = e2.noUserSpaceOnUse, h3 = this.w;
      return t3.unfilter(true), x.isIE() && h3.config.chart.type === "radialBar" || (o2 = Array.isArray(o2) ? o2[i2] : o2, t3.filter(function(t4) {
        var e3 = null;
        e3 = x.isSafari() || x.isFirefox() || x.isIE() ? t4.flood(o2, n2).composite(t4.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r2) : t4.flood(o2, n2).composite(t4.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r2).merge(t4.source), t4.blend(t4.source, e3);
      }), l2 || t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node)), t3;
    } }, { key: "setSelectionFilter", value: function(t3, e2, i2) {
      var a2 = this.w;
      if (a2.globals.selectedDataPoints[e2] !== void 0 && a2.globals.selectedDataPoints[e2].indexOf(i2) > -1) {
        t3.node.setAttribute("selected", true);
        var s2 = a2.config.states.active.filter;
        s2 !== "none" && this.applyFilter(t3, e2, s2.type, s2.value);
      }
    } }, { key: "_scaleFilterSize", value: function(t3) {
      !function(e2) {
        for (var i2 in e2)
          e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
      }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), t2;
  }(), m = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "drawLine", value: function(t3, e2, i2, a2) {
      var s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, o2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, n2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt", l2 = this.w, h3 = l2.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i2, y2: a2, stroke: s2, "stroke-dasharray": r2, "stroke-width": o2, "stroke-linecap": n2 });
      return h3;
    } }, { key: "drawRect", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, r2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", o2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, n2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, l2 = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, h3 = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, c2 = this.w, d2 = c2.globals.dom.Paper.rect();
      return d2.attr({ x: t3, y: e2, width: i2 > 0 ? i2 : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: o2, "stroke-width": n2 !== null ? n2 : 0, stroke: l2 !== null ? l2 : "none", "stroke-dasharray": h3 }), d2.node.setAttribute("fill", r2), d2;
    } }, { key: "drawPolygon", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none", s2 = this.w, r2 = s2.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, "stroke-width": i2 });
      return r2;
    } }, { key: "drawCircle", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i2 = this.w;
      t3 < 0 && (t3 = 0);
      var a2 = i2.globals.dom.Paper.circle(2 * t3);
      return e2 !== null && a2.attr(e2), a2;
    } }, { key: "drawPath", value: function(t3) {
      var e2 = t3.d, i2 = e2 === void 0 ? "" : e2, a2 = t3.stroke, s2 = a2 === void 0 ? "#a8a8a8" : a2, r2 = t3.strokeWidth, o2 = r2 === void 0 ? 1 : r2, n2 = t3.fill, l2 = t3.fillOpacity, h3 = l2 === void 0 ? 1 : l2, c2 = t3.strokeOpacity, d2 = c2 === void 0 ? 1 : c2, g2 = t3.classes, u2 = t3.strokeLinecap, p3 = u2 === void 0 ? null : u2, f2 = t3.strokeDashArray, x2 = f2 === void 0 ? 0 : f2, b2 = this.w;
      return p3 === null && (p3 = b2.config.stroke.lineCap), (i2.indexOf("undefined") > -1 || i2.indexOf("NaN") > -1) && (i2 = "M 0 ".concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i2).attr({ fill: n2, "fill-opacity": h3, stroke: s2, "stroke-opacity": d2, "stroke-linecap": p3, "stroke-width": o2, "stroke-dasharray": x2, class: g2 });
    } }, { key: "group", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, e2 = this.w, i2 = e2.globals.dom.Paper.group();
      return t3 !== null && i2.attr(t3), i2;
    } }, { key: "move", value: function(t3, e2) {
      var i2 = ["M", t3, e2].join(" ");
      return i2;
    } }, { key: "line", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = null;
      return i2 === null ? a2 = ["L", t3, e2].join(" ") : i2 === "H" ? a2 = ["H", t3].join(" ") : i2 === "V" && (a2 = ["V", e2].join(" ")), a2;
    } }, { key: "curve", value: function(t3, e2, i2, a2, s2, r2) {
      var o2 = ["C", t3, e2, i2, a2, s2, r2].join(" ");
      return o2;
    } }, { key: "quadraticCurve", value: function(t3, e2, i2, a2) {
      return ["Q", t3, e2, i2, a2].join(" ");
    } }, { key: "arc", value: function(t3, e2, i2, a2, s2, r2, o2) {
      var n2 = arguments.length > 7 && arguments[7] !== void 0 && arguments[7], l2 = "A";
      n2 && (l2 = "a");
      var h3 = [l2, t3, e2, i2, a2, s2, r2, o2].join(" ");
      return h3;
    } }, { key: "renderPaths", value: function(t3) {
      var i2, a2 = t3.j, s2 = t3.realIndex, r2 = t3.pathFrom, o2 = t3.pathTo, n2 = t3.stroke, l2 = t3.strokeWidth, h3 = t3.strokeLinecap, c2 = t3.fill, d2 = t3.animationDelay, g2 = t3.initialSpeed, u2 = t3.dataChangeSpeed, p3 = t3.className, f2 = t3.shouldClipToGrid, x2 = f2 === void 0 || f2, m2 = t3.bindEventsOnPaths, y2 = m2 === void 0 || m2, w2 = t3.drawShadow, k2 = w2 === void 0 || w2, A2 = this.w, S2 = new v(this.ctx), C2 = new b(this.ctx), L2 = this.w.config.chart.animations.enabled, P2 = L2 && this.w.config.chart.animations.dynamicAnimation.enabled, T2 = !!(L2 && !A2.globals.resized || P2 && A2.globals.dataChanged && A2.globals.shouldAnimate);
      T2 ? i2 = r2 : (i2 = o2, A2.globals.animationEnded = true);
      var M2 = A2.config.stroke.dashArray, I2 = 0;
      I2 = Array.isArray(M2) ? M2[s2] : A2.config.stroke.dashArray;
      var z2 = this.drawPath({ d: i2, stroke: n2, strokeWidth: l2, fill: c2, fillOpacity: 1, classes: p3, strokeLinecap: h3, strokeDashArray: I2 });
      if (z2.attr("index", s2), x2 && z2.attr({ "clip-path": "url(#gridRectMask".concat(A2.globals.cuid, ")") }), A2.config.states.normal.filter.type !== "none")
        S2.getDefaultFilter(z2, s2);
      else if (A2.config.chart.dropShadow.enabled && k2 && (!A2.config.chart.dropShadow.enabledOnSeries || A2.config.chart.dropShadow.enabledOnSeries && A2.config.chart.dropShadow.enabledOnSeries.indexOf(s2) !== -1)) {
        var X2 = A2.config.chart.dropShadow;
        S2.dropShadow(z2, X2, s2);
      }
      y2 && (z2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z2)), z2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z2)), z2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z2))), z2.attr({ pathTo: o2, pathFrom: r2 });
      var E2 = { el: z2, j: a2, realIndex: s2, pathFrom: r2, pathTo: o2, fill: c2, strokeWidth: l2, delay: d2 };
      return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized && A2.globals.dataChanged || C2.showDelayedElements() : C2.animatePathsGradually(e(e({}, E2), {}, { speed: g2 })), A2.globals.dataChanged && P2 && T2 && C2.animatePathsGradually(e(e({}, E2), {}, { speed: u2 })), z2;
    } }, { key: "drawPattern", value: function(t3, e2, i2) {
      var a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, r2 = this.w, o2 = r2.globals.dom.Paper.pattern(e2, i2, function(r3) {
        t3 === "horizontalLines" ? r3.line(0, 0, i2, 0).stroke({ color: a2, width: s2 + 1 }) : t3 === "verticalLines" ? r3.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : t3 === "slantedLines" ? r3.line(0, 0, e2, i2).stroke({ color: a2, width: s2 }) : t3 === "squares" ? r3.rect(e2, i2).fill("none").stroke({ color: a2, width: s2 }) : t3 === "circles" && r3.circle(e2).fill("none").stroke({ color: a2, width: s2 });
      });
      return o2;
    } }, { key: "drawGradient", value: function(t3, e2, i2, a2, s2) {
      var r2, o2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, n2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, l2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, h3 = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, c2 = this.w;
      e2.length < 9 && e2.indexOf("#") === 0 && (e2 = x.hexToRgba(e2, a2)), i2.length < 9 && i2.indexOf("#") === 0 && (i2 = x.hexToRgba(i2, s2));
      var d2 = 0, g2 = 1, u2 = 1, p3 = null;
      n2 !== null && (d2 = n2[0] !== void 0 ? n2[0] / 100 : 0, g2 = n2[1] !== void 0 ? n2[1] / 100 : 1, u2 = n2[2] !== void 0 ? n2[2] / 100 : 1, p3 = n2[3] !== void 0 ? n2[3] / 100 : null);
      var f2 = !(c2.config.chart.type !== "donut" && c2.config.chart.type !== "pie" && c2.config.chart.type !== "polarArea" && c2.config.chart.type !== "bubble");
      if (r2 = l2 === null || l2.length === 0 ? c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
        t4.at(d2, e2, a2), t4.at(g2, i2, s2), t4.at(u2, i2, s2), p3 !== null && t4.at(p3, e2, a2);
      }) : c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
        (Array.isArray(l2[h3]) ? l2[h3] : l2).forEach(function(e3) {
          t4.at(e3.offset / 100, e3.color, e3.opacity);
        });
      }), f2) {
        var b2 = c2.globals.gridWidth / 2, v2 = c2.globals.gridHeight / 2;
        c2.config.chart.type !== "bubble" ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: b2, cy: v2, r: o2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else
        t3 === "vertical" ? r2.from(0, 0).to(0, 1) : t3 === "diagonal" ? r2.from(0, 0).to(1, 1) : t3 === "horizontal" ? r2.from(0, 1).to(1, 1) : t3 === "diagonal2" && r2.from(1, 0).to(0, 1);
      return r2;
    } }, { key: "drawText", value: function(t3) {
      var e2, i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, o2 = t3.fontSize, n2 = t3.fontFamily, l2 = t3.fontWeight, h3 = t3.foreColor, c2 = t3.opacity, d2 = t3.cssClass, g2 = d2 === void 0 ? "" : d2, u2 = t3.isPlainText, p3 = u2 === void 0 || u2, f2 = this.w;
      return s2 === void 0 && (s2 = ""), r2 || (r2 = "start"), h3 && h3.length || (h3 = f2.config.chart.foreColor), n2 = n2 || f2.config.chart.fontFamily, l2 = l2 || "regular", (e2 = Array.isArray(s2) ? f2.globals.dom.Paper.text(function(t4) {
        for (var e3 = 0; e3 < s2.length; e3++)
          e3 === 0 ? t4.tspan(s2[e3]) : t4.tspan(s2[e3]).newLine();
      }) : p3 ? f2.globals.dom.Paper.plain(s2) : f2.globals.dom.Paper.text(function(t4) {
        return t4.tspan(s2);
      })).attr({ x: i2, y: a2, "text-anchor": r2, "dominant-baseline": "auto", "font-size": o2, "font-family": n2, "font-weight": l2, fill: h3, class: "apexcharts-text " + g2 }), e2.node.style.fontFamily = n2, e2.node.style.opacity = c2, e2;
    } }, { key: "drawMarker", value: function(t3, e2, i2) {
      t3 = t3 || 0;
      var a2 = i2.pSize || 0, s2 = null;
      if (i2.shape === "square" || i2.shape === "rect") {
        var r2 = i2.pRadius === void 0 ? a2 / 2 : i2.pRadius;
        e2 !== null && a2 || (a2 = 0, r2 = 0);
        var o2 = 1.2 * a2 + r2, n2 = this.drawRect(o2, o2, o2, o2, r2);
        n2.attr({ x: t3 - o2 / 2, y: e2 - o2 / 2, cx: t3, cy: e2, class: i2.class ? i2.class : "", fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, stroke: i2.pointStrokeColor, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }), s2 = n2;
      } else
        i2.shape !== "circle" && i2.shape || (x.isNumber(e2) || (a2 = 0, e2 = 0), s2 = this.drawCircle(a2, { cx: t3, cy: e2, class: i2.class ? i2.class : "", stroke: i2.pointStrokeColor, fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }));
      return s2;
    } }, { key: "pathMouseEnter", value: function(t3, e2) {
      var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
      if (typeof i2.config.chart.events.dataPointMouseEnter == "function" && i2.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), (i2.config.states.active.filter.type === "none" || t3.node.getAttribute("selected") !== "true") && i2.config.states.hover.filter.type !== "none" && !i2.globals.isTouchDevice) {
        var o2 = i2.config.states.hover.filter;
        a2.applyFilter(t3, s2, o2.type, o2.value);
      }
    } }, { key: "pathMouseLeave", value: function(t3, e2) {
      var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
      typeof i2.config.chart.events.dataPointMouseLeave == "function" && i2.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), i2.config.states.active.filter.type !== "none" && t3.node.getAttribute("selected") === "true" || i2.config.states.hover.filter.type !== "none" && a2.getDefaultFilter(t3, s2);
    } }, { key: "pathMouseDown", value: function(t3, e2) {
      var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10), o2 = "false";
      if (t3.node.getAttribute("selected") === "true") {
        if (t3.node.setAttribute("selected", "false"), i2.globals.selectedDataPoints[s2].indexOf(r2) > -1) {
          var n2 = i2.globals.selectedDataPoints[s2].indexOf(r2);
          i2.globals.selectedDataPoints[s2].splice(n2, 1);
        }
      } else {
        if (!i2.config.states.active.allowMultipleDataPointsSelection && i2.globals.selectedDataPoints.length > 0) {
          i2.globals.selectedDataPoints = [];
          var l2 = i2.globals.dom.Paper.select(".apexcharts-series path").members, h3 = i2.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c2 = function(t4) {
            Array.prototype.forEach.call(t4, function(t5) {
              t5.node.setAttribute("selected", "false"), a2.getDefaultFilter(t5, s2);
            });
          };
          c2(l2), c2(h3);
        }
        t3.node.setAttribute("selected", "true"), o2 = "true", i2.globals.selectedDataPoints[s2] === void 0 && (i2.globals.selectedDataPoints[s2] = []), i2.globals.selectedDataPoints[s2].push(r2);
      }
      if (o2 === "true") {
        var d2 = i2.config.states.active.filter;
        d2 !== "none" && a2.applyFilter(t3, s2, d2.type, d2.value);
      } else
        i2.config.states.active.filter.type !== "none" && a2.getDefaultFilter(t3, s2);
      typeof i2.config.chart.events.dataPointSelection == "function" && i2.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }), e2 && this.ctx.events.fireEvent("dataPointSelection", [e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }]);
    } }, { key: "rotateAroundCenter", value: function(t3) {
      var e2 = {};
      return t3 && typeof t3.getBBox == "function" && (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
    } }, { key: "getTextRects", value: function(t3, e2, i2, a2) {
      var s2 = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], r2 = this.w, o2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: "start", fontSize: e2, fontFamily: i2, foreColor: "#fff", opacity: 0 });
      a2 && o2.attr("transform", a2), r2.globals.dom.Paper.add(o2);
      var n2 = o2.bbox();
      return s2 || (n2 = o2.node.getBoundingClientRect()), o2.remove(), { width: n2.width, height: n2.height };
    } }, { key: "placeTextWithEllipsis", value: function(t3, e2, i2) {
      if (typeof t3.getComputedTextLength == "function" && (t3.textContent = e2, e2.length > 0 && t3.getComputedTextLength() >= i2 / 1.1)) {
        for (var a2 = e2.length - 3; a2 > 0; a2 -= 3)
          if (t3.getSubStringLength(0, a2) <= i2 / 1.1)
            return void (t3.textContent = e2.substring(0, a2) + "...");
        t3.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(t3, e2) {
      for (var i2 in e2)
        e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
    } }]), t2;
  }(), y = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "getStackedSeriesTotals", value: function() {
      var t3 = this.w, e2 = [];
      if (t3.globals.series.length === 0)
        return e2;
      for (var i2 = 0; i2 < t3.globals.series[t3.globals.maxValsInArrayIndex].length; i2++) {
        for (var a2 = 0, s2 = 0; s2 < t3.globals.series.length; s2++)
          t3.globals.series[s2][i2] !== void 0 && (a2 += t3.globals.series[s2][i2]);
        e2.push(a2);
      }
      return t3.globals.stackedSeriesTotals = e2, e2;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return t3 === null ? this.w.config.series.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0) : this.w.globals.series[t3].reduce(function(t4, e2) {
        return t4 + e2;
      }, 0);
    } }, { key: "isSeriesNull", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return (t3 === null ? this.w.config.series.filter(function(t4) {
        return t4 !== null;
      }) : this.w.config.series[t3].data.filter(function(t4) {
        return t4 !== null;
      })).length === 0;
    } }, { key: "seriesHaveSameValues", value: function(t3) {
      return this.w.globals.series[t3].every(function(t4, e2, i2) {
        return t4 === i2[0];
      });
    } }, { key: "getCategoryLabels", value: function(t3) {
      var e2 = this.w, i2 = t3.slice();
      return e2.config.xaxis.convertedCatToNumeric && (i2 = t3.map(function(t4, i3) {
        return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
      })), i2;
    } }, { key: "getLargestSeries", value: function() {
      var t3 = this.w;
      t3.globals.maxValsInArrayIndex = t3.globals.series.map(function(t4) {
        return t4.length;
      }).indexOf(Math.max.apply(Math, t3.globals.series.map(function(t4) {
        return t4.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var t3 = this.w, e2 = 0;
      return t3.globals.markers.size.forEach(function(t4) {
        e2 = Math.max(e2, t4);
      }), t3.config.markers.discrete && t3.config.markers.discrete.length && t3.config.markers.discrete.forEach(function(t4) {
        e2 = Math.max(e2, t4.size);
      }), e2 > 0 && (e2 += t3.config.markers.hover.sizeOffset + 1), t3.globals.markers.largestSize = e2, e2;
    } }, { key: "getSeriesTotals", value: function() {
      var t3 = this.w;
      t3.globals.seriesTotals = t3.globals.series.map(function(t4, e2) {
        var i2 = 0;
        if (Array.isArray(t4))
          for (var a2 = 0; a2 < t4.length; a2++)
            i2 += t4[a2];
        else
          i2 += t4;
        return i2;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(t3, e2) {
      var i2 = this.w;
      return i2.globals.series.map(function(a2, s2) {
        for (var r2 = 0, o2 = 0; o2 < a2.length; o2++)
          i2.globals.seriesX[s2][o2] > t3 && i2.globals.seriesX[s2][o2] < e2 && (r2 += a2[o2]);
        return r2;
      });
    } }, { key: "getPercentSeries", value: function() {
      var t3 = this.w;
      t3.globals.seriesPercent = t3.globals.series.map(function(e2, i2) {
        var a2 = [];
        if (Array.isArray(e2))
          for (var s2 = 0; s2 < e2.length; s2++) {
            var r2 = t3.globals.stackedSeriesTotals[s2], o2 = 0;
            r2 && (o2 = 100 * e2[s2] / r2), a2.push(o2);
          }
        else {
          var n2 = 100 * e2 / t3.globals.seriesTotals.reduce(function(t4, e3) {
            return t4 + e3;
          }, 0);
          a2.push(n2);
        }
        return a2;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var t3, e2, i2, a2, s2 = this.w.globals, r2 = [], o2 = 0, n2 = [], l2 = 0.1, h3 = 0;
      if (s2.yRange = [], s2.isMultipleYAxis)
        for (var c2 = 0; c2 < s2.minYArr.length; c2++)
          s2.yRange.push(Math.abs(s2.minYArr[c2] - s2.maxYArr[c2])), n2.push(0);
      else
        s2.yRange.push(Math.abs(s2.minY - s2.maxY));
      s2.xRange = Math.abs(s2.maxX - s2.minX), s2.zRange = Math.abs(s2.maxZ - s2.minZ);
      for (var d2 = 0; d2 < s2.yRange.length; d2++)
        r2.push(s2.yRange[d2] / s2.gridHeight);
      if (e2 = s2.xRange / s2.gridWidth, i2 = Math.abs(s2.initialMaxX - s2.initialMinX) / s2.gridWidth, t3 = s2.yRange / s2.gridWidth, a2 = s2.xRange / s2.gridHeight, (o2 = s2.zRange / s2.gridHeight * 16) || (o2 = 1), s2.minY !== Number.MIN_VALUE && Math.abs(s2.minY) !== 0 && (s2.hasNegs = true), s2.isMultipleYAxis) {
        n2 = [];
        for (var g2 = 0; g2 < r2.length; g2++)
          n2.push(-s2.minYArr[g2] / r2[g2]);
      } else
        n2.push(-s2.minY / r2[0]), s2.minY !== Number.MIN_VALUE && Math.abs(s2.minY) !== 0 && (l2 = -s2.minY / t3, h3 = s2.minX / e2);
      return { yRatio: r2, invertedYRatio: t3, zRatio: o2, xRatio: e2, initialXRatio: i2, invertedXRatio: a2, baseLineInvertedY: l2, baseLineY: n2, baseLineX: h3 };
    } }, { key: "getLogSeries", value: function(t3) {
      var e2 = this, i2 = this.w;
      return i2.globals.seriesLog = t3.map(function(t4, a2) {
        return i2.config.yaxis[a2] && i2.config.yaxis[a2].logarithmic ? t4.map(function(t5) {
          return t5 === null ? null : e2.getLogVal(i2.config.yaxis[a2].logBase, t5, a2);
        }) : t4;
      }), i2.globals.invalidLogScale ? t3 : i2.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(t3, e2) {
      return Math.log(e2) / Math.log(t3);
    } }, { key: "getLogVal", value: function(t3, e2, i2) {
      if (e2 === 0)
        return 0;
      var a2 = this.w, s2 = a2.globals.minYArr[i2] === 0 ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i2]), r2 = (a2.globals.maxYArr[i2] === 0 ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i2])) - s2;
      return e2 < 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
    } }, { key: "getLogYRatios", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = this.w.globals;
      return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map(function(t4, s2) {
        if (i2.config.yaxis[s2] && e2.w.config.yaxis[s2].logarithmic) {
          var r2, o2 = -Number.MAX_VALUE, n2 = Number.MIN_VALUE;
          return a2.seriesLog.forEach(function(t5, e3) {
            t5.forEach(function(t6) {
              i2.config.yaxis[e3] && i2.config.yaxis[e3].logarithmic && (o2 = Math.max(t6, o2), n2 = Math.min(t6, n2));
            });
          }), r2 = Math.pow(a2.yRange[s2], Math.abs(n2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = r2 / a2.gridHeight, r2;
        }
      }), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
    } }], [{ key: "checkComboSeries", value: function(t3) {
      var e2 = false, i2 = 0, a2 = 0;
      return t3.length && t3[0].type !== void 0 && t3.forEach(function(t4) {
        t4.type !== "bar" && t4.type !== "column" && t4.type !== "candlestick" && t4.type !== "boxPlot" || i2++, t4.type !== void 0 && a2++;
      }), a2 > 0 && (e2 = true), { comboBarCount: i2, comboCharts: e2 };
    } }, { key: "extendArrayProps", value: function(t3, e2, i2) {
      return e2.yaxis && (e2 = t3.extendYAxis(e2, i2)), e2.annotations && (e2.annotations.yaxis && (e2 = t3.extendYAxisAnnotations(e2)), e2.annotations.xaxis && (e2 = t3.extendXAxisAnnotations(e2)), e2.annotations.points && (e2 = t3.extendPointAnnotations(e2))), e2;
    } }]), t2;
  }(), w = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.annoCtx = e2;
    }
    return r(t2, [{ key: "setOrientations", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i2 = this.w;
      if (t3.label.orientation === "vertical") {
        var a2 = e2 !== null ? e2 : 0, s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
        if (s2 !== null) {
          var r2 = s2.getBoundingClientRect();
          s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r2.height + 4), t3.label.position === "top" ? s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + r2.width) : s2.setAttribute("y", parseFloat(s2.getAttribute("y")) - r2.width);
          var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), n2 = o2.x, l2 = o2.y;
          s2.setAttribute("transform", "rotate(-90 ".concat(n2, " ").concat(l2, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(t3, e2) {
      var i2 = this.w;
      if (!t3 || e2.label.text === void 0 || e2.label.text !== void 0 && !String(e2.label.text).trim())
        return null;
      var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding.left, o2 = e2.label.style.padding.right, n2 = e2.label.style.padding.top, l2 = e2.label.style.padding.bottom;
      e2.label.orientation === "vertical" && (n2 = e2.label.style.padding.left, l2 = e2.label.style.padding.right, r2 = e2.label.style.padding.top, o2 = e2.label.style.padding.bottom);
      var h3 = s2.left - a2.left - r2, c2 = s2.top - a2.top - n2, d2 = this.annoCtx.graphics.drawRect(h3 - i2.globals.barPadForNumericAxis, c2, s2.width + r2 + o2, s2.height + n2 + l2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
      return e2.id && d2.node.classList.add(e2.id), d2;
    } }, { key: "annotationsBackground", value: function() {
      var t3 = this, e2 = this.w, i2 = function(i3, a2, s2) {
        var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(a2, "']"));
        if (r2) {
          var o2 = r2.parentNode, n2 = t3.addBackgroundToAnno(r2, i3);
          n2 && (o2.insertBefore(n2.node, r2), i3.label.mouseEnter && n2.node.addEventListener("mouseenter", i3.label.mouseEnter.bind(t3, i3)), i3.label.mouseLeave && n2.node.addEventListener("mouseleave", i3.label.mouseLeave.bind(t3, i3)));
        }
      };
      e2.config.annotations.xaxis.map(function(t4, e3) {
        i2(t4, e3, "xaxis");
      }), e2.config.annotations.yaxis.map(function(t4, e3) {
        i2(t4, e3, "yaxis");
      }), e2.config.annotations.points.map(function(t4, e3) {
        i2(t4, e3, "point");
      });
    } }, { key: "getY1Y2", value: function(t3, e2) {
      var i2, a2 = t3 === "y1" ? e2.y : e2.y2, s2 = this.w;
      if (this.annoCtx.invertAxis) {
        var r2 = s2.globals.labels.indexOf(a2);
        s2.config.xaxis.convertedCatToNumeric && (r2 = s2.globals.categoryLabels.indexOf(a2));
        var o2 = s2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r2 + 1) + ")");
        o2 && (i2 = parseFloat(o2.getAttribute("y")));
      } else {
        var n2;
        if (s2.config.yaxis[e2.yAxisIndex].logarithmic)
          n2 = (a2 = new y(this.annoCtx.ctx).getLogVal(a2, e2.yAxisIndex)) / s2.globals.yLogRatio[e2.yAxisIndex];
        else
          n2 = (a2 - s2.globals.minYArr[e2.yAxisIndex]) / (s2.globals.yRange[e2.yAxisIndex] / s2.globals.gridHeight);
        i2 = s2.globals.gridHeight - n2, s2.config.yaxis[e2.yAxisIndex] && s2.config.yaxis[e2.yAxisIndex].reversed && (i2 = n2);
      }
      return i2;
    } }, { key: "getX1X2", value: function(t3, e2) {
      var i2 = this.w, a2 = this.annoCtx.invertAxis ? i2.globals.minY : i2.globals.minX, s2 = this.annoCtx.invertAxis ? i2.globals.maxY : i2.globals.maxX, r2 = this.annoCtx.invertAxis ? i2.globals.yRange[0] : i2.globals.xRange, o2 = (e2.x - a2) / (r2 / i2.globals.gridWidth);
      this.annoCtx.inversedReversedAxis && (o2 = (s2 - e2.x) / (r2 / i2.globals.gridWidth)), i2.config.xaxis.type !== "category" && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || (o2 = this.getStringX(e2.x));
      var n2 = (e2.x2 - a2) / (r2 / i2.globals.gridWidth);
      return this.annoCtx.inversedReversedAxis && (n2 = (s2 - e2.x2) / (r2 / i2.globals.gridWidth)), i2.config.xaxis.type !== "category" && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || (n2 = this.getStringX(e2.x2)), t3 === "x1" ? o2 : n2;
    } }, { key: "getStringX", value: function(t3) {
      var e2 = this.w, i2 = t3;
      e2.config.xaxis.convertedCatToNumeric && e2.globals.categoryLabels.length && (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
      var a2 = e2.globals.labels.indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a2 + 1) + ")");
      return s2 && (i2 = parseFloat(s2.getAttribute("x"))), i2;
    } }]), t2;
  }(), k = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new w(this.annoCtx);
    }
    return r(t2, [{ key: "addXaxisAnnotation", value: function(t3, e2, i2) {
      var a2, s2 = this.w, r2 = this.helpers.getX1X2("x1", t3), o2 = t3.label.text, n2 = t3.strokeDashArray;
      if (x.isNumber(r2)) {
        if (t3.x2 === null || t3.x2 === void 0) {
          var l2 = this.annoCtx.graphics.drawLine(r2 + t3.offsetX, 0 + t3.offsetY, r2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, n2, t3.borderWidth);
          e2.appendChild(l2.node), t3.id && l2.node.classList.add(t3.id);
        } else {
          if ((a2 = this.helpers.getX1X2("x2", t3)) < r2) {
            var h3 = r2;
            r2 = a2, a2 = h3;
          }
          var c2 = this.annoCtx.graphics.drawRect(r2 + t3.offsetX, 0 + t3.offsetY, a2 - r2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, n2);
          c2.node.classList.add("apexcharts-annotation-rect"), c2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(c2.node), t3.id && c2.node.classList.add(t3.id);
        }
        var d2 = t3.label.position === "top" ? 4 : s2.globals.gridHeight, g2 = this.annoCtx.graphics.getTextRects(o2, parseFloat(t3.label.style.fontSize)), u2 = this.annoCtx.graphics.drawText({ x: r2 + t3.label.offsetX, y: d2 + t3.label.offsetY - (t3.label.orientation === "vertical" ? t3.label.position === "top" ? g2.width / 2 - 12 : -g2.width / 2 : 0), text: o2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        u2.attr({ rel: i2 }), e2.appendChild(u2.node), this.annoCtx.helpers.setOrientations(t3, i2);
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return e2.config.annotations.xaxis.map(function(e3, a2) {
        t3.addXaxisAnnotation(e3, i2.node, a2);
      }), i2;
    } }]), t2;
  }(), A = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new w(this.annoCtx);
    }
    return r(t2, [{ key: "addYaxisAnnotation", value: function(t3, e2, i2) {
      var a2, s2 = this.w, r2 = t3.strokeDashArray, o2 = this.helpers.getY1Y2("y1", t3), n2 = t3.label.text;
      if (t3.y2 === null || t3.y2 === void 0) {
        var l2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
        e2.appendChild(l2.node), t3.id && l2.node.classList.add(t3.id);
      } else {
        if ((a2 = this.helpers.getY1Y2("y2", t3)) > o2) {
          var h3 = o2;
          o2 = a2, a2 = h3;
        }
        var c2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
        c2.node.classList.add("apexcharts-annotation-rect"), c2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(c2.node), t3.id && c2.node.classList.add(t3.id);
      }
      var d2 = t3.label.position === "right" ? s2.globals.gridWidth : 0, g2 = this.annoCtx.graphics.drawText({ x: d2 + t3.label.offsetX, y: (a2 != null ? a2 : o2) + t3.label.offsetY - 3, text: n2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
      g2.attr({ rel: i2 }), e2.appendChild(g2.node);
    } }, { key: "_getYAxisAnnotationWidth", value: function(t3) {
      var e2 = this.w;
      e2.globals.gridWidth;
      return (t3.width.indexOf("%") > -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return e2.config.annotations.yaxis.map(function(e3, a2) {
        t3.addYaxisAnnotation(e3, i2.node, a2);
      }), i2;
    } }]), t2;
  }(), S = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new w(this.annoCtx);
    }
    return r(t2, [{ key: "addPointAnnotation", value: function(t3, e2, i2) {
      this.w;
      var a2 = this.helpers.getX1X2("x1", t3), s2 = this.helpers.getY1Y2("y1", t3);
      if (x.isNumber(a2)) {
        var r2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t3.marker.cssClass, " ").concat(t3.id ? t3.id : "") }, o2 = this.annoCtx.graphics.drawMarker(a2 + t3.marker.offsetX, s2 + t3.marker.offsetY, r2);
        e2.appendChild(o2.node);
        var n2 = t3.label.text ? t3.label.text : "", l2 = this.annoCtx.graphics.drawText({ x: a2 + t3.label.offsetX, y: s2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: n2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        if (l2.attr({ rel: i2 }), e2.appendChild(l2.node), t3.customSVG.SVG) {
          var h3 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t3.customSVG.cssClass });
          h3.attr({ transform: "translate(".concat(a2 + t3.customSVG.offsetX, ", ").concat(s2 + t3.customSVG.offsetY, ")") }), h3.node.innerHTML = t3.customSVG.SVG, e2.appendChild(h3.node);
        }
        if (t3.image.path) {
          var c2 = t3.image.width ? t3.image.width : 20, d2 = t3.image.height ? t3.image.height : 20;
          o2 = this.annoCtx.addImage({ x: a2 + t3.image.offsetX - c2 / 2, y: s2 + t3.image.offsetY - d2 / 2, width: c2, height: d2, path: t3.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t3.mouseEnter && o2.node.addEventListener("mouseenter", t3.mouseEnter.bind(this, t3)), t3.mouseLeave && o2.node.addEventListener("mouseleave", t3.mouseLeave.bind(this, t3));
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return e2.config.annotations.points.map(function(e3, a2) {
        t3.addPointAnnotation(e3, i2.node, a2);
      }), i2;
    } }]), t2;
  }();
  var C = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, L = function() {
    function t2() {
      a(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: 0, mouseEnter: void 0, mouseLeave: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return r(t2, [{ key: "init", value: function() {
      return { annotations: { position: "front", yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "transparent", locales: [C], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0 }, stacked: false, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t3) {
        return new Date(t3).toDateString();
      } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, rangeBarOverlap: true, rangeBarGroupRows: false, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal" } }, bubble: { minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t3) {
        return t3;
      } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t3) {
        return t3 + "%";
      } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t3) {
        return t3.globals.seriesTotals.reduce(function(t4, e2) {
          return t4 + e2;
        }, 0) / t3.globals.series.length + "%";
      } } } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t3) {
        return t3;
      } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t3) {
        return t3;
      } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t3) {
        return t3.globals.seriesTotals.reduce(function(t4, e2) {
          return t4 + e2;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t3) {
        return t3 !== null ? t3 : "";
      }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: true, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0 }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t3) {
        return t3 ? t3 + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), t2;
  }(), P = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new m(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new w(this), this.xAxisAnnotations = new k(this), this.yAxisAnnotations = new A(this), this.pointsAnnotations = new S(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return r(t2, [{ key: "drawAxesAnnotations", value: function() {
      var t3 = this.w;
      if (t3.globals.axisCharts) {
        for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i2, a2], o2 = [i2.node, e2.node, a2.node], n2 = 0; n2 < 3; n2++)
          t3.globals.dom.elGraphical.add(r2[n2]), !s2 || t3.globals.resized || t3.globals.dataChanged || t3.config.chart.type !== "scatter" && t3.config.chart.type !== "bubble" && t3.globals.dataPoints > 1 && o2[n2].classList.add("apexcharts-element-hidden"), t3.globals.delayedElements.push({ el: o2[n2], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var t3 = this;
      this.w.config.annotations.images.map(function(e2, i2) {
        t3.addImage(e2, i2);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var t3 = this;
      this.w.config.annotations.texts.map(function(e2, i2) {
        t3.addText(e2, i2);
      });
    } }, { key: "addXaxisAnnotation", value: function(t3, e2, i2) {
      this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i2);
    } }, { key: "addYaxisAnnotation", value: function(t3, e2, i2) {
      this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i2);
    } }, { key: "addPointAnnotation", value: function(t3, e2, i2) {
      this.pointsAnnotations.addPointAnnotation(t3, e2, i2);
    } }, { key: "addText", value: function(t3, e2) {
      var i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, o2 = t3.foreColor, n2 = t3.fontSize, l2 = t3.fontFamily, h3 = t3.fontWeight, c2 = t3.cssClass, d2 = t3.backgroundColor, g2 = t3.borderWidth, u2 = t3.strokeDashArray, p3 = t3.borderRadius, f2 = t3.borderColor, x2 = t3.appendTo, b2 = x2 === void 0 ? ".apexcharts-annotations" : x2, v2 = t3.paddingLeft, m2 = v2 === void 0 ? 4 : v2, y2 = t3.paddingRight, w2 = y2 === void 0 ? 4 : y2, k2 = t3.paddingBottom, A2 = k2 === void 0 ? 2 : k2, S2 = t3.paddingTop, C2 = S2 === void 0 ? 2 : S2, L2 = this.w, P2 = this.graphics.drawText({ x: i2, y: a2, text: s2, textAnchor: r2 || "start", fontSize: n2 || "12px", fontWeight: h3 || "regular", fontFamily: l2 || L2.config.chart.fontFamily, foreColor: o2 || L2.config.chart.foreColor, cssClass: c2 }), T2 = L2.globals.dom.baseEl.querySelector(b2);
      T2 && T2.appendChild(P2.node);
      var M2 = P2.bbox();
      if (s2) {
        var I2 = this.graphics.drawRect(M2.x - m2, M2.y - C2, M2.width + m2 + w2, M2.height + A2 + C2, p3, d2 || "transparent", 1, g2, f2, u2);
        T2.insertBefore(I2.node, P2.node);
      }
    } }, { key: "addImage", value: function(t3, e2) {
      var i2 = this.w, a2 = t3.path, s2 = t3.x, r2 = s2 === void 0 ? 0 : s2, o2 = t3.y, n2 = o2 === void 0 ? 0 : o2, l2 = t3.width, h3 = l2 === void 0 ? 20 : l2, c2 = t3.height, d2 = c2 === void 0 ? 20 : c2, g2 = t3.appendTo, u2 = g2 === void 0 ? ".apexcharts-annotations" : g2, p3 = i2.globals.dom.Paper.image(a2);
      p3.size(h3, d2).move(r2, n2);
      var f2 = i2.globals.dom.baseEl.querySelector(u2);
      return f2 && f2.appendChild(p3.node), p3;
    } }, { key: "addXaxisAnnotationExternal", value: function(t3, e2, i2) {
      return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "xaxis", contextMethod: i2.addXaxisAnnotation }), i2;
    } }, { key: "addYaxisAnnotationExternal", value: function(t3, e2, i2) {
      return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "yaxis", contextMethod: i2.addYaxisAnnotation }), i2;
    } }, { key: "addPointAnnotationExternal", value: function(t3, e2, i2) {
      return this.invertAxis === void 0 && (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "point", contextMethod: i2.addPointAnnotation }), i2;
    } }, { key: "addAnnotationExternal", value: function(t3) {
      var e2 = t3.params, i2 = t3.pushToMemory, a2 = t3.context, s2 = t3.type, r2 = t3.contextMethod, o2 = a2, n2 = o2.w, l2 = n2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), h3 = l2.childNodes.length + 1, c2 = new L(), d2 = Object.assign({}, s2 === "xaxis" ? c2.xAxisAnnotation : s2 === "yaxis" ? c2.yAxisAnnotation : c2.pointAnnotation), g2 = x.extend(d2, e2);
      switch (s2) {
        case "xaxis":
          this.addXaxisAnnotation(g2, l2, h3);
          break;
        case "yaxis":
          this.addYaxisAnnotation(g2, l2, h3);
          break;
        case "point":
          this.addPointAnnotation(g2, l2, h3);
      }
      var u2 = n2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(h3, "']")), p3 = this.helpers.addBackgroundToAnno(u2, g2);
      return p3 && l2.insertBefore(p3.node, u2), i2 && n2.globals.memory.methodsToExec.push({ context: o2, id: g2.id ? g2.id : x.randomId(), method: r2, label: "addAnnotation", params: e2 }), a2;
    } }, { key: "clearAnnotations", value: function(t3) {
      var e2 = t3.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      e2.globals.memory.methodsToExec.map(function(t4, i3) {
        t4.label !== "addText" && t4.label !== "addAnnotation" || e2.globals.memory.methodsToExec.splice(i3, 1);
      }), i2 = x.listToArray(i2), Array.prototype.forEach.call(i2, function(t4) {
        for (; t4.firstChild; )
          t4.removeChild(t4.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(t3, e2) {
      var i2 = t3.w, a2 = i2.globals.dom.baseEl.querySelectorAll(".".concat(e2));
      a2 && (i2.globals.memory.methodsToExec.map(function(t4, a3) {
        t4.id === e2 && i2.globals.memory.methodsToExec.splice(a3, 1);
      }), Array.prototype.forEach.call(a2, function(t4) {
        t4.parentElement.removeChild(t4);
      }));
    } }]), t2;
  }(), T = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0;
    }
    return r(t2, [{ key: "clippedImgArea", value: function(t3) {
      var e2 = this.w, i2 = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 > s2 ? a2 : s2, o2 = t3.image, n2 = 0, l2 = 0;
      t3.width === void 0 && t3.height === void 0 ? i2.fill.image.width !== void 0 && i2.fill.image.height !== void 0 ? (n2 = i2.fill.image.width + 1, l2 = i2.fill.image.height) : (n2 = r2 + 1, l2 = r2) : (n2 = t3.width, l2 = t3.height);
      var h3 = document.createElementNS(e2.globals.SVGNS, "pattern");
      m.setAttrs(h3, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : "userSpaceOnUse", width: n2 + "px", height: l2 + "px" });
      var c2 = document.createElementNS(e2.globals.SVGNS, "image");
      h3.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, "href", o2), m.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: "none", width: n2 + "px", height: l2 + "px" }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h3);
    } }, { key: "getSeriesIndex", value: function(t3) {
      var e2 = this.w;
      return (e2.config.chart.type === "bar" || e2.config.chart.type === "rangeBar") && e2.config.plotOptions.bar.distributed || e2.config.chart.type === "heatmap" || e2.config.chart.type === "treemap" ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(t3) {
      var e2 = this.w;
      this.opts = t3;
      var i2, a2, s2, r2 = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t3);
      var o2 = this.getFillColors()[this.seriesIndex];
      e2.globals.seriesColors[this.seriesIndex] !== void 0 && (o2 = e2.globals.seriesColors[this.seriesIndex]), typeof o2 == "function" && (o2 = o2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: e2 }));
      var n2 = this.getFillType(this.seriesIndex), l2 = Array.isArray(r2.fill.opacity) ? r2.fill.opacity[this.seriesIndex] : r2.fill.opacity;
      t3.color && (o2 = t3.color);
      var h3 = o2;
      if (o2.indexOf("rgb") === -1 ? o2.length < 9 && (h3 = x.hexToRgba(o2, l2)) : o2.indexOf("rgba") > -1 && (l2 = x.getOpacityFromRGBA(o2)), t3.opacity && (l2 = t3.opacity), n2 === "pattern" && (a2 = this.handlePatternFill(a2, o2, l2, h3)), n2 === "gradient" && (s2 = this.handleGradientFill(o2, l2, this.seriesIndex)), n2 === "image") {
        var c2 = r2.fill.image.src, d2 = t3.patternID ? t3.patternID : "";
        this.clippedImgArea({ opacity: l2, image: Array.isArray(c2) ? t3.seriesNumber < c2.length ? c2[t3.seriesNumber] : c2[0] : c2, width: t3.width ? t3.width : void 0, height: t3.height ? t3.height : void 0, patternUnits: t3.patternUnits, patternID: "pattern".concat(e2.globals.cuid).concat(t3.seriesNumber + 1).concat(d2) }), i2 = "url(#pattern".concat(e2.globals.cuid).concat(t3.seriesNumber + 1).concat(d2, ")");
      } else
        i2 = n2 === "gradient" ? s2 : n2 === "pattern" ? a2 : h3;
      return t3.solid && (i2 = h3), i2;
    } }, { key: "getFillType", value: function(t3) {
      var e2 = this.w;
      return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var t3 = this.w, e2 = t3.config, i2 = this.opts, a2 = [];
      return t3.globals.comboCharts ? t3.config.series[this.seriesIndex].type === "line" ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : e2.chart.type === "line" ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), i2.fillColors !== void 0 && (a2 = [], Array.isArray(i2.fillColors) ? a2 = i2.fillColors.slice() : a2.push(i2.fillColors)), a2;
    } }, { key: "handlePatternFill", value: function(t3, e2, i2, a2) {
      var s2 = this.w.config, r2 = this.opts, o2 = new m(this.ctx), n2 = s2.fill.pattern.strokeWidth === void 0 ? Array.isArray(s2.stroke.width) ? s2.stroke.width[this.seriesIndex] : s2.stroke.width : Array.isArray(s2.fill.pattern.strokeWidth) ? s2.fill.pattern.strokeWidth[this.seriesIndex] : s2.fill.pattern.strokeWidth, l2 = e2;
      Array.isArray(s2.fill.pattern.style) ? t3 = s2.fill.pattern.style[r2.seriesNumber] !== void 0 ? o2.drawPattern(s2.fill.pattern.style[r2.seriesNumber], s2.fill.pattern.width, s2.fill.pattern.height, l2, n2, i2) : a2 : t3 = o2.drawPattern(s2.fill.pattern.style, s2.fill.pattern.width, s2.fill.pattern.height, l2, n2, i2);
      return t3;
    } }, { key: "handleGradientFill", value: function(t3, e2, i2) {
      var a2, s2 = this.w.config, r2 = this.opts, o2 = new m(this.ctx), n2 = new x(), l2 = s2.fill.gradient.type, h3 = t3, c2 = s2.fill.gradient.opacityFrom === void 0 ? e2 : Array.isArray(s2.fill.gradient.opacityFrom) ? s2.fill.gradient.opacityFrom[i2] : s2.fill.gradient.opacityFrom;
      h3.indexOf("rgba") > -1 && (c2 = x.getOpacityFromRGBA(h3));
      var d2 = s2.fill.gradient.opacityTo === void 0 ? e2 : Array.isArray(s2.fill.gradient.opacityTo) ? s2.fill.gradient.opacityTo[i2] : s2.fill.gradient.opacityTo;
      if (s2.fill.gradient.gradientToColors === void 0 || s2.fill.gradient.gradientToColors.length === 0)
        a2 = s2.fill.gradient.shade === "dark" ? n2.shadeColor(-1 * parseFloat(s2.fill.gradient.shadeIntensity), t3.indexOf("rgb") > -1 ? x.rgb2hex(t3) : t3) : n2.shadeColor(parseFloat(s2.fill.gradient.shadeIntensity), t3.indexOf("rgb") > -1 ? x.rgb2hex(t3) : t3);
      else if (s2.fill.gradient.gradientToColors[r2.seriesNumber]) {
        var g2 = s2.fill.gradient.gradientToColors[r2.seriesNumber];
        a2 = g2, g2.indexOf("rgba") > -1 && (d2 = x.getOpacityFromRGBA(g2));
      } else
        a2 = t3;
      if (s2.fill.gradient.inverseColors) {
        var u2 = h3;
        h3 = a2, a2 = u2;
      }
      return h3.indexOf("rgb") > -1 && (h3 = x.rgb2hex(h3)), a2.indexOf("rgb") > -1 && (a2 = x.rgb2hex(a2)), o2.drawGradient(l2, h3, a2, c2, d2, r2.size, s2.fill.gradient.stops, s2.fill.gradient.colorStops, i2);
    } }]), t2;
  }(), M = function() {
    function t2(e2, i2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "setGlobalMarkerSize", value: function() {
      var t3 = this.w;
      if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length > 0) {
        if (t3.globals.markers.size.length < t3.globals.series.length + 1)
          for (var e2 = 0; e2 <= t3.globals.series.length; e2++)
            t3.globals.markers.size[e2] === void 0 && t3.globals.markers.size.push(t3.globals.markers.size[0]);
      } else
        t3.globals.markers.size = t3.config.series.map(function(e3) {
          return t3.config.markers.size;
        });
    } }, { key: "plotChartMarkers", value: function(t3, e2, i2, a2) {
      var s2, r2 = arguments.length > 4 && arguments[4] !== void 0 && arguments[4], o2 = this.w, n2 = e2, l2 = t3, h3 = null, c2 = new m(this.ctx), d2 = o2.config.markers.discrete && o2.config.markers.discrete.length;
      if ((o2.globals.markers.size[e2] > 0 || r2 || d2) && (h3 = c2.group({ class: r2 || d2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(o2.globals.cuid, ")")), Array.isArray(l2.x))
        for (var g2 = 0; g2 < l2.x.length; g2++) {
          var u2 = i2;
          i2 === 1 && g2 === 0 && (u2 = 0), i2 === 1 && g2 === 1 && (u2 = 1);
          var p3 = "apexcharts-marker";
          o2.config.chart.type !== "line" && o2.config.chart.type !== "area" || o2.globals.comboCharts || o2.config.tooltip.intersect || (p3 += " no-pointer-events");
          var f2 = Array.isArray(o2.config.markers.size) ? o2.globals.markers.size[e2] > 0 : o2.config.markers.size > 0;
          if (f2 || r2 || d2) {
            x.isNumber(l2.y[g2]) ? p3 += " w".concat(x.randomId()) : p3 = "apexcharts-nullpoint";
            var b2 = this.getMarkerConfig({ cssClass: p3, seriesIndex: e2, dataPointIndex: u2 });
            o2.config.series[n2].data[u2] && (o2.config.series[n2].data[u2].fillColor && (b2.pointFillColor = o2.config.series[n2].data[u2].fillColor), o2.config.series[n2].data[u2].strokeColor && (b2.pointStrokeColor = o2.config.series[n2].data[u2].strokeColor)), a2 && (b2.pSize = a2), (s2 = c2.drawMarker(l2.x[g2], l2.y[g2], b2)).attr("rel", u2), s2.attr("j", u2), s2.attr("index", e2), s2.node.setAttribute("default-marker-size", b2.pSize);
            var y2 = new v(this.ctx);
            y2.setSelectionFilter(s2, e2, u2), this.addEvents(s2), h3 && h3.add(s2);
          } else
            o2.globals.pointsArray[e2] === void 0 && (o2.globals.pointsArray[e2] = []), o2.globals.pointsArray[e2].push([l2.x[g2], l2.y[g2]]);
        }
      return h3;
    } }, { key: "getMarkerConfig", value: function(t3) {
      var e2 = t3.cssClass, i2 = t3.seriesIndex, a2 = t3.dataPointIndex, s2 = a2 === void 0 ? null : a2, r2 = t3.finishRadius, o2 = r2 === void 0 ? null : r2, n2 = this.w, l2 = this.getMarkerStyle(i2), h3 = n2.globals.markers.size[i2], c2 = n2.config.markers;
      return s2 !== null && c2.discrete.length && c2.discrete.map(function(t4) {
        t4.seriesIndex === i2 && t4.dataPointIndex === s2 && (l2.pointStrokeColor = t4.strokeColor, l2.pointFillColor = t4.fillColor, h3 = t4.size, l2.pointShape = t4.shape);
      }), { pSize: o2 === null ? h3 : o2, pRadius: c2.radius, width: Array.isArray(c2.width) ? c2.width[i2] : c2.width, height: Array.isArray(c2.height) ? c2.height[i2] : c2.height, pointStrokeWidth: Array.isArray(c2.strokeWidth) ? c2.strokeWidth[i2] : c2.strokeWidth, pointStrokeColor: l2.pointStrokeColor, pointFillColor: l2.pointFillColor, shape: l2.pointShape || (Array.isArray(c2.shape) ? c2.shape[i2] : c2.shape), class: e2, pointStrokeOpacity: Array.isArray(c2.strokeOpacity) ? c2.strokeOpacity[i2] : c2.strokeOpacity, pointStrokeDashArray: Array.isArray(c2.strokeDashArray) ? c2.strokeDashArray[i2] : c2.strokeDashArray, pointFillOpacity: Array.isArray(c2.fillOpacity) ? c2.fillOpacity[i2] : c2.fillOpacity, seriesIndex: i2 };
    } }, { key: "addEvents", value: function(t3) {
      var e2 = this.w, i2 = new m(this.ctx);
      t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener("click", e2.config.markers.onClick), t3.node.addEventListener("dblclick", e2.config.markers.onDblClick), t3.node.addEventListener("touchstart", i2.pathMouseDown.bind(this.ctx, t3), { passive: true });
    } }, { key: "getMarkerStyle", value: function(t3) {
      var e2 = this.w, i2 = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i2) ? i2[t3] : i2 };
    } }]), t2;
  }(), I = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return r(t2, [{ key: "draw", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = new m(this.ctx), r2 = i2.realIndex, o2 = i2.pointsPos, n2 = i2.zRatio, l2 = i2.elParent, h3 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
      if (h3.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(o2.x))
        for (var c2 = 0; c2 < o2.x.length; c2++) {
          var d2 = e2 + 1, g2 = true;
          e2 === 0 && c2 === 0 && (d2 = 0), e2 === 0 && c2 === 1 && (d2 = 1);
          var u2 = 0, p3 = a2.globals.markers.size[r2];
          if (n2 !== 1 / 0) {
            p3 = a2.globals.seriesZ[r2][d2] / n2;
            var f2 = a2.config.plotOptions.bubble;
            f2.minBubbleRadius && p3 < f2.minBubbleRadius && (p3 = f2.minBubbleRadius), f2.maxBubbleRadius && p3 > f2.maxBubbleRadius && (p3 = f2.maxBubbleRadius);
          }
          a2.config.chart.animations.enabled || (u2 = p3);
          var x2 = o2.x[c2], b2 = o2.y[c2];
          if (u2 = u2 || 0, b2 !== null && a2.globals.series[r2][d2] !== void 0 || (g2 = false), g2) {
            var v2 = this.drawPoint(x2, b2, u2, p3, r2, d2, e2);
            h3.add(v2);
          }
          l2.add(h3);
        }
    } }, { key: "drawPoint", value: function(t3, e2, i2, a2, s2, r2, o2) {
      var n2 = this.w, l2 = s2, h3 = new b(this.ctx), c2 = new v(this.ctx), d2 = new T(this.ctx), g2 = new M(this.ctx), u2 = new m(this.ctx), p3 = g2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l2, dataPointIndex: r2, finishRadius: n2.config.chart.type === "bubble" || n2.globals.comboCharts && n2.config.series[s2] && n2.config.series[s2].type === "bubble" ? a2 : null });
      a2 = p3.pSize;
      var f2, x2 = d2.fillPath({ seriesNumber: s2, dataPointIndex: r2, color: p3.pointFillColor, patternUnits: "objectBoundingBox", value: n2.globals.series[s2][o2] });
      if (p3.shape === "circle" ? f2 = u2.drawCircle(i2) : p3.shape !== "square" && p3.shape !== "rect" || (f2 = u2.drawRect(0, 0, p3.width - p3.pointStrokeWidth / 2, p3.height - p3.pointStrokeWidth / 2, p3.pRadius)), n2.config.series[l2].data[r2] && n2.config.series[l2].data[r2].fillColor && (x2 = n2.config.series[l2].data[r2].fillColor), f2.attr({ x: t3 - p3.width / 2 - p3.pointStrokeWidth / 2, y: e2 - p3.height / 2 - p3.pointStrokeWidth / 2, cx: t3, cy: e2, fill: x2, "fill-opacity": p3.pointFillOpacity, stroke: p3.pointStrokeColor, r: a2, "stroke-width": p3.pointStrokeWidth, "stroke-dasharray": p3.pointStrokeDashArray, "stroke-opacity": p3.pointStrokeOpacity }), n2.config.chart.dropShadow.enabled) {
        var y2 = n2.config.chart.dropShadow;
        c2.dropShadow(f2, y2, s2);
      }
      if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized)
        n2.globals.animationEnded = true;
      else {
        var w2 = n2.config.chart.animations.speed;
        h3.animateMarker(f2, 0, p3.shape === "circle" ? a2 : { width: p3.width, height: p3.height }, w2, n2.globals.easing, function() {
          window.setTimeout(function() {
            h3.animationCompleted(f2);
          }, 100);
        });
      }
      if (n2.globals.dataChanged && p3.shape === "circle")
        if (this.dynamicAnim) {
          var k2, A2, S2, C2, L2 = n2.config.chart.animations.dynamicAnimation.speed;
          (C2 = n2.globals.previousPaths[s2] && n2.globals.previousPaths[s2][o2]) != null && (k2 = C2.x, A2 = C2.y, S2 = C2.r !== void 0 ? C2.r : a2);
          for (var P2 = 0; P2 < n2.globals.collapsedSeries.length; P2++)
            n2.globals.collapsedSeries[P2].index === s2 && (L2 = 1, a2 = 0);
          t3 === 0 && e2 === 0 && (a2 = 0), h3.animateCircle(f2, { cx: k2, cy: A2, r: S2 }, { cx: t3, cy: e2, r: a2 }, L2, n2.globals.easing);
        } else
          f2.attr({ r: a2 });
      return f2.attr({ rel: r2, j: r2, index: s2, "default-marker-size": a2 }), c2.setSelectionFilter(f2, s2, r2), g2.addEvents(f2), f2.node.classList.add("apexcharts-marker"), f2;
    } }, { key: "centerTextInBubble", value: function(t3) {
      var e2 = this.w;
      return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), t2;
  }(), z = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "dataLabelsCorrection", value: function(t3, e2, i2, a2, s2, r2, o2) {
      var n2 = this.w, l2 = false, h3 = new m(this.ctx).getTextRects(i2, o2), c2 = h3.width, d2 = h3.height;
      e2 < 0 && (e2 = 0), e2 > n2.globals.gridHeight + d2 && (e2 = n2.globals.gridHeight + d2 / 2), n2.globals.dataLabelsRects[a2] === void 0 && (n2.globals.dataLabelsRects[a2] = []), n2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
      var g2 = n2.globals.dataLabelsRects[a2].length - 2, u2 = n2.globals.lastDrawnDataLabelsIndexes[a2] !== void 0 ? n2.globals.lastDrawnDataLabelsIndexes[a2][n2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
      if (n2.globals.dataLabelsRects[a2][g2] !== void 0) {
        var p3 = n2.globals.dataLabelsRects[a2][u2];
        (t3 > p3.x + p3.width + 2 || e2 > p3.y + p3.height + 2 || t3 + c2 < p3.x) && (l2 = true);
      }
      return (s2 === 0 || r2) && (l2 = true), { x: t3, y: e2, textRects: h3, drawnextLabel: l2 };
    } }, { key: "drawDataLabel", value: function(t3, e2, i2) {
      var a2 = this, s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2, r2 = this.w, o2 = new m(this.ctx), n2 = r2.config.dataLabels, l2 = 0, h3 = 0, c2 = i2, d2 = null;
      if (!n2.enabled || !Array.isArray(t3.x))
        return d2;
      d2 = o2.group({ class: "apexcharts-data-labels" });
      for (var g2 = 0; g2 < t3.x.length; g2++)
        if (l2 = t3.x[g2] + n2.offsetX, h3 = t3.y[g2] + n2.offsetY + s2, !isNaN(l2)) {
          i2 === 1 && g2 === 0 && (c2 = 0), i2 === 1 && g2 === 1 && (c2 = 1);
          var u2 = r2.globals.series[e2][c2], p3 = "", f2 = function(t4) {
            return r2.config.dataLabels.formatter(t4, { ctx: a2.ctx, seriesIndex: e2, dataPointIndex: c2, w: r2 });
          };
          if (r2.config.chart.type === "bubble") {
            p3 = f2(u2 = r2.globals.seriesZ[e2][c2]), h3 = t3.y[g2];
            var x2 = new I(this.ctx), b2 = x2.centerTextInBubble(h3, e2, c2);
            h3 = b2.y;
          } else
            u2 !== void 0 && (p3 = f2(u2));
          this.plotDataLabelsText({ x: l2, y: h3, text: p3, i: e2, j: c2, parent: d2, offsetCorrection: true, dataLabelsConfig: r2.config.dataLabels });
        }
      return d2;
    } }, { key: "plotDataLabelsText", value: function(t3) {
      var e2 = this.w, i2 = new m(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, o2 = t3.j, n2 = t3.text, l2 = t3.textAnchor, h3 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, g2 = t3.color, u2 = t3.alwaysDrawDataLabel, p3 = t3.offsetCorrection;
      if (!(Array.isArray(e2.config.dataLabels.enabledOnSeries) && e2.config.dataLabels.enabledOnSeries.indexOf(r2) < 0)) {
        var f2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
        p3 && (f2 = this.dataLabelsCorrection(a2, s2, n2, r2, o2, u2, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = f2.x, s2 = f2.y), f2.textRects && (a2 < -10 - f2.textRects.width || a2 > e2.globals.gridWidth + f2.textRects.width + 10) && (n2 = "");
        var x2 = e2.globals.dataLabels.style.colors[r2];
        ((e2.config.chart.type === "bar" || e2.config.chart.type === "rangeBar") && e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) && (x2 = e2.globals.dataLabels.style.colors[o2]), typeof x2 == "function" && (x2 = x2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: o2, w: e2 })), g2 && (x2 = g2);
        var b2 = d2.offsetX, y2 = d2.offsetY;
        if (e2.config.chart.type !== "bar" && e2.config.chart.type !== "rangeBar" || (b2 = 0, y2 = 0), f2.drawnextLabel) {
          var w2 = i2.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + b2, y: s2 + y2, foreColor: x2, textAnchor: l2 || d2.textAnchor, text: n2, fontSize: h3 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || "normal" });
          if (w2.attr({ class: "apexcharts-datalabel", cx: a2, cy: s2 }), d2.dropShadow.enabled) {
            var k2 = d2.dropShadow;
            new v(this.ctx).dropShadow(w2, k2);
          }
          c2.add(w2), e2.globals.lastDrawnDataLabelsIndexes[r2] === void 0 && (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(o2);
        }
      }
    } }, { key: "addBackgroundToDataLabel", value: function(t3, e2) {
      var i2 = this.w, a2 = i2.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, o2 = e2.width, n2 = e2.height, l2 = new m(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, o2 + 2 * s2, n2 + r2, a2.borderRadius, i2.config.chart.background === "transparent" ? "#fff" : i2.config.chart.background, a2.opacity, a2.borderWidth, a2.borderColor);
      a2.dropShadow.enabled && new v(this.ctx).dropShadow(l2, a2.dropShadow);
      return l2;
    } }, { key: "dataLabelsBackground", value: function() {
      var t3 = this.w;
      if (t3.config.chart.type !== "bubble")
        for (var e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i2 = 0; i2 < e2.length; i2++) {
          var a2 = e2[i2], s2 = a2.getBBox(), r2 = null;
          if (s2.width && s2.height && (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
            a2.parentNode.insertBefore(r2.node, a2);
            var o2 = a2.getAttribute("fill");
            t3.config.chart.animations.enabled && !t3.globals.resized && !t3.globals.dataChanged ? r2.animate().attr({ fill: o2 }) : r2.attr({ fill: o2 }), a2.setAttribute("fill", t3.config.dataLabels.background.foreColor);
          }
        }
    } }, { key: "bringForward", value: function() {
      for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0; a2 < e2.length; a2++)
        i2 && i2.insertBefore(e2[a2], i2.nextSibling);
    } }]), t2;
  }(), X = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.barCtx = e2;
    }
    return r(t2, [{ key: "handleBarDataLabels", value: function(t3) {
      var e2 = t3.x, i2 = t3.y, a2 = t3.y1, s2 = t3.y2, r2 = t3.i, o2 = t3.j, n2 = t3.realIndex, l2 = t3.series, h3 = t3.barHeight, c2 = t3.barWidth, d2 = t3.barYPosition, g2 = t3.visibleSeries, u2 = t3.renderedPath, p3 = this.w, f2 = new m(this.barCtx.ctx), x2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[n2] : this.barCtx.strokeWidth, b2 = e2 + parseFloat(c2 * g2), v2 = i2 + parseFloat(h3 * g2);
      p3.globals.isXNumeric && !p3.globals.isBarHorizontal && (b2 = e2 + parseFloat(c2 * (g2 + 1)), v2 = i2 + parseFloat(h3 * (g2 + 1)) - x2);
      var y2 = e2, w2 = i2, k2 = {}, A2 = p3.config.dataLabels, S2 = this.barCtx.barOptions.dataLabels;
      d2 !== void 0 && this.barCtx.isRangeBar && (v2 = d2, w2 = d2);
      var C2 = A2.offsetX, L2 = A2.offsetY, P2 = { width: 0, height: 0 };
      if (p3.config.dataLabels.enabled) {
        var T2 = this.barCtx.series[r2][o2];
        P2 = f2.getTextRects(p3.globals.yLabelFormatters[0](T2), parseFloat(A2.style.fontSize));
      }
      var M2 = { x: e2, y: i2, i: r2, j: o2, renderedPath: u2, bcx: b2, bcy: v2, barHeight: h3, barWidth: c2, textRects: P2, strokeWidth: x2, dataLabelsX: y2, dataLabelsY: w2, barDataLabelsConfig: S2, offX: C2, offY: L2 };
      return k2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(M2) : this.calculateColumnsDataLabelsPosition(M2), u2.attr({ cy: k2.bcy, cx: k2.bcx, j: o2, val: l2[r2][o2], barHeight: h3, barWidth: c2 }), this.drawCalculatedDataLabels({ x: k2.dataLabelsX, y: k2.dataLabelsY, val: this.barCtx.isRangeBar ? [a2, s2] : l2[r2][o2], i: n2, j: o2, barWidth: c2, barHeight: h3, textRects: P2, dataLabelsConfig: A2 });
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(t3) {
      var e2, i2 = this.w, a2 = t3.i, s2 = t3.j, r2 = t3.y, o2 = t3.bcx, n2 = t3.barWidth, l2 = t3.barHeight, h3 = t3.textRects, c2 = t3.dataLabelsY, d2 = t3.barDataLabelsConfig, g2 = t3.strokeWidth, u2 = t3.offX, p3 = t3.offY;
      l2 = Math.abs(l2);
      var f2 = i2.config.plotOptions.bar.dataLabels.orientation === "vertical";
      o2 -= g2 / 2;
      var x2 = i2.globals.gridWidth / i2.globals.dataPoints;
      if (e2 = i2.globals.isXNumeric ? o2 - n2 / 2 + u2 : o2 - x2 + n2 / 2 + u2, f2) {
        e2 = e2 + h3.height / 2 - g2 / 2 - 2;
      }
      var b2 = this.barCtx.series[a2][s2] < 0, v2 = r2;
      switch (this.barCtx.isReversed && (v2 = r2 - l2 + (b2 ? 2 * l2 : 0), r2 -= l2), d2.position) {
        case "center":
          c2 = f2 ? b2 ? v2 + l2 / 2 + p3 : v2 + l2 / 2 - p3 : b2 ? v2 - l2 / 2 + h3.height / 2 + p3 : v2 + l2 / 2 + h3.height / 2 - p3;
          break;
        case "bottom":
          c2 = f2 ? b2 ? v2 + l2 + p3 : v2 + l2 - p3 : b2 ? v2 - l2 + h3.height + g2 + p3 : v2 + l2 - h3.height / 2 + g2 - p3;
          break;
        case "top":
          c2 = f2 ? b2 ? v2 + p3 : v2 - p3 : b2 ? v2 - h3.height / 2 - p3 : v2 + h3.height + p3;
      }
      return i2.config.chart.stacked || (c2 < 0 ? c2 = 0 + g2 : c2 + h3.height / 3 > i2.globals.gridHeight && (c2 = i2.globals.gridHeight - g2)), { bcx: o2, bcy: r2, dataLabelsX: e2, dataLabelsY: c2 };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(t3) {
      var e2 = this.w, i2 = t3.x, a2 = t3.i, s2 = t3.j, r2 = t3.bcy, o2 = t3.barHeight, n2 = t3.barWidth, l2 = t3.textRects, h3 = t3.dataLabelsX, c2 = t3.strokeWidth, d2 = t3.barDataLabelsConfig, g2 = t3.offX, u2 = t3.offY, p3 = e2.globals.gridHeight / e2.globals.dataPoints;
      n2 = Math.abs(n2);
      var f2 = r2 - (this.barCtx.isRangeBar ? 0 : p3) + o2 / 2 + l2.height / 2 + u2 - 3, x2 = this.barCtx.series[a2][s2] < 0, b2 = i2;
      switch (this.barCtx.isReversed && (b2 = i2 + n2 - (x2 ? 2 * n2 : 0), i2 = e2.globals.gridWidth - n2), d2.position) {
        case "center":
          h3 = x2 ? b2 + n2 / 2 - g2 : Math.max(l2.width / 2, b2 - n2 / 2) + g2;
          break;
        case "bottom":
          h3 = x2 ? b2 + n2 - c2 - Math.round(l2.width / 2) - g2 : b2 - n2 + c2 + Math.round(l2.width / 2) + g2;
          break;
        case "top":
          h3 = x2 ? b2 - c2 + Math.round(l2.width / 2) - g2 : b2 - c2 - Math.round(l2.width / 2) + g2;
      }
      return e2.config.chart.stacked || (h3 < 0 ? h3 = h3 + l2.width + c2 : h3 + l2.width / 2 > e2.globals.gridWidth && (h3 = e2.globals.gridWidth - l2.width - c2)), { bcx: i2, bcy: r2, dataLabelsX: h3, dataLabelsY: f2 };
    } }, { key: "drawCalculatedDataLabels", value: function(t3) {
      var i2 = t3.x, a2 = t3.y, s2 = t3.val, r2 = t3.i, o2 = t3.j, n2 = t3.textRects, l2 = t3.barHeight, h3 = t3.barWidth, c2 = t3.dataLabelsConfig, d2 = this.w, g2 = "rotate(0)";
      d2.config.plotOptions.bar.dataLabels.orientation === "vertical" && (g2 = "rotate(-90, ".concat(i2, ", ").concat(a2, ")"));
      var u2 = new z(this.barCtx.ctx), p3 = new m(this.barCtx.ctx), f2 = c2.formatter, x2 = null, b2 = d2.globals.collapsedSeriesIndices.indexOf(r2) > -1;
      if (c2.enabled && !b2) {
        x2 = p3.group({ class: "apexcharts-data-labels", transform: g2 });
        var v2 = "";
        s2 !== void 0 && (v2 = f2(s2, { seriesIndex: r2, dataPointIndex: o2, w: d2 }));
        var y2 = d2.globals.series[r2][o2] < 0, w2 = d2.config.plotOptions.bar.dataLabels.position;
        if (d2.config.plotOptions.bar.dataLabels.orientation === "vertical" && (w2 === "top" && (c2.textAnchor = y2 ? "end" : "start"), w2 === "center" && (c2.textAnchor = "middle"), w2 === "bottom" && (c2.textAnchor = y2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)
          h3 < p3.getTextRects(v2, parseFloat(c2.style.fontSize)).width && (v2 = "");
        d2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(h3) && (v2 = "") : n2.height / 1.6 > Math.abs(l2) && (v2 = ""));
        var k2 = e({}, c2);
        this.barCtx.isHorizontal && s2 < 0 && (c2.textAnchor === "start" ? k2.textAnchor = "end" : c2.textAnchor === "end" && (k2.textAnchor = "start")), u2.plotDataLabelsText({ x: i2, y: a2, text: v2, i: r2, j: o2, parent: x2, dataLabelsConfig: k2, alwaysDrawDataLabel: true, offsetCorrection: true });
      }
      return x2;
    } }]), t2;
  }(), E = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return r(t2, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(t3) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x.escapeString(t3), "']"));
    } }, { key: "isSeriesHidden", value: function(t3) {
      var e2 = this.getSeriesByName(t3), i2 = parseInt(e2.getAttribute("data:realIndex"), 10);
      return { isHidden: e2.classList.contains("apexcharts-series-collapsed"), realIndex: i2 };
    } }, { key: "addCollapsedClassToSeries", value: function(t3, e2) {
      var i2 = this.w;
      function a2(i3) {
        for (var a3 = 0; a3 < i3.length; a3++)
          i3[a3].index === e2 && t3.node.classList.add("apexcharts-series-collapsed");
      }
      a2(i2.globals.collapsedSeries), a2(i2.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(t3) {
      var e2 = this.isSeriesHidden(t3);
      return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
    } }, { key: "showSeries", value: function(t3) {
      var e2 = this.isSeriesHidden(t3);
      e2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
    } }, { key: "hideSeries", value: function(t3) {
      var e2 = this.isSeriesHidden(t3);
      e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
    } }, { key: "resetSeries", value: function() {
      var t3 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a2 = this.w, s2 = x.clone(a2.globals.initialSeries);
      a2.globals.previousPaths = [], i2 ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 && (e2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(t3) {
      for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++)
        e2.globals.collapsedSeriesIndices.indexOf(i2) > -1 && (t3[i2].data = []);
      return t3;
    } }, { key: "toggleSeriesOnHover", value: function(t3, e2) {
      var i2 = this.w;
      e2 || (e2 = t3.target);
      var a2 = i2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
      if (t3.type === "mousemove") {
        var s2 = parseInt(e2.getAttribute("rel"), 10) - 1, r2 = null, o2 = null;
        i2.globals.axisCharts || i2.config.chart.type === "radialBar" ? i2.globals.axisCharts ? (r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s2, "']")), o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s2, "']"))) : r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "']")) : r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "'] path"));
        for (var n2 = 0; n2 < a2.length; n2++)
          a2[n2].classList.add(this.legendInactiveClass);
        r2 !== null && (i2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), o2 !== null && o2.classList.remove(this.legendInactiveClass));
      } else if (t3.type === "mouseout")
        for (var l2 = 0; l2 < a2.length; l2++)
          a2[l2].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(t3, e2) {
      var i2 = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t4) {
        for (var e3 = 0; e3 < s2.length; e3++)
          s2[e3].classList[t4](i2.legendInactiveClass);
      };
      if (t3.type === "mousemove") {
        var o2 = parseInt(e2.getAttribute("rel"), 10) - 1;
        r2("add"), function(t4) {
          for (var e3 = 0; e3 < s2.length; e3++) {
            var a3 = parseInt(s2[e3].getAttribute("val"), 10);
            a3 >= t4.from && a3 <= t4.to && s2[e3].classList.remove(i2.legendInactiveClass);
          }
        }(a2.config.plotOptions.heatmap.colorScale.ranges[o2]);
      } else
        t3.type === "mouseout" && r2("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "asc", i2 = this.w, a2 = 0;
      if (i2.config.series.length > 1) {
        for (var s2 = i2.config.series.map(function(e3, a3) {
          var s3 = false;
          return t3 && (s3 = i2.config.series[a3].type === "bar" || i2.config.series[a3].type === "column"), e3.data && e3.data.length > 0 && !s3 ? a3 : -1;
        }), r2 = e2 === "asc" ? 0 : s2.length - 1; e2 === "asc" ? r2 < s2.length : r2 >= 0; e2 === "asc" ? r2++ : r2--)
          if (s2[r2] !== -1) {
            a2 = s2[r2];
            break;
          }
      }
      return a2;
    } }, { key: "getPreviousPaths", value: function() {
      var t3 = this.w;
      function e2(e3, i3, a3) {
        for (var s3 = e3[i3].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i3].getAttribute("data:realIndex") }, o2 = 0; o2 < s3.length; o2++)
          if (s3[o2].hasAttribute("pathTo")) {
            var n2 = s3[o2].getAttribute("pathTo");
            r2.paths.push({ d: n2 });
          }
        t3.globals.previousPaths.push(r2);
      }
      t3.globals.previousPaths = [];
      ["line", "area", "bar", "rangebar", "candlestick", "radar"].forEach(function(i3) {
        for (var a3, s3 = (a3 = i3, t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a3, "-series .apexcharts-series"))), r2 = 0; r2 < s3.length; r2++)
          e2(s3, r2, i3);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series"));
      if (i2.length > 0)
        for (var a2 = function(e3) {
          for (var i3 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e3, "'] rect")), a3 = [], s3 = function(t4) {
            var e4 = function(e5) {
              return i3[t4].getAttribute(e5);
            }, s4 = { x: parseFloat(e4("x")), y: parseFloat(e4("y")), width: parseFloat(e4("width")), height: parseFloat(e4("height")) };
            a3.push({ rect: s4, color: i3[t4].getAttribute("color") });
          }, r2 = 0; r2 < i3.length; r2++)
            s3(r2);
          t3.globals.previousPaths.push(a3);
        }, s2 = 0; s2 < i2.length; s2++)
          a2(s2);
      t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(t3) {
      var e2 = this.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3, "-series .apexcharts-series"));
      if (i2.length > 0)
        for (var a2 = 0; a2 < i2.length; a2++) {
          for (var s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3, "-series .apexcharts-series[data\\:realIndex='").concat(a2, "'] circle")), r2 = [], o2 = 0; o2 < s2.length; o2++)
            r2.push({ x: s2[o2].getAttribute("cx"), y: s2[o2].getAttribute("cy"), r: s2[o2].getAttribute("r") });
          e2.globals.previousPaths.push(r2);
        }
    } }, { key: "clearPreviousPaths", value: function() {
      var t3 = this.w;
      t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
    } }, { key: "handleNoData", value: function() {
      var t3 = this.w, e2 = t3.config.noData, i2 = new m(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = "middle";
      if (t3.globals.noData = true, t3.globals.animationEnded = true, e2.align === "left" ? (a2 = 10, r2 = "start") : e2.align === "right" && (a2 = t3.globals.svgWidth - 10, r2 = "end"), e2.verticalAlign === "top" ? s2 = 50 : e2.verticalAlign === "bottom" && (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, e2.text !== void 0 && e2.text !== "") {
        var o2 = i2.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        t3.globals.dom.Paper.add(o2);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(t3) {
      for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++)
        if (t3[i2].length === 0)
          for (var a2 = 0; a2 < t3[e2.globals.maxValsInArrayIndex].length; a2++)
            t3[i2].push(0);
      return t3;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var t3 = true, e2 = this.w, i2 = this.filteredSeriesX(), a2 = 0; a2 < i2.length - 1; a2++)
        if (i2[a2][0] !== i2[a2 + 1][0]) {
          t3 = false;
          break;
        }
      return e2.globals.allSeriesHasEqualX = t3, t3;
    } }, { key: "filteredSeriesX", value: function() {
      var t3 = this.w.globals.seriesX.map(function(t4) {
        return t4.length > 0 ? t4 : [];
      });
      return t3;
    } }]), t2;
  }(), Y = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.barCtx = e2;
    }
    return r(t2, [{ key: "initVariables", value: function(t3) {
      var e2 = this.w;
      this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var i2 = 0; i2 < t3.length; i2++)
        if (t3[i2].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i2].length), e2.globals.isXNumeric)
          for (var a2 = 0; a2 < t3[i2].length; a2++)
            e2.globals.seriesX[i2][a2] > e2.globals.minX && e2.globals.seriesX[i2][a2] < e2.globals.maxX && this.barCtx.visibleItems++;
        else
          this.barCtx.visibleItems = e2.globals.dataPoints;
      this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], this.barCtx.radiusOnSeriesNumber = t3.length - 1, e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
    } }, { key: "initialPositions", value: function() {
      var t3, e2, i2, a2, s2, r2, o2, n2, l2 = this.w, h3 = l2.globals.dataPoints;
      this.barCtx.isRangeBar && (h3 = l2.globals.labels.length);
      var c2 = this.barCtx.seriesLen;
      if (l2.config.plotOptions.bar.rangeBarGroupRows && (c2 = 1), this.barCtx.isHorizontal)
        s2 = (i2 = l2.globals.gridHeight / h3) / c2, l2.globals.isXNumeric && (s2 = (i2 = l2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s2 = s2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, n2 = this.barCtx.baseLineInvertedY + l2.globals.padHorizontal + (this.barCtx.isReversed ? l2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e2 = (i2 - s2 * this.barCtx.seriesLen) / 2;
      else {
        if (a2 = l2.globals.gridWidth / this.barCtx.visibleItems, l2.config.xaxis.convertedCatToNumeric && (a2 = l2.globals.gridWidth / l2.globals.dataPoints), r2 = a2 / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l2.globals.isXNumeric) {
          var d2 = this.barCtx.xRatio;
          l2.config.xaxis.convertedCatToNumeric && (d2 = this.barCtx.initialXRatio), l2.globals.minXDiff && l2.globals.minXDiff !== 0.5 && l2.globals.minXDiff / d2 > 0 && (a2 = l2.globals.minXDiff / d2), (r2 = a2 / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r2 = 1);
        }
        o2 = l2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t3 = l2.globals.padHorizontal + (a2 - r2 * this.barCtx.seriesLen) / 2;
      }
      return { x: t3, y: e2, yDivision: i2, xDivision: a2, barHeight: s2, barWidth: r2, zeroH: o2, zeroW: n2 };
    } }, { key: "getPathFillColor", value: function(t3, e2, i2, a2) {
      var s2 = this.w, r2 = new T(this.barCtx.ctx), o2 = null, n2 = this.barCtx.barOptions.distributed ? i2 : e2;
      this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a3) {
        t3[e2][i2] >= a3.from && t3[e2][i2] <= a3.to && (o2 = a3.color);
      });
      return s2.config.series[e2].data[i2] && s2.config.series[e2].data[i2].fillColor && (o2 = s2.config.series[e2].data[i2].fillColor), r2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? n2 : a2, dataPointIndex: i2, color: o2, value: t3[e2][i2] });
    } }, { key: "getStrokeWidth", value: function(t3, e2, i2) {
      var a2 = 0, s2 = this.w;
      return this.barCtx.series[t3][e2] === void 0 || this.barCtx.series[t3][e2] === null ? this.barCtx.isNullValue = true : this.barCtx.isNullValue = false, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a2;
    } }, { key: "barBackground", value: function(t3) {
      var e2 = t3.j, i2 = t3.i, a2 = t3.x1, s2 = t3.x2, r2 = t3.y1, o2 = t3.y2, n2 = t3.elSeries, l2 = this.w, h3 = new m(this.barCtx.ctx), c2 = new E(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c2 === i2) {
        e2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], g2 = h3.drawRect(a2 !== void 0 ? a2 : 0, r2 !== void 0 ? r2 : 0, s2 !== void 0 ? s2 : l2.globals.gridWidth, o2 !== void 0 ? o2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
        n2.add(g2), g2.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(t3) {
      var e2 = t3.barWidth, i2 = t3.barXPosition, a2 = t3.yRatio, s2 = t3.y1, r2 = t3.y2, o2 = t3.strokeWidth, n2 = t3.series, l2 = t3.realIndex, h3 = t3.i, c2 = t3.j, d2 = t3.w, g2 = new m(this.barCtx.ctx);
      (o2 = Array.isArray(o2) ? o2[l2] : o2) || (o2 = 0);
      var u2 = { barWidth: e2, strokeWidth: o2, yRatio: a2, barXPosition: i2, y1: s2, y2: r2 }, p3 = this.getRoundedBars(d2, u2, n2, h3, c2), f2 = i2, x2 = i2 + e2, b2 = g2.move(f2, s2), v2 = g2.move(f2, s2), y2 = g2.line(x2 - o2, s2);
      return d2.globals.previousPaths.length > 0 && (v2 = this.barCtx.getPreviousPath(l2, c2, false)), b2 = b2 + g2.line(f2, p3.y2) + p3.pathWithRadius + g2.line(x2 - o2, p3.y2) + y2 + y2 + "z", v2 = v2 + g2.line(f2, s2) + y2 + y2 + y2 + y2 + y2 + g2.line(f2, s2), d2.config.chart.stacked && (this.barCtx.yArrj.push(p3.y2), this.barCtx.yArrjF.push(Math.abs(s2 - p3.y2)), this.barCtx.yArrjVal.push(this.barCtx.series[h3][c2])), { pathTo: b2, pathFrom: v2 };
    } }, { key: "getBarpaths", value: function(t3) {
      var e2 = t3.barYPosition, i2 = t3.barHeight, a2 = t3.x1, s2 = t3.x2, r2 = t3.strokeWidth, o2 = t3.series, n2 = t3.realIndex, l2 = t3.i, h3 = t3.j, c2 = t3.w, d2 = new m(this.barCtx.ctx);
      (r2 = Array.isArray(r2) ? r2[n2] : r2) || (r2 = 0);
      var g2 = { barHeight: i2, strokeWidth: r2, barYPosition: e2, x2: s2, x1: a2 }, u2 = this.getRoundedBars(c2, g2, o2, l2, h3), p3 = d2.move(a2, e2), f2 = d2.move(a2, e2);
      c2.globals.previousPaths.length > 0 && (f2 = this.barCtx.getPreviousPath(n2, h3, false));
      var x2 = e2, b2 = e2 + i2, v2 = d2.line(a2, b2 - r2);
      return p3 = p3 + d2.line(u2.x2, x2) + u2.pathWithRadius + d2.line(u2.x2, b2 - r2) + v2 + v2 + "z", f2 = f2 + d2.line(a2, x2) + v2 + v2 + v2 + v2 + v2 + d2.line(a2, x2), c2.config.chart.stacked && (this.barCtx.xArrj.push(u2.x2), this.barCtx.xArrjF.push(Math.abs(a2 - u2.x2)), this.barCtx.xArrjVal.push(this.barCtx.series[l2][h3])), { pathTo: p3, pathFrom: f2 };
    } }, { key: "getRoundedBars", value: function(t3, e2, i2, a2, s2) {
      var r2 = new m(this.barCtx.ctx), o2 = 0, n2 = t3.config.plotOptions.bar.borderRadius, l2 = Array.isArray(n2);
      l2 ? o2 = n2[a2 > n2.length - 1 ? n2.length - 1 : a2] : o2 = n2;
      if (t3.config.chart.stacked && i2.length > 1 && a2 !== this.barCtx.radiusOnSeriesNumber && !l2 && (o2 = 0), this.barCtx.isHorizontal) {
        var h3 = "", c2 = e2.x2;
        if (Math.abs(e2.x1 - e2.x2) < o2 && (o2 = Math.abs(e2.x1 - e2.x2)), i2[a2][s2] !== void 0 || i2[a2][s2] !== null) {
          var d2 = this.barCtx.isReversed ? i2[a2][s2] > 0 : i2[a2][s2] < 0;
          d2 && (o2 *= -1), c2 -= o2, h3 = r2.quadraticCurve(c2 + o2, e2.barYPosition, c2 + o2, e2.barYPosition + (d2 ? -1 * o2 : o2)) + r2.line(c2 + o2, e2.barYPosition + e2.barHeight - e2.strokeWidth - (d2 ? -1 * o2 : o2)) + r2.quadraticCurve(c2 + o2, e2.barYPosition + e2.barHeight - e2.strokeWidth, c2, e2.barYPosition + e2.barHeight - e2.strokeWidth);
        }
        return { pathWithRadius: h3, x2: c2 };
      }
      var g2 = "", u2 = e2.y2;
      if (Math.abs(e2.y1 - e2.y2) < o2 && (o2 = Math.abs(e2.y1 - e2.y2)), i2[a2][s2] !== void 0 || i2[a2][s2] !== null) {
        var p3 = i2[a2][s2] < 0;
        p3 && (o2 *= -1), u2 += o2, g2 = r2.quadraticCurve(e2.barXPosition, u2 - o2, e2.barXPosition + (p3 ? -1 * o2 : o2), u2 - o2) + r2.line(e2.barXPosition + e2.barWidth - e2.strokeWidth - (p3 ? -1 * o2 : o2), u2 - o2) + r2.quadraticCurve(e2.barXPosition + e2.barWidth - e2.strokeWidth, u2 - o2, e2.barXPosition + e2.barWidth - e2.strokeWidth, u2);
      }
      return { pathWithRadius: g2, y2: u2 };
    } }, { key: "checkZeroSeries", value: function(t3) {
      for (var e2 = t3.series, i2 = this.w, a2 = 0; a2 < e2.length; a2++) {
        for (var s2 = 0, r2 = 0; r2 < e2[i2.globals.maxValsInArrayIndex].length; r2++)
          s2 += e2[a2][r2];
        s2 === 0 && this.barCtx.zeroSerieses.push(a2);
      }
      for (var o2 = e2.length - 1; o2 >= 0; o2--)
        this.barCtx.zeroSerieses.indexOf(o2) > -1 && o2 === this.radiusOnSeriesNumber && (this.barCtx.radiusOnSeriesNumber -= 1);
      for (var n2 = e2.length - 1; n2 >= 0; n2--)
        i2.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 && (this.barCtx.radiusOnSeriesNumber -= 1);
    } }, { key: "getXForValue", value: function(t3, e2) {
      var i2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a2 = i2 ? e2 : null;
      return t3 != null && (a2 = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), a2;
    } }, { key: "getYForValue", value: function(t3, e2) {
      var i2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a2 = i2 ? e2 : null;
      return t3 != null && (a2 = e2 - t3 / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), a2;
    } }, { key: "getGoalValues", value: function(t3, e2, i2, a2, s2) {
      var r2 = this, n2 = this.w, l2 = [];
      return n2.globals.seriesGoals[a2] && n2.globals.seriesGoals[a2][s2] && Array.isArray(n2.globals.seriesGoals[a2][s2]) && n2.globals.seriesGoals[a2][s2].forEach(function(a3) {
        var s3;
        l2.push((o(s3 = {}, t3, t3 === "x" ? r2.getXForValue(a3.value, e2, false) : r2.getYForValue(a3.value, i2, false)), o(s3, "attrs", a3), s3));
      }), l2;
    } }, { key: "drawGoalLine", value: function(t3) {
      var e2 = t3.barXPosition, i2 = t3.barYPosition, a2 = t3.goalX, s2 = t3.goalY, r2 = t3.barWidth, o2 = t3.barHeight, n2 = new m(this.barCtx.ctx), l2 = n2.group({ className: "apexcharts-bar-goals-groups" }), h3 = null;
      return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach(function(t4) {
        var e3 = t4.attrs.strokeHeight !== void 0 ? t4.attrs.strokeHeight : o2 / 2, a3 = i2 + e3 + o2 / 2;
        h3 = n2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h3);
      }) : Array.isArray(s2) && s2.forEach(function(t4) {
        var i3 = t4.attrs.strokeWidth !== void 0 ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i3 + r2 / 2;
        h3 = n2.drawLine(a3 - 2 * i3, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h3);
      }), l2;
    } }]), t2;
  }(), F = function() {
    function t2(e2, i2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var s2 = this.w;
      this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRangeBar.length && this.isHorizontal, this.xyRatios = i2, this.xyRatios !== null && (this.xRatio = i2.xRatio, this.initialXRatio = i2.initialXRatio, this.yRatio = i2.yRatio, this.invertedXRatio = i2.invertedXRatio, this.invertedYRatio = i2.invertedYRatio, this.baseLineY = i2.baseLineY, this.baseLineInvertedY = i2.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new Y(this);
    }
    return r(t2, [{ key: "draw", value: function(t3, i2) {
      var a2 = this.w, s2 = new m(this.ctx), r2 = new y(this.ctx, a2);
      t3 = r2.getLogSeries(t3), this.series = t3, this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
      var o2 = s2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      a2.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
      for (var n2 = 0, l2 = 0; n2 < t3.length; n2++, l2++) {
        var h3, c2, d2, g2, u2 = void 0, p3 = void 0, f2 = [], b2 = [], v2 = a2.globals.comboCharts ? i2[n2] : n2, w2 = s2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: x.escapeString(a2.globals.seriesNames[v2]), "data:realIndex": v2 });
        this.ctx.series.addCollapsedClassToSeries(w2, v2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
        var k2 = 0, A2 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = v2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed;
        var S2 = this.barHelpers.initialPositions();
        p3 = S2.y, k2 = S2.barHeight, c2 = S2.yDivision, g2 = S2.zeroW, u2 = S2.x, A2 = S2.barWidth, h3 = S2.xDivision, d2 = S2.zeroH, this.horizontal || b2.push(u2 + A2 / 2);
        for (var C2 = s2.group({ class: "apexcharts-datalabels", "data:realIndex": v2 }), L2 = s2.group({ class: "apexcharts-bar-goals-markers", style: "pointer-events: none" }), P2 = 0; P2 < a2.globals.dataPoints; P2++) {
          var T2 = this.barHelpers.getStrokeWidth(n2, P2, v2), M2 = null, I2 = { indexes: { i: n2, j: P2, realIndex: v2, bc: l2 }, x: u2, y: p3, strokeWidth: T2, elSeries: w2 };
          this.isHorizontal ? (M2 = this.drawBarPaths(e(e({}, I2), {}, { barHeight: k2, zeroW: g2, yDivision: c2 })), A2 = this.series[n2][P2] / this.invertedYRatio) : (M2 = this.drawColumnPaths(e(e({}, I2), {}, { xDivision: h3, barWidth: A2, zeroH: d2 })), k2 = this.series[n2][P2] / this.yRatio[this.yaxisIndex]);
          var z2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: M2.barYPosition, goalX: M2.goalX, goalY: M2.goalY, barHeight: k2, barWidth: A2 });
          z2 && L2.add(z2), p3 = M2.y, u2 = M2.x, P2 > 0 && b2.push(u2 + A2 / 2), f2.push(p3);
          var X2 = this.barHelpers.getPathFillColor(t3, n2, P2, v2);
          this.renderSeries({ realIndex: v2, pathFill: X2, j: P2, i: n2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: T2, elSeries: w2, x: u2, y: p3, series: t3, barHeight: k2, barWidth: A2, elDataLabelsWrap: C2, elGoalsMarkers: L2, visibleSeries: this.visibleI, type: "bar" });
        }
        a2.globals.seriesXvalues[v2] = b2, a2.globals.seriesYvalues[v2] = f2, o2.add(w2);
      }
      return o2;
    } }, { key: "renderSeries", value: function(t3) {
      var e2 = t3.realIndex, i2 = t3.pathFill, a2 = t3.lineFill, s2 = t3.j, r2 = t3.i, o2 = t3.pathFrom, n2 = t3.pathTo, l2 = t3.strokeWidth, h3 = t3.elSeries, c2 = t3.x, d2 = t3.y, g2 = t3.y1, u2 = t3.y2, p3 = t3.series, f2 = t3.barHeight, x2 = t3.barWidth, b2 = t3.barYPosition, y2 = t3.elDataLabelsWrap, w2 = t3.elGoalsMarkers, k2 = t3.visibleSeries, A2 = t3.type, S2 = this.w, C2 = new m(this.ctx);
      a2 || (a2 = this.barOptions.distributed ? S2.globals.stroke.colors[s2] : S2.globals.stroke.colors[e2]), S2.config.series[r2].data[s2] && S2.config.series[r2].data[s2].strokeColor && (a2 = S2.config.series[r2].data[s2].strokeColor), this.isNullValue && (i2 = "none");
      var L2 = s2 / S2.config.chart.animations.animateGradually.delay * (S2.config.chart.animations.speed / S2.globals.dataPoints) / 2.4, P2 = C2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: o2, pathTo: n2, stroke: a2, strokeWidth: l2, strokeLineCap: S2.config.stroke.lineCap, fill: i2, animationDelay: L2, initialSpeed: S2.config.chart.animations.speed, dataChangeSpeed: S2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(A2, "-area") });
      P2.attr("clip-path", "url(#gridRectMask".concat(S2.globals.cuid, ")"));
      var T2 = S2.config.forecastDataPoints;
      T2.count > 0 && s2 >= S2.globals.dataPoints - T2.count && (P2.node.setAttribute("stroke-dasharray", T2.dashArray), P2.node.setAttribute("stroke-width", T2.strokeWidth), P2.node.setAttribute("fill-opacity", T2.fillOpacity)), g2 !== void 0 && u2 !== void 0 && (P2.attr("data-range-y1", g2), P2.attr("data-range-y2", u2)), new v(this.ctx).setSelectionFilter(P2, e2, s2), h3.add(P2);
      var M2 = new X(this).handleBarDataLabels({ x: c2, y: d2, y1: g2, y2: u2, i: r2, j: s2, series: p3, realIndex: e2, barHeight: f2, barWidth: x2, barYPosition: b2, renderedPath: P2, visibleSeries: k2 });
      return M2 !== null && y2.add(M2), h3.add(y2), w2 && h3.add(w2), h3;
    } }, { key: "drawBarPaths", value: function(t3) {
      var e2 = t3.indexes, i2 = t3.barHeight, a2 = t3.strokeWidth, s2 = t3.zeroW, r2 = t3.x, o2 = t3.y, n2 = t3.yDivision, l2 = t3.elSeries, h3 = this.w, c2 = e2.i, d2 = e2.j;
      h3.globals.isXNumeric && (o2 = (h3.globals.seriesX[c2][d2] - h3.globals.minX) / this.invertedXRatio - i2);
      var g2 = o2 + i2 * this.visibleI;
      r2 = this.barHelpers.getXForValue(this.series[c2][d2], s2);
      var u2 = this.barHelpers.getBarpaths({ barYPosition: g2, barHeight: i2, x1: s2, x2: r2, strokeWidth: a2, series: this.series, realIndex: e2.realIndex, i: c2, j: d2, w: h3 });
      return h3.globals.isXNumeric || (o2 += n2), this.barHelpers.barBackground({ j: d2, i: c2, y1: g2 - i2 * this.visibleI, y2: i2 * this.seriesLen, elSeries: l2 }), { pathTo: u2.pathTo, pathFrom: u2.pathFrom, x: r2, y: o2, goalX: this.barHelpers.getGoalValues("x", s2, null, c2, d2), barYPosition: g2 };
    } }, { key: "drawColumnPaths", value: function(t3) {
      var e2 = t3.indexes, i2 = t3.x, a2 = t3.y, s2 = t3.xDivision, r2 = t3.barWidth, o2 = t3.zeroH, n2 = t3.strokeWidth, l2 = t3.elSeries, h3 = this.w, c2 = e2.realIndex, d2 = e2.i, g2 = e2.j, u2 = e2.bc;
      if (h3.globals.isXNumeric) {
        var p3 = c2;
        h3.globals.seriesX[c2].length || (p3 = h3.globals.maxValsInArrayIndex), i2 = (h3.globals.seriesX[p3][g2] - h3.globals.minX) / this.xRatio - r2 * this.seriesLen / 2;
      }
      var f2 = i2 + r2 * this.visibleI;
      a2 = this.barHelpers.getYForValue(this.series[d2][g2], o2);
      var x2 = this.barHelpers.getColumnPaths({ barXPosition: f2, barWidth: r2, y1: o2, y2: a2, strokeWidth: n2, series: this.series, realIndex: e2.realIndex, i: d2, j: g2, w: h3 });
      return h3.globals.isXNumeric || (i2 += s2), this.barHelpers.barBackground({ bc: u2, j: g2, i: d2, x1: f2 - n2 / 2 - r2 * this.visibleI, x2: r2 * this.seriesLen + n2 / 2, elSeries: l2 }), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, x: i2, y: a2, goalY: this.barHelpers.getGoalValues("y", null, o2, d2, g2), barXPosition: f2 };
    } }, { key: "getPreviousPath", value: function(t3, e2) {
      for (var i2, a2 = this.w, s2 = 0; s2 < a2.globals.previousPaths.length; s2++) {
        var r2 = a2.globals.previousPaths[s2];
        r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t3, 10) && a2.globals.previousPaths[s2].paths[e2] !== void 0 && (i2 = a2.globals.previousPaths[s2].paths[e2].d);
      }
      return i2;
    } }]), t2;
  }(), R = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return r(t2, [{ key: "isValidDate", value: function(t3) {
      return !isNaN(this.parseDate(t3));
    } }, { key: "getTimeStamp", value: function(t3) {
      return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
    } }, { key: "getDate", value: function(t3) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
    } }, { key: "parseDate", value: function(t3) {
      var e2 = Date.parse(t3);
      if (!isNaN(e2))
        return this.getTimeStamp(t3);
      var i2 = Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i2 = this.getTimeStamp(i2);
    } }, { key: "parseDateWithTimezone", value: function(t3) {
      return Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(t3, e2) {
      var i2 = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(u(i2.months)), r2 = [""].concat(u(i2.shortMonths)), o2 = [""].concat(u(i2.days)), n2 = [""].concat(u(i2.shortDays));
      function l2(t4, e3) {
        var i3 = t4 + "";
        for (e3 = e3 || 2; i3.length < e3; )
          i3 = "0" + i3;
        return i3;
      }
      var h3 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
      e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, "$1" + h3)).replace(/(^|[^\\])yy/g, "$1" + h3.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h3);
      var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
      e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l2(c2))).replace(/(^|[^\\])M/g, "$1" + c2);
      var d2 = a2 ? t3.getUTCDate() : t3.getDate();
      e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, "$1" + o2[0])).replace(/(^|[^\\])ddd/g, "$1" + n2[0])).replace(/(^|[^\\])dd/g, "$1" + l2(d2))).replace(/(^|[^\\])d/g, "$1" + d2);
      var g2 = a2 ? t3.getUTCHours() : t3.getHours(), p3 = g2 > 12 ? g2 - 12 : g2 === 0 ? 12 : g2;
      e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, "$1" + l2(g2))).replace(/(^|[^\\])H/g, "$1" + g2)).replace(/(^|[^\\])hh+/g, "$1" + l2(p3))).replace(/(^|[^\\])h/g, "$1" + p3);
      var f2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
      e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, "$1" + l2(f2))).replace(/(^|[^\\])m/g, "$1" + f2);
      var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
      e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, "$1" + l2(x2))).replace(/(^|[^\\])s/g, "$1" + x2);
      var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
      e2 = e2.replace(/(^|[^\\])fff+/g, "$1" + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, "$1" + l2(b2)), b2 = Math.round(b2 / 10);
      var v2 = g2 < 12 ? "AM" : "PM";
      e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, "$1" + b2)).replace(/(^|[^\\])TT+/g, "$1" + v2)).replace(/(^|[^\\])T/g, "$1" + v2.charAt(0));
      var m2 = v2.toLowerCase();
      e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, "$1" + m2)).replace(/(^|[^\\])t/g, "$1" + m2.charAt(0));
      var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? "Z" : y2 > 0 ? "+" : "-";
      if (!a2) {
        var k2 = (y2 = Math.abs(y2)) % 60;
        w2 += l2(Math.floor(y2 / 60)) + ":" + l2(k2);
      }
      e2 = e2.replace(/(^|[^\\])K/g, "$1" + w2);
      var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
      return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(o2[0], "g"), o2[A2])).replace(new RegExp(n2[0], "g"), n2[A2])).replace(new RegExp(s2[0], "g"), s2[c2])).replace(new RegExp(r2[0], "g"), r2[c2])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(t3, e2, i2) {
      var a2 = this.w;
      a2.config.xaxis.min !== void 0 && (t3 = a2.config.xaxis.min), a2.config.xaxis.max !== void 0 && (e2 = a2.config.xaxis.max);
      var s2 = this.getDate(t3), r2 = this.getDate(e2), o2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), n2 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(o2[6], 10), maxMillisecond: parseInt(n2[6], 10), minSecond: parseInt(o2[5], 10), maxSecond: parseInt(n2[5], 10), minMinute: parseInt(o2[4], 10), maxMinute: parseInt(n2[4], 10), minHour: parseInt(o2[3], 10), maxHour: parseInt(n2[3], 10), minDate: parseInt(o2[2], 10), maxDate: parseInt(n2[2], 10), minMonth: parseInt(o2[1], 10) - 1, maxMonth: parseInt(n2[1], 10) - 1, minYear: parseInt(o2[0], 10), maxYear: parseInt(n2[0], 10) };
    } }, { key: "isLeapYear", value: function(t3) {
      return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(t3, e2, i2) {
      return this.determineDaysOfMonths(t3, e2) - i2;
    } }, { key: "determineDaysOfYear", value: function(t3) {
      var e2 = 365;
      return this.isLeapYear(t3) && (e2 = 366), e2;
    } }, { key: "determineRemainingDaysOfYear", value: function(t3, e2, i2) {
      var a2 = this.daysCntOfYear[e2] + i2;
      return e2 > 1 && this.isLeapYear() && a2++, a2;
    } }, { key: "determineDaysOfMonths", value: function(t3, e2) {
      var i2 = 30;
      switch (t3 = x.monthMod(t3), true) {
        case this.months30.indexOf(t3) > -1:
          t3 === 2 && (i2 = this.isLeapYear(e2) ? 29 : 28);
          break;
        case this.months31.indexOf(t3) > -1:
        default:
          i2 = 31;
      }
      return i2;
    } }]), t2;
  }(), H = function(t2) {
    n(s2, F);
    var i2 = d(s2);
    function s2() {
      return a(this, s2), i2.apply(this, arguments);
    }
    return r(s2, [{ key: "draw", value: function(t3, i3) {
      var a2 = this.w, s3 = new m(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = a2.globals.seriesRangeStart, this.seriesRangeEnd = a2.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
      for (var r2 = s3.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), o2 = 0; o2 < t3.length; o2++) {
        var n2, l2, h3, c2 = void 0, d2 = void 0, g2 = void 0, u2 = a2.globals.comboCharts ? i3[o2] : o2, p3 = s3.group({ class: "apexcharts-series", seriesName: x.escapeString(a2.globals.seriesNames[u2]), rel: o2 + 1, "data:realIndex": u2 });
        this.ctx.series.addCollapsedClassToSeries(p3, u2), t3[o2].length > 0 && (this.visibleI = this.visibleI + 1);
        var f2 = 0, b2 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = u2);
        var v2 = this.barHelpers.initialPositions();
        d2 = v2.y, h3 = v2.zeroW, c2 = v2.x, b2 = v2.barWidth, n2 = v2.xDivision, l2 = v2.zeroH;
        for (var y2 = s3.group({ class: "apexcharts-datalabels", "data:realIndex": u2 }), w2 = s3.group({ class: "apexcharts-rangebar-goals-markers", style: "pointer-events: none" }), k2 = 0; k2 < a2.globals.dataPoints; k2++) {
          var A2 = this.barHelpers.getStrokeWidth(o2, k2, u2), S2 = this.seriesRangeStart[o2][k2], C2 = this.seriesRangeEnd[o2][k2], L2 = null, P2 = null, T2 = { x: c2, y: d2, strokeWidth: A2, elSeries: p3 };
          if (g2 = v2.yDivision, f2 = v2.barHeight, this.isHorizontal) {
            P2 = d2 + f2 * this.visibleI;
            var M2 = this.seriesLen;
            a2.config.plotOptions.bar.rangeBarGroupRows && (M2 = 1);
            var I2 = (g2 - f2 * M2) / 2;
            if (a2.config.series[o2].data[k2] === void 0)
              break;
            if (a2.config.series[o2].data[k2].x) {
              var z2 = this.detectOverlappingBars({ i: o2, j: k2, barYPosition: P2, srty: I2, barHeight: f2, yDivision: g2, initPositions: v2 });
              f2 = z2.barHeight, P2 = z2.barYPosition;
            }
            b2 = (L2 = this.drawRangeBarPaths(e({ indexes: { i: o2, j: k2, realIndex: u2 }, barHeight: f2, barYPosition: P2, zeroW: h3, yDivision: g2, y1: S2, y2: C2 }, T2))).barWidth;
          } else
            f2 = (L2 = this.drawRangeColumnPaths(e({ indexes: { i: o2, j: k2, realIndex: u2 }, zeroH: l2, barWidth: b2, xDivision: n2 }, T2))).barHeight;
          var X2 = this.barHelpers.drawGoalLine({ barXPosition: L2.barXPosition, barYPosition: P2, goalX: L2.goalX, goalY: L2.goalY, barHeight: f2, barWidth: b2 });
          X2 && w2.add(X2), d2 = L2.y, c2 = L2.x;
          var E2 = this.barHelpers.getPathFillColor(t3, o2, k2, u2), Y2 = a2.globals.stroke.colors[u2];
          this.renderSeries({ realIndex: u2, pathFill: E2, lineFill: Y2, j: k2, i: o2, x: c2, y: d2, y1: S2, y2: C2, pathFrom: L2.pathFrom, pathTo: L2.pathTo, strokeWidth: A2, elSeries: p3, series: t3, barHeight: f2, barYPosition: P2, barWidth: b2, elDataLabelsWrap: y2, elGoalsMarkers: w2, visibleSeries: this.visibleI, type: "rangebar" });
        }
        r2.add(p3);
      }
      return r2;
    } }, { key: "detectOverlappingBars", value: function(t3) {
      var e2 = t3.i, i3 = t3.j, a2 = t3.barYPosition, s3 = t3.srty, r2 = t3.barHeight, o2 = t3.yDivision, n2 = t3.initPositions, l2 = this.w, h3 = [], c2 = l2.config.series[e2].data[i3].rangeName, d2 = l2.config.series[e2].data[i3].x, g2 = l2.globals.labels.indexOf(d2), u2 = l2.globals.seriesRangeBar[e2].findIndex(function(t4) {
        return t4.x === d2 && t4.overlaps.length > 0;
      });
      return a2 = l2.config.plotOptions.bar.rangeBarGroupRows ? s3 + o2 * g2 : s3 + r2 * this.visibleI + o2 * g2, u2 > -1 && !l2.config.plotOptions.bar.rangeBarOverlap && (h3 = l2.globals.seriesRangeBar[e2][u2].overlaps).indexOf(c2) > -1 && (a2 = (r2 = n2.barHeight / h3.length) * this.visibleI + o2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r2 * (this.visibleI + h3.indexOf(c2)) + o2 * g2), { barYPosition: a2, barHeight: r2 };
    } }, { key: "drawRangeColumnPaths", value: function(t3) {
      var e2 = t3.indexes, i3 = t3.x;
      t3.strokeWidth;
      var a2 = t3.xDivision, s3 = t3.barWidth, r2 = t3.zeroH, o2 = this.w, n2 = e2.i, l2 = e2.j, h3 = this.yRatio[this.yaxisIndex], c2 = e2.realIndex, d2 = this.getRangeValue(c2, l2), g2 = Math.min(d2.start, d2.end), u2 = Math.max(d2.start, d2.end);
      o2.globals.isXNumeric && (i3 = (o2.globals.seriesX[n2][l2] - o2.globals.minX) / this.xRatio - s3 / 2);
      var p3 = i3 + s3 * this.visibleI;
      this.series[n2][l2] === void 0 || this.series[n2][l2] === null ? g2 = r2 : (g2 = r2 - g2 / h3, u2 = r2 - u2 / h3);
      var f2 = Math.abs(u2 - g2), x2 = this.barHelpers.getColumnPaths({ barXPosition: p3, barWidth: s3, y1: g2, y2: u2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: e2.realIndex, i: c2, j: l2, w: o2 });
      return o2.globals.isXNumeric || (i3 += a2), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barHeight: f2, x: i3, y: u2, goalY: this.barHelpers.getGoalValues("y", null, r2, n2, l2), barXPosition: p3 };
    } }, { key: "drawRangeBarPaths", value: function(t3) {
      var e2 = t3.indexes, i3 = t3.y, a2 = t3.y1, s3 = t3.y2, r2 = t3.yDivision, o2 = t3.barHeight, n2 = t3.barYPosition, l2 = t3.zeroW, h3 = this.w, c2 = l2 + a2 / this.invertedYRatio, d2 = l2 + s3 / this.invertedYRatio, g2 = Math.abs(d2 - c2), u2 = this.barHelpers.getBarpaths({ barYPosition: n2, barHeight: o2, x1: c2, x2: d2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: e2.realIndex, realIndex: e2.realIndex, j: e2.j, w: h3 });
      return h3.globals.isXNumeric || (i3 += r2), { pathTo: u2.pathTo, pathFrom: u2.pathFrom, barWidth: g2, x: d2, goalX: this.barHelpers.getGoalValues("x", l2, null, e2.realIndex, e2.j), y: i3 };
    } }, { key: "getRangeValue", value: function(t3, e2) {
      var i3 = this.w;
      return { start: i3.globals.seriesRangeStart[t3][e2], end: i3.globals.seriesRangeEnd[t3][e2] };
    } }, { key: "getTooltipValues", value: function(t3) {
      var e2 = t3.ctx, i3 = t3.seriesIndex, a2 = t3.dataPointIndex, s3 = t3.y1, r2 = t3.y2, o2 = t3.w, n2 = o2.globals.seriesRangeStart[i3][a2], l2 = o2.globals.seriesRangeEnd[i3][a2], h3 = o2.globals.labels[a2], c2 = o2.config.series[i3].name ? o2.config.series[i3].name : "", d2 = o2.config.tooltip.y.formatter, g2 = o2.config.tooltip.y.title.formatter, u2 = { w: o2, seriesIndex: i3, dataPointIndex: a2, start: n2, end: l2 };
      typeof g2 == "function" && (c2 = g2(c2, u2)), Number.isFinite(s3) && Number.isFinite(r2) && (n2 = s3, l2 = r2, o2.config.series[i3].data[a2].x && (h3 = o2.config.series[i3].data[a2].x + ":"), typeof d2 == "function" && (h3 = d2(h3, u2)));
      var p3 = "", f2 = "", x2 = o2.globals.colors[i3];
      if (o2.config.tooltip.x.formatter === void 0)
        if (o2.config.xaxis.type === "datetime") {
          var b2 = new R(e2);
          p3 = b2.formatDate(b2.getDate(n2), o2.config.tooltip.x.format), f2 = b2.formatDate(b2.getDate(l2), o2.config.tooltip.x.format);
        } else
          p3 = n2, f2 = l2;
      else
        p3 = o2.config.tooltip.x.formatter(n2), f2 = o2.config.tooltip.x.formatter(l2);
      return { start: n2, end: l2, startVal: p3, endVal: f2, ylabel: h3, color: x2, seriesName: c2 };
    } }, { key: "buildCustomTooltipHTML", value: function(t3) {
      var e2 = t3.color, i3 = t3.seriesName;
      return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (i3 || "") + '</span></div><div> <span class="category">' + t3.ylabel + ' </span> <span class="value start-value">' + t3.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t3.end + "</span></div></div>";
    } }]), s2;
  }(), D = function() {
    function t2(e2) {
      a(this, t2), this.opts = e2;
    }
    return r(t2, [{ key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(t3) {
      this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
      return x.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
    } }, { key: "bar", value: function() {
      return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
    } }, { key: "candlestick", value: function() {
      var t3 = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
        var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
        return t3._getBoxTooltip(s2, i2, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var t3 = this;
      return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
        var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
        return t3._getBoxTooltip(s2, i2, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
        e2.ctx;
        var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w, r2 = s2.globals.seriesRangeStart[i2][a2];
        return s2.globals.seriesRangeEnd[i2][a2] - r2;
      }, background: { enabled: false }, style: { colors: ["#fff"] } }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
        return t3.w.config.plotOptions && t3.w.config.plotOptions.bar && t3.w.config.plotOptions.bar.horizontal ? function(t4) {
          var e2 = new H(t4.ctx, null), i2 = e2.getTooltipValues(t4), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.startVal, n2 = i2.endVal;
          return e2.buildCustomTooltipHTML({ color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 });
        }(t3) : function(t4) {
          var e2 = new H(t4.ctx, null), i2 = e2.getTooltipValues(t4), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.start, n2 = i2.end;
          return e2.buildCustomTooltipHTML({ color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 });
        }(t3);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "area", value: function() {
      return { stroke: { width: 4 }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
    } }, { key: "brush", value: function(t3) {
      return x.extend(t3, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
    } }, { key: "stacked100", value: function(t3) {
      t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || void 0;
      var e2 = t3.dataLabels.formatter;
      return t3.yaxis.forEach(function(e3, i2) {
        t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
      }), t3.chart.type === "bar" && (t3.dataLabels.formatter = e2 || function(t4) {
        return typeof t4 == "number" && t4 ? t4.toFixed(0) + "%" : t4;
      }), t3;
    } }, { key: "convertCatToNumeric", value: function(t3) {
      return t3.xaxis.convertedCatToNumeric = true, t3;
    } }, { key: "convertCatToNumericXaxis", value: function(t3, e2, i2) {
      t3.xaxis.type = "numeric", t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
        return x.isNumber(t4) ? Math.floor(t4) : t4;
      };
      var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories && t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
      return i2 && i2.length && (s2 = i2.map(function(t4) {
        return Array.isArray(t4) ? t4 : String(t4);
      })), s2 && s2.length && (t3.xaxis.labels.formatter = function(t4) {
        return x.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
      }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || "dataPoints", t3;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
        return t3.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
        return t3.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
        return t3.toFixed(1) + "%";
      }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { labels: { formatter: function(t3) {
        return t3;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
    } }, { key: "_getBoxTooltip", value: function(t3, e2, i2, a2, s2) {
      var r2 = t3.globals.seriesCandleO[e2][i2], o2 = t3.globals.seriesCandleH[e2][i2], n2 = t3.globals.seriesCandleM[e2][i2], l2 = t3.globals.seriesCandleL[e2][i2], h3 = t3.globals.seriesCandleC[e2][i2];
      return t3.config.series[e2].type && t3.config.series[e2].type !== s2 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t3.config.series[e2].name ? t3.config.series[e2].name : "series-" + (e2 + 1), ": <strong>").concat(t3.globals.series[e2][i2], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t3.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + o2 + "</span></div>" + (n2 ? "<div>".concat(a2[2], ': <span class="value">') + n2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + l2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + h3 + "</span></div></div>";
    } }]), t2;
  }(), N = function() {
    function t2(e2) {
      a(this, t2), this.opts = e2;
    }
    return r(t2, [{ key: "init", value: function(t3) {
      var e2 = t3.responsiveOverride, a2 = this.opts, s2 = new L(), r2 = new D(a2);
      this.chartType = a2.chart.type, this.chartType === "histogram" && (a2.chart.type = "bar", a2 = x.extend({ plotOptions: { bar: { columnWidth: "99.99%" } } }, a2)), a2 = this.extendYAxis(a2), a2 = this.extendAnnotations(a2);
      var o2 = s2.init(), n2 = {};
      if (a2 && i(a2) === "object") {
        var l2 = {};
        l2 = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a2.chart.type) !== -1 ? r2[a2.chart.type]() : r2.line(), a2.chart.brush && a2.chart.brush.enabled && (l2 = r2.brush(l2)), a2.chart.stacked && a2.chart.stackType === "100%" && (a2 = r2.stacked100(a2)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a2), a2.xaxis = a2.xaxis || window.Apex.xaxis || {}, e2 || (a2.xaxis.convertedCatToNumeric = false), ((a2 = this.checkForCatToNumericXAxis(this.chartType, l2, a2)).chart.sparkline && a2.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l2 = r2.sparkline(l2)), n2 = x.extend(o2, l2);
      }
      var h3 = x.extend(n2, window.Apex);
      return o2 = x.extend(h3, a2), o2 = this.handleUserInputErrors(o2);
    } }, { key: "checkForCatToNumericXAxis", value: function(t3, e2, i2) {
      var a2 = new D(i2), s2 = (t3 === "bar" || t3 === "boxPlot") && i2.plotOptions && i2.plotOptions.bar && i2.plotOptions.bar.horizontal, r2 = t3 === "pie" || t3 === "polarArea" || t3 === "donut" || t3 === "radar" || t3 === "radialBar" || t3 === "heatmap", o2 = i2.xaxis.type !== "datetime" && i2.xaxis.type !== "numeric", n2 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e2.xaxis && e2.xaxis.tickPlacement;
      return s2 || r2 || !o2 || n2 === "between" || (i2 = a2.convertCatToNumeric(i2)), i2;
    } }, { key: "extendYAxis", value: function(t3, e2) {
      var i2 = new L();
      (t3.yaxis === void 0 || !t3.yaxis || Array.isArray(t3.yaxis) && t3.yaxis.length === 0) && (t3.yaxis = {}), t3.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t3.yaxis = x.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [x.extend(i2.yAxis, t3.yaxis)] : t3.yaxis = x.extendArray(t3.yaxis, i2.yAxis);
      var a2 = false;
      t3.yaxis.forEach(function(t4) {
        t4.logarithmic && (a2 = true);
      });
      var s2 = t3.series;
      return e2 && !s2 && (s2 = e2.config.series), a2 && s2.length !== t3.yaxis.length && s2.length && (t3.yaxis = s2.map(function(e3, a3) {
        if (e3.name || (s2[a3].name = "series-".concat(a3 + 1)), t3.yaxis[a3])
          return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
        var r2 = x.extend(i2.yAxis, t3.yaxis[0]);
        return r2.show = false, r2;
      })), a2 && s2.length > 1 && s2.length !== t3.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t3;
    } }, { key: "extendAnnotations", value: function(t3) {
      return t3.annotations === void 0 && (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
    } }, { key: "extendYAxisAnnotations", value: function(t3) {
      var e2 = new L();
      return t3.annotations.yaxis = x.extendArray(t3.annotations.yaxis !== void 0 ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
    } }, { key: "extendXAxisAnnotations", value: function(t3) {
      var e2 = new L();
      return t3.annotations.xaxis = x.extendArray(t3.annotations.xaxis !== void 0 ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
    } }, { key: "extendPointAnnotations", value: function(t3) {
      var e2 = new L();
      return t3.annotations.points = x.extendArray(t3.annotations.points !== void 0 ? t3.annotations.points : [], e2.pointAnnotation), t3;
    } }, { key: "checkForDarkTheme", value: function(t3) {
      t3.theme && t3.theme.mode === "dark" && (t3.tooltip || (t3.tooltip = {}), t3.tooltip.theme !== "light" && (t3.tooltip.theme = "dark"), t3.chart.foreColor || (t3.chart.foreColor = "#f6f7f8"), t3.chart.background || (t3.chart.background = "#424242"), t3.theme.palette || (t3.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(t3) {
      var e2 = t3;
      if (e2.tooltip.shared && e2.tooltip.intersect)
        throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if (e2.chart.type === "bar" && e2.plotOptions.bar.horizontal) {
        if (e2.yaxis.length > 1)
          throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        e2.yaxis[0].reversed && (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
      }
      return e2.chart.type !== "bar" && e2.chart.type !== "rangeBar" || e2.tooltip.shared && e2.xaxis.crosshairs.width === "barWidth" && e2.series.length > 1 && (e2.xaxis.crosshairs.width = "tickWidth"), e2.chart.type !== "candlestick" && e2.chart.type !== "boxPlot" || e2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e2.chart.type, " chart is not supported.")), e2.yaxis[0].reversed = false), e2;
    } }]), t2;
  }(), O = function() {
    function t2() {
      a(this, t2);
    }
    return r(t2, [{ key: "initGlobalVars", value: function(t3) {
      t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRangeBar = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasGroups = false, t3.groups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.xaxisLabelsCount = 0, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0;
    } }, { key: "globalVars", value: function(t3) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: false, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: t3.chart.toolbar.autoSelected === "zoom" && t3.chart.toolbar.tools.zoom && t3.chart.zoom.enabled, panEnabled: t3.chart.toolbar.autoSelected === "pan" && t3.chart.toolbar.tools.pan, selectionEnabled: t3.chart.toolbar.autoSelected === "selection" && t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
    } }, { key: "init", value: function(t3) {
      var e2 = this.globalVars(t3);
      return this.initGlobalVars(e2), e2.initialConfig = x.extend({}, t3), e2.initialSeries = x.clone(t3.series), e2.lastXAxis = x.clone(e2.initialConfig.xaxis), e2.lastYAxis = x.clone(e2.initialConfig.yaxis), e2;
    } }]), t2;
  }(), W = function() {
    function t2(e2) {
      a(this, t2), this.opts = e2;
    }
    return r(t2, [{ key: "init", value: function() {
      var t3 = new N(this.opts).init({ responsiveOverride: false });
      return { config: t3, globals: new O().init(t3) };
    } }]), t2;
  }(), B = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new y(this.ctx);
    }
    return r(t2, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var t3 = this.w.config.series.slice(), e2 = new E(this.ctx);
      if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), t3[this.activeSeriesIndex].data !== void 0 && t3[this.activeSeriesIndex].data.length > 0 && t3[this.activeSeriesIndex].data[0] !== null && t3[this.activeSeriesIndex].data[0].x !== void 0 && t3[this.activeSeriesIndex].data[0] !== null)
        return true;
    } }, { key: "isFormat2DArray", value: function() {
      var t3 = this.w.config.series.slice(), e2 = new E(this.ctx);
      if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), t3[this.activeSeriesIndex].data !== void 0 && t3[this.activeSeriesIndex].data.length > 0 && t3[this.activeSeriesIndex].data[0] !== void 0 && t3[this.activeSeriesIndex].data[0] !== null && t3[this.activeSeriesIndex].data[0].constructor === Array)
        return true;
    } }, { key: "handleFormat2DArray", value: function(t3, e2) {
      for (var i2 = this.w.config, a2 = this.w.globals, s2 = i2.chart.type === "boxPlot" || i2.series[e2].type === "boxPlot", r2 = 0; r2 < t3[e2].data.length; r2++)
        if (t3[e2].data[r2][1] !== void 0 && (Array.isArray(t3[e2].data[r2][1]) && t3[e2].data[r2][1].length === 4 && !s2 ? this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length >= 5 ? this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), i2.xaxis.type === "datetime") {
          var o2 = new Date(t3[e2].data[r2][0]);
          o2 = new Date(o2).getTime(), this.twoDSeriesX.push(o2);
        } else
          this.twoDSeriesX.push(t3[e2].data[r2][0]);
      for (var n2 = 0; n2 < t3[e2].data.length; n2++)
        t3[e2].data[n2][2] !== void 0 && (this.threeDSeries.push(t3[e2].data[n2][2]), a2.isDataXYZ = true);
    } }, { key: "handleFormatXY", value: function(t3, e2) {
      var i2 = this.w.config, a2 = this.w.globals, s2 = new R(this.ctx), r2 = e2;
      a2.collapsedSeriesIndices.indexOf(e2) > -1 && (r2 = this.activeSeriesIndex);
      for (var o2 = 0; o2 < t3[e2].data.length; o2++)
        t3[e2].data[o2].y !== void 0 && (Array.isArray(t3[e2].data[o2].y) ? this.twoDSeries.push(x.parseNumber(t3[e2].data[o2].y[t3[e2].data[o2].y.length - 1])) : this.twoDSeries.push(x.parseNumber(t3[e2].data[o2].y))), t3[e2].data[o2].goals !== void 0 && Array.isArray(t3[e2].data[o2].goals) ? (this.seriesGoals[e2] === void 0 && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[o2].goals)) : (this.seriesGoals[e2] === void 0 && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
      for (var n2 = 0; n2 < t3[r2].data.length; n2++) {
        var l2 = typeof t3[r2].data[n2].x == "string", h3 = Array.isArray(t3[r2].data[n2].x), c2 = !h3 && !!s2.isValidDate(t3[r2].data[n2].x.toString());
        if (l2 || c2)
          if (l2 || i2.xaxis.convertedCatToNumeric) {
            var d2 = a2.isBarHorizontal && a2.isRangeData;
            i2.xaxis.type !== "datetime" || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[n2].x)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[n2].x));
          } else
            i2.xaxis.type === "datetime" ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[n2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[n2].x)));
        else
          h3 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[n2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[n2].x));
      }
      if (t3[e2].data[0] && t3[e2].data[0].z !== void 0) {
        for (var g2 = 0; g2 < t3[e2].data.length; g2++)
          this.threeDSeries.push(t3[e2].data[g2].z);
        a2.isDataXYZ = true;
      }
    } }, { key: "handleRangeData", value: function(t3, e2) {
      var i2 = this.w.globals, a2 = {};
      return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", t3, e2)), i2.seriesRangeStart.push(a2.start), i2.seriesRangeEnd.push(a2.end), i2.seriesRangeBar.push(a2.rangeUniques), i2.seriesRangeBar.forEach(function(t4, e3) {
        t4 && t4.forEach(function(t5, e4) {
          t5.y.forEach(function(e5, i3) {
            for (var a3 = 0; a3 < t5.y.length; a3++)
              if (i3 !== a3) {
                var s2 = e5.y1, r2 = e5.y2, o2 = t5.y[a3].y1;
                s2 <= t5.y[a3].y2 && o2 <= r2 && (t5.overlaps.indexOf(e5.rangeName) < 0 && t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) < 0 && t5.overlaps.push(t5.y[a3].rangeName));
              }
          });
        });
      }), a2;
    } }, { key: "handleCandleStickBoxData", value: function(t3, e2) {
      var i2 = this.w.globals, a2 = {};
      return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", t3, e2)), i2.seriesCandleO[e2] = a2.o, i2.seriesCandleH[e2] = a2.h, i2.seriesCandleM[e2] = a2.m, i2.seriesCandleL[e2] = a2.l, i2.seriesCandleC[e2] = a2.c, a2;
    } }, { key: "handleRangeDataFormat", value: function(t3, e2, i2) {
      var a2 = [], s2 = [], r2 = e2[i2].data.filter(function(t4, e3, i3) {
        return e3 === i3.findIndex(function(e4) {
          return e4.x === t4.x;
        });
      }).map(function(t4, e3) {
        return { x: t4.x, overlaps: [], y: [] };
      }), o2 = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts", n2 = new E(this.ctx).getActiveConfigSeriesIndex();
      if (t3 === "array") {
        if (e2[n2].data[0][1].length !== 2)
          throw new Error(o2);
        for (var l2 = 0; l2 < e2[i2].data.length; l2++)
          a2.push(e2[i2].data[l2][1][0]), s2.push(e2[i2].data[l2][1][1]);
      } else if (t3 === "xy") {
        if (e2[n2].data[0].y.length !== 2)
          throw new Error(o2);
        for (var h3 = function(t4) {
          var o3 = x.randomId(), n3 = e2[i2].data[t4].x, l3 = { y1: e2[i2].data[t4].y[0], y2: e2[i2].data[t4].y[1], rangeName: o3 };
          e2[i2].data[t4].rangeName = o3;
          var h4 = r2.findIndex(function(t5) {
            return t5.x === n3;
          });
          r2[h4].y.push(l3), a2.push(l3.y1), s2.push(l3.y2);
        }, c2 = 0; c2 < e2[i2].data.length; c2++)
          h3(c2);
      }
      return { start: a2, end: s2, rangeUniques: r2 };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = a2.config.chart.type === "boxPlot" || a2.config.series[i2].type === "boxPlot", r2 = [], o2 = [], n2 = [], l2 = [], h3 = [];
      if (t3 === "array")
        if (s2 && e2[i2].data[0].length === 6 || !s2 && e2[i2].data[0].length === 5)
          for (var c2 = 0; c2 < e2[i2].data.length; c2++)
            r2.push(e2[i2].data[c2][1]), o2.push(e2[i2].data[c2][2]), s2 ? (n2.push(e2[i2].data[c2][3]), l2.push(e2[i2].data[c2][4]), h3.push(e2[i2].data[c2][5])) : (l2.push(e2[i2].data[c2][3]), h3.push(e2[i2].data[c2][4]));
        else
          for (var d2 = 0; d2 < e2[i2].data.length; d2++)
            Array.isArray(e2[i2].data[d2][1]) && (r2.push(e2[i2].data[d2][1][0]), o2.push(e2[i2].data[d2][1][1]), s2 ? (n2.push(e2[i2].data[d2][1][2]), l2.push(e2[i2].data[d2][1][3]), h3.push(e2[i2].data[d2][1][4])) : (l2.push(e2[i2].data[d2][1][2]), h3.push(e2[i2].data[d2][1][3])));
      else if (t3 === "xy")
        for (var g2 = 0; g2 < e2[i2].data.length; g2++)
          Array.isArray(e2[i2].data[g2].y) && (r2.push(e2[i2].data[g2].y[0]), o2.push(e2[i2].data[g2].y[1]), s2 ? (n2.push(e2[i2].data[g2].y[2]), l2.push(e2[i2].data[g2].y[3]), h3.push(e2[i2].data[g2].y[4])) : (l2.push(e2[i2].data[g2].y[2]), h3.push(e2[i2].data[g2].y[3])));
      return { o: r2, h: o2, m: n2, l: l2, c: h3 };
    } }, { key: "parseDataAxisCharts", value: function(t3) {
      var e2 = this, i2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, a2 = this.w.config, s2 = this.w.globals, r2 = new R(i2), o2 = a2.labels.length > 0 ? a2.labels.slice() : a2.xaxis.categories.slice();
      s2.isRangeBar = a2.chart.type === "rangeBar" && s2.isBarHorizontal, s2.hasGroups = a2.xaxis.type === "category" && a2.xaxis.group !== void 0 && a2.xaxis.group.groups !== void 0 && a2.xaxis.group.groups.length > 0, s2.hasGroups && (s2.groups = a2.xaxis.group.groups);
      for (var n2 = function() {
        for (var t4 = 0; t4 < o2.length; t4++)
          if (typeof o2[t4] == "string") {
            if (!r2.isValidDate(o2[t4]))
              throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            e2.twoDSeriesX.push(r2.parseDate(o2[t4]));
          } else
            e2.twoDSeriesX.push(o2[t4]);
      }, l2 = 0; l2 < t3.length; l2++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], t3[l2].data === void 0)
          return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if (a2.chart.type !== "rangeBar" && a2.chart.type !== "rangeArea" && t3[l2].type !== "rangeBar" && t3[l2].type !== "rangeArea" || (s2.isRangeData = true, this.handleRangeData(t3, l2)), this.isMultiFormat())
          this.isFormat2DArray() ? this.handleFormat2DArray(t3, l2) : this.isFormatXY() && this.handleFormatXY(t3, l2), a2.chart.type !== "candlestick" && t3[l2].type !== "candlestick" && a2.chart.type !== "boxPlot" && t3[l2].type !== "boxPlot" || this.handleCandleStickBoxData(t3, l2), s2.series.push(this.twoDSeries), s2.labels.push(this.twoDSeriesX), s2.seriesX.push(this.twoDSeriesX), s2.seriesGoals = this.seriesGoals, l2 !== this.activeSeriesIndex || this.fallbackToCategory || (s2.isXNumeric = true);
        else {
          a2.xaxis.type === "datetime" ? (s2.isXNumeric = true, n2(), s2.seriesX.push(this.twoDSeriesX)) : a2.xaxis.type === "numeric" && (s2.isXNumeric = true, o2.length > 0 && (this.twoDSeriesX = o2, s2.seriesX.push(this.twoDSeriesX))), s2.labels.push(this.twoDSeriesX);
          var h3 = t3[l2].data.map(function(t4) {
            return x.parseNumber(t4);
          });
          s2.series.push(h3);
        }
        s2.seriesZ.push(this.threeDSeries), t3[l2].name !== void 0 ? s2.seriesNames.push(t3[l2].name) : s2.seriesNames.push("series-" + parseInt(l2 + 1, 10)), t3[l2].color !== void 0 ? s2.seriesColors.push(t3[l2].color) : s2.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(t3) {
      var e2 = this.w.globals, i2 = this.w.config;
      e2.series = t3.slice(), e2.seriesNames = i2.labels.slice();
      for (var a2 = 0; a2 < e2.series.length; a2++)
        e2.seriesNames[a2] === void 0 && e2.seriesNames.push("series-" + (a2 + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(t3) {
      var e2 = this.w.config, i2 = this.w.globals;
      if (e2.xaxis.categories.length > 0)
        i2.labels = e2.xaxis.categories;
      else if (e2.labels.length > 0)
        i2.labels = e2.labels.slice();
      else if (this.fallbackToCategory) {
        if (i2.labels = i2.labels[0], i2.seriesRangeBar.length && (i2.seriesRangeBar.map(function(t4) {
          t4.forEach(function(t5) {
            i2.labels.indexOf(t5.x) < 0 && t5.x && i2.labels.push(t5.x);
          });
        }), i2.labels = i2.labels.filter(function(t4, e3, i3) {
          return i3.indexOf(t4) === e3;
        })), e2.xaxis.convertedCatToNumeric)
          new D(e2).convertCatToNumericXaxis(e2, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t3);
      } else
        this._generateExternalLabels(t3);
    } }, { key: "_generateExternalLabels", value: function(t3) {
      var e2 = this.w.globals, i2 = this.w.config, a2 = [];
      if (e2.axisCharts) {
        if (e2.series.length > 0)
          if (this.isFormatXY())
            for (var s2 = i2.series.map(function(t4, e3) {
              return t4.data.filter(function(t5, e4, i3) {
                return i3.findIndex(function(e5) {
                  return e5.x === t5.x;
                }) === e4;
              });
            }), r2 = s2.reduce(function(t4, e3, i3, a3) {
              return a3[t4].length > e3.length ? t4 : i3;
            }, 0), o2 = 0; o2 < s2[r2].length; o2++)
              a2.push(o2 + 1);
          else
            for (var n2 = 0; n2 < e2.series[e2.maxValsInArrayIndex].length; n2++)
              a2.push(n2 + 1);
        e2.seriesX = [];
        for (var l2 = 0; l2 < t3.length; l2++)
          e2.seriesX.push(a2);
        e2.isXNumeric = true;
      }
      if (a2.length === 0) {
        a2 = e2.axisCharts ? [] : e2.series.map(function(t4, e3) {
          return e3 + 1;
        });
        for (var h3 = 0; h3 < t3.length; h3++)
          e2.seriesX.push(a2);
      }
      e2.labels = a2, i2.xaxis.convertedCatToNumeric && (e2.categoryLabels = a2.map(function(t4) {
        return i2.xaxis.labels.formatter(t4);
      })), e2.noLabelsProvided = true;
    } }, { key: "parseData", value: function(t3) {
      var e2 = this.w, i2 = e2.config, a2 = e2.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? this.parseDataAxisCharts(t3) : this.parseDataNonAxisCharts(t3), this.coreUtils.getLargestSeries(), i2.chart.type === "bar" && i2.chart.stacked) {
        var s2 = new E(this.ctx);
        a2.series = s2.setNullSeriesToZeroValues(a2.series);
      }
      this.coreUtils.getSeriesTotals(), a2.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && (i2.xaxis.type !== "numeric" || i2.labels.length !== 0 || i2.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t3);
      for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), o2 = 0; o2 < r2.length; o2++)
        if (Array.isArray(r2[o2])) {
          a2.isMultiLineX = true;
          break;
        }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var t3 = this, e2 = this.w;
      e2.globals.ignoreYAxisIndexes = e2.globals.collapsedSeries.map(function(i2, a2) {
        if (t3.w.globals.isMultipleYAxis && !e2.config.chart.stacked)
          return i2.index;
      });
    } }]), t2;
  }(), V = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
    }
    return r(t2, [{ key: "xLabelFormat", value: function(t3, e2, i2, a2) {
      var s2 = this.w;
      if (s2.config.xaxis.type === "datetime" && s2.config.xaxis.labels.formatter === void 0 && s2.config.tooltip.x.formatter === void 0) {
        var r2 = new R(this.ctx);
        return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
      }
      return t3(e2, i2, a2);
    } }, { key: "defaultGeneralFormatter", value: function(t3) {
      return Array.isArray(t3) ? t3.map(function(t4) {
        return t4;
      }) : t3;
    } }, { key: "defaultYFormatter", value: function(t3, e2, i2) {
      var a2 = this.w;
      return x.isNumber(t3) && (t3 = a2.globals.yValueDecimal !== 0 ? t3.toFixed(e2.decimalsInFloat !== void 0 ? e2.decimalsInFloat : a2.globals.yValueDecimal) : a2.globals.maxYArr[i2] - a2.globals.minYArr[i2] < 5 ? t3.toFixed(1) : t3.toFixed(0)), t3;
    } }, { key: "setLabelFormatters", value: function() {
      var t3 = this, e2 = this.w;
      return e2.globals.xaxisTooltipFormatter = function(e3) {
        return t3.defaultGeneralFormatter(e3);
      }, e2.globals.ttKeyFormatter = function(e3) {
        return t3.defaultGeneralFormatter(e3);
      }, e2.globals.ttZFormatter = function(t4) {
        return t4;
      }, e2.globals.legendFormatter = function(e3) {
        return t3.defaultGeneralFormatter(e3);
      }, e2.config.xaxis.labels.formatter !== void 0 ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
        if (x.isNumber(t4)) {
          if (!e2.config.xaxis.convertedCatToNumeric && e2.config.xaxis.type === "numeric") {
            if (x.isNumber(e2.config.xaxis.decimalsInFloat))
              return t4.toFixed(e2.config.xaxis.decimalsInFloat);
            var i2 = e2.globals.maxX - e2.globals.minX;
            return i2 > 0 && i2 < 100 ? t4.toFixed(1) : t4.toFixed(0);
          }
          if (e2.globals.isBarHorizontal) {
            if (e2.globals.maxY - e2.globals.minYArr < 4)
              return t4.toFixed(1);
          }
          return t4.toFixed(0);
        }
        return t4;
      }, typeof e2.config.tooltip.x.formatter == "function" ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, typeof e2.config.xaxis.tooltip.formatter == "function" && (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || e2.config.tooltip.y.formatter !== void 0) && (e2.globals.ttVal = e2.config.tooltip.y), e2.config.tooltip.z.formatter !== void 0 && (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), e2.config.legend.formatter !== void 0 && (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach(function(i2, a2) {
        i2.labels.formatter !== void 0 ? e2.globals.yLabelFormatters[a2] = i2.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
          return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(e3) {
            return t3.defaultYFormatter(e3, i2, a2);
          }) : t3.defaultYFormatter(s2, i2, a2) : s2;
        };
      }), e2.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var t3 = this.w;
      if (t3.config.chart.type === "heatmap") {
        t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
        var e2 = t3.globals.seriesNames.reduce(function(t4, e3) {
          return t4.length > e3.length ? t4 : e3;
        }, 0);
        t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
      }
    } }]), t2;
  }(), G = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "getLabel", value: function(t3, e2, i2, a2) {
      var s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], r2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", o2 = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], n2 = this.w, l2 = t3[a2] === void 0 ? "" : t3[a2], h3 = l2, c2 = n2.globals.xLabelFormatter, d2 = n2.config.xaxis.labels.formatter, g2 = false, u2 = new V(this.ctx), p3 = l2;
      o2 && (h3 = u2.xLabelFormat(c2, l2, p3, { i: a2, dateFormatter: new R(this.ctx).formatDate, w: n2 }), d2 !== void 0 && (h3 = d2(l2, t3[a2], { i: a2, dateFormatter: new R(this.ctx).formatDate, w: n2 })));
      var f2 = function(t4) {
        var i3 = null;
        return e2.forEach(function(t5) {
          t5.unit === "month" ? i3 = "year" : t5.unit === "day" ? i3 = "month" : t5.unit === "hour" ? i3 = "day" : t5.unit === "minute" && (i3 = "hour");
        }), i3 === t4;
      };
      e2.length > 0 ? (g2 = f2(e2[a2].unit), i2 = e2[a2].position, h3 = e2[a2].value) : n2.config.xaxis.type === "datetime" && d2 === void 0 && (h3 = ""), h3 === void 0 && (h3 = ""), h3 = Array.isArray(h3) ? h3 : h3.toString();
      var x2 = new m(this.ctx), b2 = {};
      b2 = n2.globals.rotateXLabels && o2 ? x2.getTextRects(h3, parseInt(r2, 10), null, "rotate(".concat(n2.config.xaxis.labels.rotate, " 0 0)"), false) : x2.getTextRects(h3, parseInt(r2, 10));
      var v2 = !n2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(h3) && (h3.indexOf("NaN") === 0 || h3.toLowerCase().indexOf("invalid") === 0 || h3.toLowerCase().indexOf("infinity") >= 0 || s2.indexOf(h3) >= 0 && v2) && (h3 = ""), { x: i2, text: h3, textRect: b2, isBold: g2 };
    } }, { key: "checkLabelBasedOnTickamount", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
      return s2 === "dataPoints" && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i2 || t3 % Math.round(i2 / (s2 + 1)) == 0 || (e2.text = ""), e2;
    } }, { key: "checkForOverflowingLabels", value: function(t3, e2, i2, a2, s2) {
      var r2 = this.w;
      if (t3 === 0 && r2.globals.skipFirstTimelinelabel && (e2.text = ""), t3 === i2 - 1 && r2.globals.skipLastTimelinelabel && (e2.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
        var o2 = s2[s2.length - 1];
        e2.x < o2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + o2.x && (e2.text = "");
      }
      return e2;
    } }, { key: "checkForReversedLabels", value: function(t3, e2) {
      var i2 = this.w;
      return i2.config.yaxis[t3] && i2.config.yaxis[t3].reversed && e2.reverse(), e2;
    } }, { key: "isYAxisHidden", value: function(t3) {
      var e2 = this.w, i2 = new y(this.ctx);
      return !e2.config.yaxis[t3].show || !e2.config.yaxis[t3].showForNullSeries && i2.isSeriesNull(t3) && e2.globals.collapsedSeriesIndices.indexOf(t3) === -1;
    } }, { key: "getYAxisForeColor", value: function(t3, e2) {
      var i2 = this.w;
      return Array.isArray(t3) && i2.globals.yAxisScale[e2] && this.ctx.theme.pushExtraColors(t3, i2.globals.yAxisScale[e2].result.length, false), t3;
    } }, { key: "drawYAxisTicks", value: function(t3, e2, i2, a2, s2, r2, o2) {
      var n2 = this.w, l2 = new m(this.ctx), h3 = n2.globals.translateY;
      if (a2.show && e2 > 0) {
        n2.config.yaxis[s2].opposite === true && (t3 += a2.width);
        for (var c2 = e2; c2 >= 0; c2--) {
          var d2 = h3 + e2 / 10 + n2.config.yaxis[s2].labels.offsetY - 1;
          n2.globals.isBarHorizontal && (d2 = r2 * c2), n2.config.chart.type === "heatmap" && (d2 += r2 / 2);
          var g2 = l2.drawLine(t3 + i2.offsetX - a2.width + a2.offsetX, d2 + a2.offsetY, t3 + i2.offsetX + a2.offsetX, d2 + a2.offsetY, a2.color);
          o2.add(g2), h3 += r2;
        }
      }
    } }]), t2;
  }(), j = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "scaleSvgNode", value: function(t3, e2) {
      var i2 = parseFloat(t3.getAttributeNS(null, "width")), a2 = parseFloat(t3.getAttributeNS(null, "height"));
      t3.setAttributeNS(null, "width", i2 * e2), t3.setAttributeNS(null, "height", a2 * e2), t3.setAttributeNS(null, "viewBox", "0 0 " + i2 + " " + a2);
    } }, { key: "fixSvgStringForIe11", value: function(t3) {
      if (!x.isIE11())
        return t3.replace(/&nbsp;/g, "&#160;");
      var e2 = 0, i2 = t3.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t4) {
        return ++e2 === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t4;
      });
      return i2 = (i2 = i2.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(t3) {
      var e2 = this.w.globals.dom.Paper.svg();
      if (t3 !== 1) {
        var i2 = this.w.globals.dom.Paper.node.cloneNode(true);
        this.scaleSvgNode(i2, t3), e2 = new XMLSerializer().serializeToString(i2);
      }
      return this.fixSvgStringForIe11(e2);
    } }, { key: "cleanup", value: function() {
      var t3 = this.w, e2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(a2, function(t4) {
        t4.setAttribute("width", 0);
      }), e2 && e2[0] && (e2[0].setAttribute("x", -500), e2[0].setAttribute("x1", -500), e2[0].setAttribute("x2", -500)), i2 && i2[0] && (i2[0].setAttribute("y", -100), i2[0].setAttribute("y1", -100), i2[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var t3 = this.getSvgString(), e2 = new Blob([t3], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(e2);
    } }, { key: "dataURI", value: function(t3) {
      var e2 = this;
      return new Promise(function(i2) {
        var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1;
        e2.cleanup();
        var r2 = document.createElement("canvas");
        r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
        var o2 = a2.config.chart.background === "transparent" ? "#fff" : a2.config.chart.background, n2 = r2.getContext("2d");
        n2.fillStyle = o2, n2.fillRect(0, 0, r2.width * s2, r2.height * s2);
        var l2 = e2.getSvgString(s2);
        if (window.canvg && x.isIE11()) {
          var h3 = window.canvg.Canvg.fromString(n2, l2, { ignoreClear: true, ignoreDimensions: true });
          h3.start();
          var c2 = r2.msToBlob();
          h3.stop(), i2({ blob: c2 });
        } else {
          var d2 = "data:image/svg+xml," + encodeURIComponent(l2), g2 = new Image();
          g2.crossOrigin = "anonymous", g2.onload = function() {
            if (n2.drawImage(g2, 0, 0), r2.msToBlob) {
              var t4 = r2.msToBlob();
              i2({ blob: t4 });
            } else {
              var e3 = r2.toDataURL("image/png");
              i2({ imgURI: e3 });
            }
          }, g2.src = d2;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var t3 = this;
      this.dataURI().then(function(e2) {
        var i2 = e2.imgURI, a2 = e2.blob;
        a2 ? navigator.msSaveOrOpenBlob(a2, t3.w.globals.chartID + ".png") : t3.triggerDownload(i2, t3.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(t3) {
      var e2 = this, i2 = t3.series, a2 = t3.columnDelimiter, s2 = t3.lineDelimiter, r2 = s2 === void 0 ? "\n" : s2, o2 = this.w, n2 = [], l2 = [], h3 = "", c2 = new B(this.ctx), d2 = new G(this.ctx), g2 = function(t4) {
        var i3 = "";
        if (o2.globals.axisCharts) {
          if (o2.config.xaxis.type === "category" || o2.config.xaxis.convertedCatToNumeric)
            if (o2.globals.isBarHorizontal) {
              var s3 = o2.globals.yLabelFormatters[0], r3 = new E(e2.ctx).getActiveConfigSeriesIndex();
              i3 = s3(o2.globals.labels[t4], { seriesIndex: r3, dataPointIndex: t4, w: o2 });
            } else
              i3 = d2.getLabel(o2.globals.labels, o2.globals.timescaleLabels, 0, t4).text;
          o2.config.xaxis.type === "datetime" && (o2.config.xaxis.categories.length ? i3 = o2.config.xaxis.categories[t4] : o2.config.labels.length && (i3 = o2.config.labels[t4]));
        } else
          i3 = o2.config.labels[t4];
        return Array.isArray(i3) && (i3 = i3.join(" ")), x.isNumber(i3) ? i3 : i3.split(a2).join("");
      };
      n2.push(o2.config.chart.toolbar.export.csv.headerCategory), i2.map(function(t4, e3) {
        var i3 = t4.name ? t4.name : "series-".concat(e3);
        o2.globals.axisCharts && n2.push(i3.split(a2).join("") ? i3.split(a2).join("") : "series-".concat(e3));
      }), o2.globals.axisCharts || (n2.push(o2.config.chart.toolbar.export.csv.headerValue), l2.push(n2.join(a2))), i2.map(function(t4, e3) {
        o2.globals.axisCharts ? function(t5, e4) {
          if (n2.length && e4 === 0 && l2.push(n2.join(a2)), t5.data && t5.data.length)
            for (var s3 = 0; s3 < t5.data.length; s3++) {
              n2 = [];
              var r3 = g2(s3);
              if (r3 || (c2.isFormatXY() ? r3 = i2[e4].data[s3].x : c2.isFormat2DArray() && (r3 = i2[e4].data[s3] ? i2[e4].data[s3][0] : "")), e4 === 0) {
                n2.push((d3 = r3, o2.config.xaxis.type === "datetime" && String(d3).length >= 10 ? o2.config.chart.toolbar.export.csv.dateFormatter(r3) : x.isNumber(r3) ? r3 : r3.split(a2).join("")));
                for (var h4 = 0; h4 < o2.globals.series.length; h4++)
                  n2.push(o2.globals.series[h4][s3]);
              }
              (o2.config.chart.type === "candlestick" || t5.type && t5.type === "candlestick") && (n2.pop(), n2.push(o2.globals.seriesCandleO[e4][s3]), n2.push(o2.globals.seriesCandleH[e4][s3]), n2.push(o2.globals.seriesCandleL[e4][s3]), n2.push(o2.globals.seriesCandleC[e4][s3])), (o2.config.chart.type === "boxPlot" || t5.type && t5.type === "boxPlot") && (n2.pop(), n2.push(o2.globals.seriesCandleO[e4][s3]), n2.push(o2.globals.seriesCandleH[e4][s3]), n2.push(o2.globals.seriesCandleM[e4][s3]), n2.push(o2.globals.seriesCandleL[e4][s3]), n2.push(o2.globals.seriesCandleC[e4][s3])), o2.config.chart.type === "rangeBar" && (n2.pop(), n2.push(o2.globals.seriesRangeStart[e4][s3]), n2.push(o2.globals.seriesRangeEnd[e4][s3])), n2.length && l2.push(n2.join(a2));
            }
          var d3;
        }(t4, e3) : ((n2 = []).push(o2.globals.labels[e3].split(a2).join("")), n2.push(o2.globals.series[e3]), l2.push(n2.join(a2)));
      }), h3 += l2.join(r2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + h3), o2.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(t3, e2, i2) {
      var a2 = document.createElement("a");
      a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i2, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
    } }]), t2;
  }(), _ = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var i2 = this.w;
      this.axesUtils = new G(e2), this.xaxisLabels = i2.globals.labels.slice(), i2.globals.timescaleLabels.length > 0 && !i2.globals.isBarHorizontal && (this.xaxisLabels = i2.globals.timescaleLabels.slice()), i2.config.xaxis.overwriteCategories && (this.xaxisLabels = i2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i2.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i2.globals.gridHeight + 1, this.offY = this.offY + i2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i2.config.chart.type === "bar" && i2.config.plotOptions.bar.horizontal, this.xaxisFontSize = i2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i2.config.xaxis.axisBorder.height, this.yaxis = i2.config.yaxis[0];
    }
    return r(t2, [{ key: "drawXaxis", value: function() {
      var t3 = this.w, e2 = new m(this.ctx), i2 = e2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t3.config.xaxis.offsetX, ", ").concat(t3.config.xaxis.offsetY, ")") }), a2 = e2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t3.globals.translateXAxisX, ", ").concat(t3.globals.translateXAxisY, ")") });
      i2.add(a2);
      for (var s2 = [], r2 = 0; r2 < this.xaxisLabels.length; r2++)
        s2.push(this.xaxisLabels[r2]);
      if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, function(t4, e3) {
        return e3;
      }), t3.globals.hasGroups) {
        var o2 = t3.globals.groups;
        s2 = [];
        for (var n2 = 0; n2 < o2.length; n2++)
          s2.push(o2[n2].title);
        var l2 = {};
        t3.config.xaxis.group.style && (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, function(t4, e3) {
          return o2[t4].cols * e3;
        }, l2);
      }
      if (t3.config.xaxis.title.text !== void 0) {
        var h3 = e2.group({ class: "apexcharts-xaxis-title" }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + t3.globals.xAxisLabelsHeight + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: "middle", fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t3.config.xaxis.title.style.cssClass });
        h3.add(c2), i2.add(h3);
      }
      if (t3.config.xaxis.axisBorder.show) {
        var d2 = t3.globals.barPadForNumericAxis, g2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        i2.add(g2);
      }
      return i2;
    } }, { key: "drawXAxisLabelAndGroup", value: function(t3, e2, i2, a2, s2, r2) {
      var o2, n2 = this, l2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, h3 = [], c2 = [], d2 = this.w, g2 = l2.xaxisFontSize || this.xaxisFontSize, u2 = l2.xaxisFontFamily || this.xaxisFontFamily, p3 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, v2 = a2.length, m2 = d2.config.xaxis.type === "category" ? d2.globals.dataPoints : v2;
      if (s2) {
        var y2 = m2 > 1 ? m2 - 1 : m2;
        o2 = d2.globals.gridWidth / y2, b2 = b2 + r2(0, o2) / 2 + d2.config.xaxis.labels.offsetX;
      } else
        o2 = d2.globals.gridWidth / m2, b2 = b2 + r2(0, o2) + d2.config.xaxis.labels.offsetX;
      for (var w2 = function(s3) {
        var l3 = b2 - r2(s3, o2) / 2 + d2.config.xaxis.labels.offsetX;
        s3 === 0 && v2 === 1 && o2 / 2 === b2 && m2 === 1 && (l3 = d2.globals.gridWidth / 2);
        var y3 = n2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h3, g2, t3), w3 = 28;
        d2.globals.rotateXLabels && t3 && (w3 = 22), t3 || (w3 = w3 + parseFloat(g2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = d2.config.xaxis.tickAmount !== void 0 && d2.config.xaxis.tickAmount !== "dataPoints" && d2.config.xaxis.type !== "datetime" ? n2.axesUtils.checkLabelBasedOnTickamount(s3, y3, v2) : n2.axesUtils.checkForOverflowingLabels(s3, y3, v2, h3, c2);
        if (t3 && y3.text && d2.globals.xaxisLabelsCount++, d2.config.xaxis.labels.show) {
          var k3 = e2.drawText({ x: y3.x, y: n2.offY + d2.config.xaxis.labels.offsetY + w3 - (d2.config.xaxis.position === "top" ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: "middle", fontWeight: y3.isBold ? 600 : f2, fontSize: g2, fontFamily: u2, foreColor: Array.isArray(p3) ? t3 && d2.config.xaxis.convertedCatToNumeric ? p3[d2.globals.minX + s3 - 1] : p3[s3] : p3, isPlainText: false, cssClass: (t3 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x2 });
          if (i2.add(k3), t3) {
            var A2 = document.createElementNS(d2.globals.SVGNS, "title");
            A2.textContent = Array.isArray(y3.text) ? y3.text.join(" ") : y3.text, k3.node.appendChild(A2), y3.text !== "" && (h3.push(y3.text), c2.push(y3));
          }
        }
        s3 < v2 - 1 && (b2 += r2(s3 + 1, o2));
      }, k2 = 0; k2 <= v2 - 1; k2++)
        w2(k2);
    } }, { key: "drawXaxisInversed", value: function(t3) {
      var e2, i2, a2 = this, s2 = this.w, r2 = new m(this.ctx), o2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, n2 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t3 }), l2 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o2 + ", 0)" });
      n2.add(l2);
      var h3 = [];
      if (s2.config.yaxis[t3].show)
        for (var c2 = 0; c2 < this.xaxisLabels.length; c2++)
          h3.push(this.xaxisLabels[c2]);
      e2 = s2.globals.gridHeight / h3.length, i2 = -e2 / 2.2;
      var d2 = s2.globals.yLabelFormatters[0], g2 = s2.config.yaxis[0].labels;
      if (g2.show)
        for (var u2 = function(o3) {
          var n3 = h3[o3] === void 0 ? "" : h3[o3];
          n3 = d2(n3, { seriesIndex: t3, dataPointIndex: o3, w: s2 });
          var c3 = a2.axesUtils.getYAxisForeColor(g2.style.colors, t3), u3 = 0;
          Array.isArray(n3) && (u3 = n3.length / 2 * parseInt(g2.style.fontSize, 10));
          var p4 = r2.drawText({ x: g2.offsetX - 15, y: i2 + e2 + g2.offsetY - u3, text: n3, textAnchor: a2.yaxis.opposite ? "start" : "end", foreColor: Array.isArray(c3) ? c3[o3] : c3, fontSize: g2.style.fontSize, fontFamily: g2.style.fontFamily, fontWeight: g2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + g2.style.cssClass });
          l2.add(p4);
          var f3 = document.createElementNS(s2.globals.SVGNS, "title");
          if (f3.textContent = Array.isArray(n3) ? n3.join(" ") : n3, p4.node.appendChild(f3), s2.config.yaxis[t3].labels.rotate !== 0) {
            var x3 = r2.rotateAroundCenter(p4.node);
            p4.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[t3].labels.rotate, " 0 ").concat(x3.y, ")"));
          }
          i2 += e2;
        }, p3 = 0; p3 <= h3.length - 1; p3++)
          u2(p3);
      if (s2.config.yaxis[0].title.text !== void 0) {
        var f2 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o2 + ", 0)" }), x2 = r2.drawText({ x: 0, y: s2.globals.gridHeight / 2, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
        f2.add(x2), n2.add(f2);
      }
      var b2 = 0;
      this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (b2 = s2.globals.gridWidth);
      var v2 = s2.config.xaxis.axisBorder;
      if (v2.show) {
        var y2 = r2.drawLine(s2.globals.padHorizontal + v2.offsetX + b2, 1 + v2.offsetY, s2.globals.padHorizontal + v2.offsetX + b2, s2.globals.gridHeight + v2.offsetY, v2.color, 0);
        n2.add(y2);
      }
      return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b2, h3.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, n2), n2;
    } }, { key: "drawXaxisTicks", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = t3;
      if (!(t3 < 0 || t3 - 2 > a2.globals.gridWidth)) {
        var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
        if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, a2.config.xaxis.position === "top" && (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
          var o2 = new m(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
          i2.add(o2), o2.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var t3 = this.w, e2 = [], i2 = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
      if (t3.globals.timescaleLabels.length > 0)
        for (var s2 = 0; s2 < i2; s2++)
          a2 = this.xaxisLabels[s2].position, e2.push(a2);
      else
        for (var r2 = i2, o2 = 0; o2 < r2; o2++) {
          var n2 = r2;
          t3.globals.isXNumeric && t3.config.chart.type !== "bar" && (n2 -= 1), a2 += t3.globals.gridWidth / n2, e2.push(a2);
        }
      return e2;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var t3 = this.w, e2 = new m(this.ctx), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways)
        for (var o2 = 0; o2 < a2.length; o2++) {
          var n2 = e2.rotateAroundCenter(a2[o2]);
          n2.y = n2.y - 1, n2.x = n2.x + 1, a2[o2].setAttribute("transform", "rotate(".concat(t3.config.xaxis.labels.rotate, " ").concat(n2.x, " ").concat(n2.y, ")")), a2[o2].setAttribute("text-anchor", "end");
          i2.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var l2 = a2[o2].childNodes;
          t3.config.xaxis.labels.trim && Array.prototype.forEach.call(l2, function(i3) {
            e2.placeTextWithEllipsis(i3, i3.textContent, t3.globals.xAxisLabelsHeight - (t3.config.legend.position === "bottom" ? 20 : 10));
          });
        }
      else
        !function() {
          for (var i3 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0; s3 < a2.length; s3++) {
            var r3 = a2[s3].childNodes;
            t3.config.xaxis.labels.trim && t3.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(r3, function(t4) {
              e2.placeTextWithEllipsis(t4, t4.textContent, i3);
            });
          }
        }();
      if (s2.length > 0) {
        var h3 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
        h3.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width > t3.globals.gridWidth && !t3.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
        for (var d2 = 0; d2 < r2.length; d2++)
          e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) - 20);
      }
    } }]), t2;
  }(), U = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var i2 = this.w;
      this.xaxisLabels = i2.globals.labels.slice(), this.axesUtils = new G(e2), this.isRangeBar = i2.globals.seriesRangeBar.length, i2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i2.globals.timescaleLabels.slice());
    }
    return r(t2, [{ key: "drawGridArea", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, e2 = this.w, i2 = new m(this.ctx);
      t3 === null && (t3 = i2.group({ class: "apexcharts-grid" }));
      var a2 = i2.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, "transparent"), s2 = i2.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, "transparent");
      return t3.add(s2), t3.add(a2), t3;
    } }, { key: "drawGrid", value: function() {
      var t3 = null;
      return this.w.globals.axisCharts && (t3 = this.renderGrid(), this.drawGridArea(t3.el)), t3;
    } }, { key: "createGridMask", value: function() {
      var t3 = this.w, e2 = t3.globals, i2 = new m(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? 0 : t3.config.stroke.width;
      if (Array.isArray(t3.config.stroke.width)) {
        var s2 = 0;
        t3.config.stroke.width.forEach(function(t4) {
          s2 = Math.max(s2, t4);
        }), a2 = s2;
      }
      e2.dom.elGridRectMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e2.cuid)), e2.dom.elGridRectMarkerMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e2.cuid)), e2.dom.elForecastMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e2.cuid)), e2.dom.elNonForecastMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e2.cuid));
      var r2 = t3.config.chart.type, o2 = 0, n2 = 0;
      (r2 === "bar" || r2 === "rangeBar" || r2 === "candlestick" || r2 === "boxPlot" || t3.globals.comboBarCount > 0) && t3.globals.isXNumeric && !t3.globals.isBarHorizontal && (o2 = t3.config.grid.padding.left, n2 = t3.config.grid.padding.right, e2.barPadForNumericAxis > o2 && (o2 = e2.barPadForNumericAxis, n2 = e2.barPadForNumericAxis)), e2.dom.elGridRect = i2.drawRect(-a2 / 2 - o2 - 2, -a2 / 2, e2.gridWidth + a2 + n2 + o2 + 4, e2.gridHeight + a2, 0, "#fff");
      var l2 = t3.globals.markers.largestSize + 1;
      e2.dom.elGridRectMarker = i2.drawRect(2 * -l2, 2 * -l2, e2.gridWidth + 4 * l2, e2.gridHeight + 4 * l2, 0, "#fff"), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
      var h3 = e2.dom.baseEl.querySelector("defs");
      h3.appendChild(e2.dom.elGridRectMask), h3.appendChild(e2.dom.elForecastMask), h3.appendChild(e2.dom.elNonForecastMask), h3.appendChild(e2.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(t3) {
      var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.xCount, n2 = t3.parent, l2 = this.w;
      if (!(e2 === 0 && l2.globals.skipFirstTimelinelabel || e2 === o2 - 1 && l2.globals.skipLastTimelinelabel && !l2.config.xaxis.labels.formatter || l2.config.chart.type === "radar")) {
        l2.config.grid.xaxis.lines.show && this._drawGridLine({ x1: i2, y1: a2, x2: s2, y2: r2, parent: n2 });
        var h3 = 0;
        if (l2.globals.hasGroups && (l2.config.xaxis.tickAmount === void 0 || l2.config.xaxis.tickAmount === "dataPoints") && l2.config.xaxis.tickPlacement === "between") {
          var c2 = l2.globals.groups;
          if (c2) {
            for (var d2 = 0, g2 = 0; d2 < e2 && g2 < c2.length; g2++)
              d2 += c2[g2].cols;
            d2 === e2 && (h3 = 0.6 * l2.globals.xAxisLabelsHeight);
          }
        }
        new _(this.ctx).drawXaxisTicks(i2, h3, this.elg);
      }
    } }, { key: "_drawGridLine", value: function(t3) {
      var e2 = t3.x1, i2 = t3.y1, a2 = t3.x2, s2 = t3.y2, r2 = t3.parent, o2 = this.w, n2 = r2.node.classList.contains("apexcharts-gridlines-horizontal"), l2 = o2.config.grid.strokeDashArray, h3 = o2.globals.barPadForNumericAxis, c2 = new m(this).drawLine(e2 - (n2 ? h3 : 0), i2, a2 + (n2 ? h3 : 0), s2, o2.config.grid.borderColor, l2);
      c2.node.classList.add("apexcharts-gridline"), r2.add(c2);
    } }, { key: "_drawGridBandRect", value: function(t3) {
      var e2 = t3.c, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.type, n2 = this.w, l2 = new m(this.ctx), h3 = n2.globals.barPadForNumericAxis;
      if (o2 !== "column" || n2.config.xaxis.type !== "datetime") {
        var c2 = n2.config.grid[o2].colors[e2], d2 = l2.drawRect(i2 - (o2 === "row" ? h3 : 0), a2, s2 + (o2 === "row" ? 2 * h3 : 0), r2, 0, c2, n2.config.grid[o2].opacity);
        this.elg.add(d2), d2.attr("clip-path", "url(#gridRectMask".concat(n2.globals.cuid, ")")), d2.node.classList.add("apexcharts-grid-".concat(o2));
      }
    } }, { key: "_drawXYLines", value: function(t3) {
      var e2 = this, i2 = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
      if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
        var r2, o2 = s2.globals.padHorizontal, n2 = s2.globals.gridHeight;
        s2.globals.timescaleLabels.length ? function(t4) {
          for (var a3 = t4.xC, s3 = t4.x1, r3 = t4.y1, o3 = t4.x2, n3 = t4.y2, l3 = 0; l3 < a3; l3++)
            s3 = e2.xaxisLabels[l3].position, o3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: o3, y2: n3, xCount: i2, parent: e2.elgridLinesV });
        }({ xC: i2, x1: o2, y1: 0, x2: r2, y2: n2 }) : (s2.globals.isXNumeric && (i2 = s2.globals.xAxisScale.result.length), s2.config.xaxis.convertedCatToNumeric && (i2 = s2.globals.xaxisLabelsCount), function(t4) {
          var a3 = t4.xC, r3 = t4.x1, o3 = t4.y1, n3 = t4.x2, l3 = t4.y2;
          if (s2.config.xaxis.tickAmount !== void 0 && s2.config.xaxis.tickAmount !== "dataPoints")
            s2.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach(function(t5, a4) {
              var s3 = t5.getBBox();
              e2._drawGridLines({ i: a4, x1: s3.x + s3.width / 2, y1: o3, x2: s3.x + s3.width / 2, y2: l3, xCount: i2, parent: e2.elgridLinesV });
            });
          else
            for (var h4 = 0; h4 < a3 + (s2.globals.isXNumeric ? 0 : 1); h4++)
              h4 === 0 && a3 === 1 && s2.globals.dataPoints === 1 && (n3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h4, x1: r3, y1: o3, x2: n3, y2: l3, xCount: i2, parent: e2.elgridLinesV }), n3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
        }({ xC: i2, x1: o2, y1: 0, x2: r2, y2: n2 }));
      }
      if (s2.config.grid.yaxis.lines.show) {
        var l2 = 0, h3 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
        this.isRangeBar && (d2 = s2.globals.labels.length);
        for (var g2 = 0; g2 < d2 + (this.isRangeBar ? 1 : 0); g2++)
          this._drawGridLine({ x1: 0, y1: l2, x2: c2, y2: h3, parent: this.elgridLinesH }), h3 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
      }
    } }, { key: "_drawInvertedXYLines", value: function(t3) {
      var e2 = t3.xCount, i2 = this.w;
      if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show)
        for (var a2, s2 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, o2 = 0; o2 < e2 + 1; o2++) {
          i2.config.grid.xaxis.lines.show && this._drawGridLine({ x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new _(this.ctx).drawXaxisTicks(s2, 0, this.elg), a2 = s2 = s2 + i2.globals.gridWidth / e2 + 0.3;
        }
      if (i2.config.grid.yaxis.lines.show)
        for (var n2 = 0, l2 = 0, h3 = i2.globals.gridWidth, c2 = 0; c2 < i2.globals.dataPoints + 1; c2++)
          this._drawGridLine({ x1: 0, y1: n2, x2: h3, y2: l2, parent: this.elgridLinesH }), l2 = n2 += i2.globals.gridHeight / i2.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var t3 = this.w, e2 = new m(this.ctx);
      this.elg = e2.group({ class: "apexcharts-grid" }), this.elgridLinesH = e2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = e2.group({ class: "apexcharts-gridlines-vertical" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());
      for (var i2, a2 = t3.globals.yAxisScale.length ? t3.globals.yAxisScale[0].result.length - 1 : 5, s2 = 0; s2 < t3.globals.series.length && (t3.globals.yAxisScale[s2] !== void 0 && (a2 = t3.globals.yAxisScale[s2].result.length - 1), !(a2 > 2)); s2++)
        ;
      return !t3.globals.isBarHorizontal || this.isRangeBar ? (i2 = this.xaxisLabels.length, this.isRangeBar && (a2 = t3.globals.labels.length, t3.config.xaxis.tickAmount && t3.config.xaxis.labels.formatter && (i2 = t3.config.xaxis.tickAmount)), this._drawXYLines({ xCount: i2, tickAmount: a2 })) : (i2 = a2, a2 = t3.globals.xTickAmount, this._drawInvertedXYLines({ xCount: i2, tickAmount: a2 })), this.drawGridBands(i2, a2), { el: this.elg, xAxisTickWidth: t3.globals.gridWidth / i2 };
    } }, { key: "drawGridBands", value: function(t3, e2) {
      var i2 = this.w;
      if (i2.config.grid.row.colors !== void 0 && i2.config.grid.row.colors.length > 0)
        for (var a2 = 0, s2 = i2.globals.gridHeight / e2, r2 = i2.globals.gridWidth, o2 = 0, n2 = 0; o2 < e2; o2++, n2++)
          n2 >= i2.config.grid.row.colors.length && (n2 = 0), this._drawGridBandRect({ c: n2, x1: 0, y1: a2, x2: r2, y2: s2, type: "row" }), a2 += i2.globals.gridHeight / e2;
      if (i2.config.grid.column.colors !== void 0 && i2.config.grid.column.colors.length > 0)
        for (var l2 = i2.globals.isBarHorizontal || i2.config.xaxis.type !== "category" && !i2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1, h3 = i2.globals.padHorizontal, c2 = i2.globals.padHorizontal + i2.globals.gridWidth / l2, d2 = i2.globals.gridHeight, g2 = 0, u2 = 0; g2 < t3; g2++, u2++)
          u2 >= i2.config.grid.column.colors.length && (u2 = 0), this._drawGridBandRect({ c: u2, x1: h3, y1: 0, x2: c2, y2: d2, type: "column" }), h3 += i2.globals.gridWidth / l2;
    } }]), t2;
  }(), q = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "niceScale", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s2 = arguments.length > 4 ? arguments[4] : void 0, r2 = this.w, o2 = Math.abs(e2 - t3);
      if ((i2 = this._adjustTicksForSmallRange(i2, a2, o2)) === "dataPoints" && (i2 = r2.globals.dataPoints - 1), t3 === Number.MIN_VALUE && e2 === 0 || !x.isNumber(t3) && !x.isNumber(e2) || t3 === Number.MIN_VALUE && e2 === -Number.MAX_VALUE) {
        t3 = 0, e2 = i2;
        var n2 = this.linearScale(t3, e2, i2);
        return n2;
      }
      t3 > e2 ? (console.warn("axis.min cannot be greater than axis.max"), e2 = t3 + 0.1) : t3 === e2 && (t3 = t3 === 0 ? 0 : t3 - 0.5, e2 = e2 === 0 ? 2 : e2 + 0.5);
      var l2 = [];
      o2 < 1 && s2 && (r2.config.chart.type === "candlestick" || r2.config.series[a2].type === "candlestick" || r2.config.chart.type === "boxPlot" || r2.config.series[a2].type === "boxPlot" || r2.globals.isRangeData) && (e2 *= 1.01);
      var h3 = i2 + 1;
      h3 < 2 ? h3 = 2 : h3 > 2 && (h3 -= 2);
      var c2 = o2 / h3, d2 = Math.floor(x.log10(c2)), g2 = Math.pow(10, d2), u2 = Math.round(c2 / g2);
      u2 < 1 && (u2 = 1);
      var p3 = u2 * g2, f2 = p3 * Math.floor(t3 / p3), b2 = p3 * Math.ceil(e2 / p3), v2 = f2;
      if (s2 && o2 > 2) {
        for (; l2.push(v2), !((v2 += p3) > b2); )
          ;
        return { result: l2, niceMin: l2[0], niceMax: l2[l2.length - 1] };
      }
      var m2 = t3;
      (l2 = []).push(m2);
      for (var y2 = Math.abs(e2 - t3) / i2, w2 = 0; w2 <= i2; w2++)
        m2 += y2, l2.push(m2);
      return l2[l2.length - 2] >= e2 && l2.pop(), { result: l2, niceMin: l2[0], niceMax: l2[l2.length - 1] };
    } }, { key: "linearScale", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, a2 = arguments.length > 3 ? arguments[3] : void 0, s2 = Math.abs(e2 - t3);
      (i2 = this._adjustTicksForSmallRange(i2, a2, s2)) === "dataPoints" && (i2 = this.w.globals.dataPoints - 1);
      var r2 = s2 / i2;
      i2 === Number.MAX_VALUE && (i2 = 10, r2 = 1);
      for (var o2 = [], n2 = t3; i2 >= 0; )
        o2.push(n2), n2 += r2, i2 -= 1;
      return { result: o2, niceMin: o2[0], niceMax: o2[o2.length - 1] };
    } }, { key: "logarithmicScale", value: function(t3, e2, i2) {
      for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i2)) + 1, r2 = 0; r2 < s2; r2++)
        a2.push(Math.pow(i2, r2));
      return t3 === 0 && a2.unshift(t3), { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
    } }, { key: "_adjustTicksForSmallRange", value: function(t3, e2, i2) {
      var a2 = t3;
      if (e2 !== void 0 && this.w.config.yaxis[e2].labels.formatter && this.w.config.yaxis[e2].tickAmount === void 0) {
        var s2 = this.w.config.yaxis[e2].labels.formatter(1);
        x.isNumber(Number(s2)) && !x.isFloat(s2) && (a2 = Math.ceil(i2));
      }
      return a2 < t3 ? a2 : t3;
    } }, { key: "setYScaleForIndex", value: function(t3, e2, i2) {
      var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
      a2.yAxisScale[t3] === void 0 && (a2.yAxisScale[t3] = []);
      var o2 = Math.abs(i2 - e2);
      if (r2.logarithmic && o2 <= 5 && (a2.invalidLogScale = true), r2.logarithmic && o2 > 5)
        a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.logarithmicScale(e2, i2, r2.logBase);
      else if (i2 !== -Number.MAX_VALUE && x.isNumber(i2))
        if (a2.allSeriesCollapsed = false, r2.min === void 0 && r2.max === void 0 || r2.forceNiceScale) {
          var n2 = s2.yaxis[t3].max === void 0 && s2.yaxis[t3].min === void 0 || s2.yaxis[t3].forceNiceScale;
          a2.yAxisScale[t3] = this.niceScale(e2, i2, r2.tickAmount ? r2.tickAmount : o2 < 5 && o2 > 1 ? o2 + 1 : 5, t3, n2);
        } else
          a2.yAxisScale[t3] = this.linearScale(e2, i2, r2.tickAmount, t3);
      else
        a2.yAxisScale[t3] = this.linearScale(0, 5, 5);
    } }, { key: "setXScale", value: function(t3, e2) {
      var i2 = this.w, a2 = i2.globals, s2 = i2.config.xaxis, r2 = Math.abs(e2 - t3);
      return e2 !== -Number.MAX_VALUE && x.isNumber(e2) ? a2.xAxisScale = this.linearScale(t3, e2, s2.tickAmount ? s2.tickAmount : r2 < 5 && r2 > 1 ? r2 + 1 : 5, 0) : a2.xAxisScale = this.linearScale(0, 5, 5), a2.xAxisScale;
    } }, { key: "setMultipleYScales", value: function() {
      var t3 = this, e2 = this.w.globals, i2 = this.w.config, a2 = e2.minYArr.concat([]), s2 = e2.maxYArr.concat([]), r2 = [];
      i2.yaxis.forEach(function(e3, o2) {
        var n2 = o2;
        i2.series.forEach(function(t4, i3) {
          t4.name === e3.seriesName && (n2 = i3, o2 !== i3 ? r2.push({ index: i3, similarIndex: o2, alreadyExists: true }) : r2.push({ index: i3 }));
        });
        var l2 = a2[n2], h3 = s2[n2];
        t3.setYScaleForIndex(o2, l2, h3);
      }), this.sameScaleInMultipleAxes(a2, s2, r2);
    } }, { key: "sameScaleInMultipleAxes", value: function(t3, e2, i2) {
      var a2 = this, s2 = this.w.config, r2 = this.w.globals, o2 = [];
      i2.forEach(function(t4) {
        t4.alreadyExists && (o2[t4.index] === void 0 && (o2[t4.index] = []), o2[t4.index].push(t4.index), o2[t4.index].push(t4.similarIndex));
      }), r2.yAxisSameScaleIndices = o2, o2.forEach(function(t4, e3) {
        o2.forEach(function(i3, a3) {
          var s3, r3;
          e3 !== a3 && (s3 = t4, r3 = i3, s3.filter(function(t5) {
            return r3.indexOf(t5) !== -1;
          })).length > 0 && (o2[e3] = o2[e3].concat(o2[a3]));
        });
      });
      var n2 = o2.map(function(t4) {
        return t4.filter(function(e3, i3) {
          return t4.indexOf(e3) === i3;
        });
      }).map(function(t4) {
        return t4.sort();
      });
      o2 = o2.filter(function(t4) {
        return !!t4;
      });
      var l2 = n2.slice(), h3 = l2.map(function(t4) {
        return JSON.stringify(t4);
      });
      l2 = l2.filter(function(t4, e3) {
        return h3.indexOf(JSON.stringify(t4)) === e3;
      });
      var c2 = [], d2 = [];
      t3.forEach(function(t4, i3) {
        l2.forEach(function(a3, s3) {
          a3.indexOf(i3) > -1 && (c2[s3] === void 0 && (c2[s3] = [], d2[s3] = []), c2[s3].push({ key: i3, value: t4 }), d2[s3].push({ key: i3, value: e2[i3] }));
        });
      });
      var g2 = Array.apply(null, Array(l2.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), u2 = Array.apply(null, Array(l2.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      c2.forEach(function(t4, e3) {
        t4.forEach(function(t5, i3) {
          g2[e3] = Math.min(t5.value, g2[e3]);
        });
      }), d2.forEach(function(t4, e3) {
        t4.forEach(function(t5, i3) {
          u2[e3] = Math.max(t5.value, u2[e3]);
        });
      }), t3.forEach(function(t4, e3) {
        d2.forEach(function(t5, i3) {
          var o3 = g2[i3], n3 = u2[i3];
          s2.chart.stacked && (n3 = 0, t5.forEach(function(t6, e4) {
            t6.value !== -Number.MAX_VALUE && (n3 += t6.value), o3 !== Number.MIN_VALUE && (o3 += c2[i3][e4].value);
          })), t5.forEach(function(i4, l3) {
            t5[l3].key === e3 && (s2.yaxis[e3].min !== void 0 && (o3 = typeof s2.yaxis[e3].min == "function" ? s2.yaxis[e3].min(r2.minY) : s2.yaxis[e3].min), s2.yaxis[e3].max !== void 0 && (n3 = typeof s2.yaxis[e3].max == "function" ? s2.yaxis[e3].max(r2.maxY) : s2.yaxis[e3].max), a2.setYScaleForIndex(e3, o3, n3));
          });
        });
      });
    } }, { key: "autoScaleY", value: function(t3, e2, i2) {
      t3 || (t3 = this);
      var a2 = t3.w;
      if (a2.globals.isMultipleYAxis || a2.globals.collapsedSeries.length)
        return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e2;
      var s2 = a2.globals.seriesX[0], r2 = a2.config.chart.stacked;
      return e2.forEach(function(t4, o2) {
        for (var n2 = 0, l2 = 0; l2 < s2.length; l2++)
          if (s2[l2] >= i2.xaxis.min) {
            n2 = l2;
            break;
          }
        var h3, c2, d2 = a2.globals.minYArr[o2], g2 = a2.globals.maxYArr[o2], u2 = a2.globals.stackedSeriesTotals;
        a2.globals.series.forEach(function(o3, l3) {
          var p3 = o3[n2];
          r2 ? (p3 = u2[n2], h3 = c2 = p3, u2.forEach(function(t5, e3) {
            s2[e3] <= i2.xaxis.max && s2[e3] >= i2.xaxis.min && (t5 > c2 && t5 !== null && (c2 = t5), o3[e3] < h3 && o3[e3] !== null && (h3 = o3[e3]));
          })) : (h3 = c2 = p3, o3.forEach(function(t5, e3) {
            if (s2[e3] <= i2.xaxis.max && s2[e3] >= i2.xaxis.min) {
              var r3 = t5, o4 = t5;
              a2.globals.series.forEach(function(i3, a3) {
                t5 !== null && (r3 = Math.min(i3[e3], r3), o4 = Math.max(i3[e3], o4));
              }), o4 > c2 && o4 !== null && (c2 = o4), r3 < h3 && r3 !== null && (h3 = r3);
            }
          })), h3 === void 0 && c2 === void 0 && (h3 = d2, c2 = g2), (c2 *= c2 < 0 ? 0.9 : 1.1) < 0 && c2 < g2 && (c2 = g2), (h3 *= h3 < 0 ? 1.1 : 0.9) < 0 && h3 > d2 && (h3 = d2), e2.length > 1 ? (e2[l3].min = t4.min === void 0 ? h3 : t4.min, e2[l3].max = t4.max === void 0 ? c2 : t4.max) : (e2[0].min = t4.min === void 0 ? h3 : t4.min, e2[0].max = t4.max === void 0 ? c2 : t4.max);
        });
      }), e2;
    } }]), t2;
  }(), Z = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new q(e2);
    }
    return r(t2, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, o2 = -Number.MAX_VALUE, n2 = Number.MIN_VALUE;
      a2 === null && (a2 = t3 + 1);
      var l2 = r2.series, h3 = l2, c2 = l2;
      s2.chart.type === "candlestick" ? (h3 = r2.seriesCandleL, c2 = r2.seriesCandleH) : s2.chart.type === "boxPlot" ? (h3 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData && (h3 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
      for (var d2 = t3; d2 < a2; d2++) {
        r2.dataPoints = Math.max(r2.dataPoints, l2[d2].length), r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter(function(t4) {
          return t4 !== void 0;
        }).length);
        for (var g2 = 0; g2 < r2.series[d2].length; g2++) {
          var u2 = l2[d2][g2];
          u2 !== null && x.isNumber(u2) ? (c2[d2][g2] !== void 0 && (o2 = Math.max(o2, c2[d2][g2]), e2 = Math.min(e2, c2[d2][g2])), h3[d2][g2] !== void 0 && (e2 = Math.min(e2, h3[d2][g2]), i2 = Math.max(i2, h3[d2][g2])), this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" || (r2.seriesCandleC[d2][g2] !== void 0 && (o2 = Math.max(o2, r2.seriesCandleO[d2][g2]), o2 = Math.max(o2, r2.seriesCandleH[d2][g2]), o2 = Math.max(o2, r2.seriesCandleL[d2][g2]), o2 = Math.max(o2, r2.seriesCandleC[d2][g2]), this.w.config.chart.type === "boxPlot" && (o2 = Math.max(o2, r2.seriesCandleM[d2][g2]))), !s2.series[d2].type || s2.series[d2].type === "candlestick" && s2.series[d2].type === "boxPlot" || (o2 = Math.max(o2, r2.series[d2][g2]), e2 = Math.min(e2, r2.series[d2][g2])), i2 = o2), r2.seriesGoals[d2] && r2.seriesGoals[d2][g2] && Array.isArray(r2.seriesGoals[d2][g2]) && r2.seriesGoals[d2][g2].forEach(function(t4) {
            n2 !== Number.MIN_VALUE && (n2 = Math.min(n2, t4.value), e2 = n2), o2 = Math.max(o2, t4.value), i2 = o2;
          }), x.isFloat(u2) && (u2 = x.noExponents(u2), r2.yValueDecimal = Math.max(r2.yValueDecimal, u2.toString().split(".")[1].length)), n2 > h3[d2][g2] && h3[d2][g2] < 0 && (n2 = h3[d2][g2])) : r2.hasNullValues = true;
        }
      }
      return s2.chart.type === "rangeBar" && r2.seriesRangeStart.length && r2.isBarHorizontal && (n2 = e2), s2.chart.type === "bar" && (n2 < 0 && o2 < 0 && (o2 = 0), n2 === Number.MIN_VALUE && (n2 = 0)), { minY: n2, maxY: o2, lowestY: e2, highestY: i2 };
    } }, { key: "setYRange", value: function() {
      var t3 = this.w.globals, e2 = this.w.config;
      t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
      var i2 = Number.MAX_VALUE;
      if (t3.isMultipleYAxis)
        for (var a2 = 0; a2 < t3.series.length; a2++) {
          var s2 = this.getMinYMaxY(a2, i2, null, a2 + 1);
          t3.minYArr.push(s2.minY), t3.maxYArr.push(s2.maxY), i2 = s2.lowestY;
        }
      var r2 = this.getMinYMaxY(0, i2, null, t3.series.length);
      if (t3.minY = r2.minY, t3.maxY = r2.maxY, i2 = r2.lowestY, e2.chart.stacked && this._setStackedMinMax(), (e2.chart.type === "line" || e2.chart.type === "area" || e2.chart.type === "candlestick" || e2.chart.type === "boxPlot" || e2.chart.type === "rangeBar" && !t3.isBarHorizontal) && t3.minY === Number.MIN_VALUE && i2 !== -Number.MAX_VALUE && i2 !== t3.maxY) {
        var o2 = t3.maxY - i2;
        (i2 >= 0 && i2 <= 10 || e2.yaxis[0].min !== void 0 || e2.yaxis[0].max !== void 0) && (o2 = 0), t3.minY = i2 - 5 * o2 / 100, i2 > 0 && t3.minY < 0 && (t3.minY = 0), t3.maxY = t3.maxY + 5 * o2 / 100;
      }
      if (e2.yaxis.forEach(function(e3, i3) {
        e3.max !== void 0 && (typeof e3.max == "number" ? t3.maxYArr[i3] = e3.max : typeof e3.max == "function" && (t3.maxYArr[i3] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i3] : t3.maxY)), t3.maxY = t3.maxYArr[i3]), e3.min !== void 0 && (typeof e3.min == "number" ? t3.minYArr[i3] = e3.min : typeof e3.min == "function" && (t3.minYArr[i3] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i3] === Number.MIN_VALUE ? 0 : t3.minYArr[i3] : t3.minY)), t3.minY = t3.minYArr[i3]);
      }), t3.isBarHorizontal) {
        ["min", "max"].forEach(function(i3) {
          e2.xaxis[i3] !== void 0 && typeof e2.xaxis[i3] == "number" && (i3 === "min" ? t3.minY = e2.xaxis[i3] : t3.maxY = e2.xaxis[i3]);
        });
      }
      return t3.isMultipleYAxis ? (this.scales.setMultipleYScales(), t3.minY = i2, t3.yAxisScale.forEach(function(e3, i3) {
        t3.minYArr[i3] = e3.niceMin, t3.maxYArr[i3] = e3.niceMax;
      })) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.yAxisScale[0].niceMin, t3.maxYArr[0] = t3.yAxisScale[0].niceMax), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var t3 = this.w.globals, e2 = this.w.config, i2 = e2.xaxis.type === "numeric" || e2.xaxis.type === "datetime" || e2.xaxis.type === "category" && !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
      if (t3.isXNumeric && function() {
        for (var e3 = 0; e3 < t3.series.length; e3++)
          if (t3.labels[e3])
            for (var i3 = 0; i3 < t3.labels[e3].length; i3++)
              t3.labels[e3][i3] !== null && x.isNumber(t3.labels[e3][i3]) && (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.minX = Math.min(t3.minX, t3.labels[e3][i3]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i3]));
      }(), t3.noLabelsProvided && e2.xaxis.categories.length === 0 && (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
        var a2;
        if (e2.xaxis.tickAmount === void 0 ? (a2 = Math.round(t3.svgWidth / 150), e2.xaxis.type === "numeric" && t3.dataPoints < 30 && (a2 = t3.dataPoints - 1), a2 > t3.dataPoints && t3.dataPoints !== 0 && (a2 = t3.dataPoints - 1)) : e2.xaxis.tickAmount === "dataPoints" ? (t3.series.length > 1 && (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric && (a2 = t3.maxX - t3.minX - 1)) : a2 = e2.xaxis.tickAmount, t3.xTickAmount = a2, e2.xaxis.max !== void 0 && typeof e2.xaxis.max == "number" && (t3.maxX = e2.xaxis.max), e2.xaxis.min !== void 0 && typeof e2.xaxis.min == "number" && (t3.minX = e2.xaxis.min), e2.xaxis.range !== void 0 && (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE && t3.maxX !== -Number.MAX_VALUE)
          if (e2.xaxis.convertedCatToNumeric && !t3.dataFormatXNumeric) {
            for (var s2 = [], r2 = t3.minX - 1; r2 < t3.maxX; r2++)
              s2.push(r2 + 1);
            t3.xAxisScale = { result: s2, niceMin: s2[0], niceMax: s2[s2.length - 1] };
          } else
            t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
        else
          t3.xAxisScale = this.scales.linearScale(1, a2, a2), t3.noLabelsProvided && t3.labels.length > 0 && (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1), t3.seriesX = t3.labels.slice());
        i2 && (t3.labels = t3.xAxisScale.result.slice());
      }
      return t3.isBarHorizontal && t3.labels.length && (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
    } }, { key: "setZRange", value: function() {
      var t3 = this.w.globals;
      if (t3.isDataXYZ) {
        for (var e2 = 0; e2 < t3.series.length; e2++)
          if (t3.seriesZ[e2] !== void 0)
            for (var i2 = 0; i2 < t3.seriesZ[e2].length; i2++)
              t3.seriesZ[e2][i2] !== null && x.isNumber(t3.seriesZ[e2][i2]) && (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i2]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i2]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var t3 = this.w.globals, e2 = this.w.config;
      if (t3.minX === t3.maxX) {
        var i2 = new R(this.ctx);
        if (e2.xaxis.type === "datetime") {
          var a2 = i2.getDate(t3.minX);
          e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
          var s2 = i2.getDate(t3.maxX);
          e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
        } else
          (e2.xaxis.type === "numeric" || e2.xaxis.type === "category" && !t3.noLabelsProvided) && (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var t3 = this.w.globals;
      t3.isXNumeric && t3.seriesX.forEach(function(e2, i2) {
        e2.length === 1 && e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
        var a2 = e2.slice();
        a2.sort(function(t4, e3) {
          return t4 - e3;
        }), a2.forEach(function(e3, i3) {
          if (i3 > 0) {
            var s2 = e3 - a2[i3 - 1];
            s2 > 0 && (t3.minXDiff = Math.min(s2, t3.minXDiff));
          }
        }), t3.dataPoints !== 1 && t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var t3 = this.w.globals, e2 = [], i2 = [];
      if (t3.series.length)
        for (var a2 = 0; a2 < t3.series[t3.maxValsInArrayIndex].length; a2++)
          for (var s2 = 0, r2 = 0, o2 = 0; o2 < t3.series.length; o2++)
            t3.series[o2][a2] !== null && x.isNumber(t3.series[o2][a2]) && (t3.series[o2][a2] > 0 ? s2 = s2 + parseFloat(t3.series[o2][a2]) + 1e-4 : r2 += parseFloat(t3.series[o2][a2])), o2 === t3.series.length - 1 && (e2.push(s2), i2.push(r2));
      for (var n2 = 0; n2 < e2.length; n2++)
        t3.maxY = Math.max(t3.maxY, e2[n2]), t3.minY = Math.min(t3.minY, i2[n2]);
    } }]), t2;
  }(), $ = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var i2 = this.w;
      this.xaxisFontSize = i2.config.xaxis.labels.style.fontSize, this.axisFontFamily = i2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i2.config.chart.type === "bar" && i2.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, i2.config.xaxis.position === "bottom" && (this.xAxisoffX = i2.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new G(e2);
    }
    return r(t2, [{ key: "drawYaxis", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = i2.config.yaxis[t3].labels.style, r2 = s2.fontSize, o2 = s2.fontFamily, n2 = s2.fontWeight, l2 = a2.group({ class: "apexcharts-yaxis", rel: t3, transform: "translate(" + i2.globals.translateYAxisX[t3] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(t3))
        return l2;
      var h3 = a2.group({ class: "apexcharts-yaxis-texts-g" });
      l2.add(h3);
      var c2 = i2.globals.yAxisScale[t3].result.length - 1, d2 = i2.globals.gridHeight / c2, g2 = i2.globals.translateY, u2 = i2.globals.yLabelFormatters[t3], p3 = i2.globals.yAxisScale[t3].result.slice();
      p3 = this.axesUtils.checkForReversedLabels(t3, p3);
      var f2 = "";
      if (i2.config.yaxis[t3].labels.show)
        for (var x2 = function(l3) {
          var x3 = p3[l3];
          x3 = u2(x3, l3, i2);
          var b3 = i2.config.yaxis[t3].labels.padding;
          i2.config.yaxis[t3].opposite && i2.config.yaxis.length !== 0 && (b3 *= -1);
          var v3 = e2.axesUtils.getYAxisForeColor(s2.colors, t3), m2 = a2.drawText({ x: b3, y: g2 + c2 / 10 + i2.config.yaxis[t3].labels.offsetY + 1, text: x3, textAnchor: i2.config.yaxis[t3].opposite ? "start" : "end", fontSize: r2, fontFamily: o2, fontWeight: n2, foreColor: Array.isArray(v3) ? v3[l3] : v3, isPlainText: false, cssClass: "apexcharts-yaxis-label " + s2.cssClass });
          l3 === c2 && (f2 = m2), h3.add(m2);
          var y3 = document.createElementNS(i2.globals.SVGNS, "title");
          if (y3.textContent = Array.isArray(x3) ? x3.join(" ") : x3, m2.node.appendChild(y3), i2.config.yaxis[t3].labels.rotate !== 0) {
            var w3 = a2.rotateAroundCenter(f2.node), k3 = a2.rotateAroundCenter(m2.node);
            m2.node.setAttribute("transform", "rotate(".concat(i2.config.yaxis[t3].labels.rotate, " ").concat(w3.x, " ").concat(k3.y, ")"));
          }
          g2 += d2;
        }, b2 = c2; b2 >= 0; b2--)
          x2(b2);
      if (i2.config.yaxis[t3].title.text !== void 0) {
        var v2 = a2.group({ class: "apexcharts-yaxis-title" }), y2 = 0;
        i2.config.yaxis[t3].opposite && (y2 = i2.globals.translateYAxisX[t3]);
        var w2 = a2.drawText({ x: y2, y: i2.globals.gridHeight / 2 + i2.globals.translateY + i2.config.yaxis[t3].title.offsetY, text: i2.config.yaxis[t3].title.text, textAnchor: "end", foreColor: i2.config.yaxis[t3].title.style.color, fontSize: i2.config.yaxis[t3].title.style.fontSize, fontWeight: i2.config.yaxis[t3].title.style.fontWeight, fontFamily: i2.config.yaxis[t3].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i2.config.yaxis[t3].title.style.cssClass });
        v2.add(w2), l2.add(v2);
      }
      var k2 = i2.config.yaxis[t3].axisBorder, A2 = 31 + k2.offsetX;
      if (i2.config.yaxis[t3].opposite && (A2 = -31 - k2.offsetX), k2.show) {
        var S2 = a2.drawLine(A2, i2.globals.translateY + k2.offsetY - 2, A2, i2.globals.gridHeight + i2.globals.translateY + k2.offsetY + 2, k2.color, 0, k2.width);
        l2.add(S2);
      }
      return i2.config.yaxis[t3].axisTicks.show && this.axesUtils.drawYAxisTicks(A2, c2, k2, i2.config.yaxis[t3].axisTicks, t3, d2, l2), l2;
    } }, { key: "drawYaxisInversed", value: function(t3) {
      var e2 = this.w, i2 = new m(this.ctx), a2 = i2.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
      a2.add(s2);
      var r2 = e2.globals.yAxisScale[t3].result.length - 1, o2 = e2.globals.gridWidth / r2 + 0.1, n2 = o2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h3 = e2.globals.yAxisScale[t3].result.slice(), c2 = e2.globals.timescaleLabels;
      c2.length > 0 && (this.xaxisLabels = c2.slice(), r2 = (h3 = c2.slice()).length), h3 = this.axesUtils.checkForReversedLabels(t3, h3);
      var d2 = c2.length;
      if (e2.config.xaxis.labels.show)
        for (var g2 = d2 ? 0 : r2; d2 ? g2 < d2 : g2 >= 0; d2 ? g2++ : g2--) {
          var u2 = h3[g2];
          u2 = l2(u2, g2, e2);
          var p3 = e2.globals.gridWidth + e2.globals.padHorizontal - (n2 - o2 + e2.config.xaxis.labels.offsetX);
          if (c2.length) {
            var f2 = this.axesUtils.getLabel(h3, c2, p3, g2, this.drawnLabels, this.xaxisFontSize);
            p3 = f2.x, u2 = f2.text, this.drawnLabels.push(f2.text), g2 === 0 && e2.globals.skipFirstTimelinelabel && (u2 = ""), g2 === h3.length - 1 && e2.globals.skipLastTimelinelabel && (u2 = "");
          }
          var x2 = i2.drawText({ x: p3, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - (e2.config.xaxis.position === "top" ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u2, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label " + e2.config.xaxis.labels.style.cssClass });
          s2.add(x2), x2.tspan(u2);
          var b2 = document.createElementNS(e2.globals.SVGNS, "title");
          b2.textContent = u2, x2.node.appendChild(b2), n2 += o2;
        }
      return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
    } }, { key: "inversedYAxisBorder", value: function(t3) {
      var e2 = this.w, i2 = new m(this.ctx), a2 = e2.config.xaxis.axisBorder;
      if (a2.show) {
        var s2 = 0;
        e2.config.chart.type === "bar" && e2.globals.isXNumeric && (s2 -= 15);
        var r2 = i2.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
        t3.add(r2);
      }
    } }, { key: "inversedYAxisTitleText", value: function(t3) {
      var e2 = this.w, i2 = new m(this.ctx);
      if (e2.config.xaxis.title.text !== void 0) {
        var a2 = i2.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e2.config.xaxis.title.style.cssClass });
        a2.add(s2), t3.add(a2);
      }
    } }, { key: "yAxisTitleRotate", value: function(t3, e2) {
      var i2 = this.w, a2 = new m(this.ctx), s2 = { width: 0, height: 0 }, r2 = { width: 0, height: 0 }, o2 = i2.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-texts-g"));
      o2 !== null && (s2 = o2.getBoundingClientRect());
      var n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-title text"));
      if (n2 !== null && (r2 = n2.getBoundingClientRect()), n2 !== null) {
        var l2 = this.xPaddingForYAxisTitle(t3, s2, r2, e2);
        n2.setAttribute("x", l2.xPos - (e2 ? 10 : 0));
      }
      if (n2 !== null) {
        var h3 = a2.rotateAroundCenter(n2);
        n2.setAttribute("transform", "rotate(".concat(e2 ? -1 * i2.config.yaxis[t3].title.rotate : i2.config.yaxis[t3].title.rotate, " ").concat(h3.x, " ").concat(h3.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(t3, e2, i2, a2) {
      var s2 = this.w, r2 = 0, o2 = 0, n2 = 10;
      return s2.config.yaxis[t3].title.text === void 0 || t3 < 0 ? { xPos: o2, padd: 0 } : (a2 ? (o2 = e2.width + s2.config.yaxis[t3].title.offsetX + i2.width / 2 + n2 / 2, (r2 += 1) === 0 && (o2 -= n2 / 2)) : (o2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i2.width / 2, s2.globals.isBarHorizontal && (n2 = 25, o2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: o2, padd: n2 });
    } }, { key: "setYAxisXPosition", value: function(t3, e2) {
      var i2 = this.w, a2 = 0, s2 = 0, r2 = 18, o2 = 1;
      i2.config.yaxis.length > 1 && (this.multipleYs = true), i2.config.yaxis.map(function(n2, l2) {
        var h3 = i2.globals.ignoreYAxisIndexes.indexOf(l2) > -1 || !n2.show || n2.floating || t3[l2].width === 0, c2 = t3[l2].width + e2[l2].width;
        n2.opposite ? i2.globals.isBarHorizontal ? (s2 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l2] = s2 - n2.labels.offsetX) : (s2 = i2.globals.gridWidth + i2.globals.translateX + o2, h3 || (o2 = o2 + c2 + 20), i2.globals.translateYAxisX[l2] = s2 - n2.labels.offsetX + 20) : (a2 = i2.globals.translateX - r2, h3 || (r2 = r2 + c2 + 20), i2.globals.translateYAxisX[l2] = a2 + n2.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var t3 = this.w, e2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (e2 = x.listToArray(e2)).forEach(function(e3, i2) {
        var a2 = t3.config.yaxis[i2];
        if (a2 && a2.labels.align !== void 0) {
          var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-texts-g")), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-label"));
          r2 = x.listToArray(r2);
          var o2 = s2.getBoundingClientRect();
          a2.labels.align === "left" ? (r2.forEach(function(t4, e4) {
            t4.setAttribute("text-anchor", "start");
          }), a2.opposite || s2.setAttribute("transform", "translate(-".concat(o2.width, ", 0)"))) : a2.labels.align === "center" ? (r2.forEach(function(t4, e4) {
            t4.setAttribute("text-anchor", "middle");
          }), s2.setAttribute("transform", "translate(".concat(o2.width / 2 * (a2.opposite ? 1 : -1), ", 0)"))) : a2.labels.align === "right" && (r2.forEach(function(t4, e4) {
            t4.setAttribute("text-anchor", "end");
          }), a2.opposite && s2.setAttribute("transform", "translate(".concat(o2.width, ", 0)")));
        }
      });
    } }]), t2;
  }(), J = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = x.bind(this.documentEvent, this);
    }
    return r(t2, [{ key: "addEventListener", value: function(t3, e2) {
      var i2 = this.w;
      i2.globals.events.hasOwnProperty(t3) ? i2.globals.events[t3].push(e2) : i2.globals.events[t3] = [e2];
    } }, { key: "removeEventListener", value: function(t3, e2) {
      var i2 = this.w;
      if (i2.globals.events.hasOwnProperty(t3)) {
        var a2 = i2.globals.events[t3].indexOf(e2);
        a2 !== -1 && i2.globals.events[t3].splice(a2, 1);
      }
    } }, { key: "fireEvent", value: function(t3, e2) {
      var i2 = this.w;
      if (i2.globals.events.hasOwnProperty(t3)) {
        e2 && e2.length || (e2 = []);
        for (var a2 = i2.globals.events[t3], s2 = a2.length, r2 = 0; r2 < s2; r2++)
          a2[r2].apply(null, e2);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var t3 = this, e2 = this.w, i2 = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
      this.ctx.eventList.forEach(function(t4) {
        a2.addEventListener(t4, function(t5) {
          var a3 = Object.assign({}, e2, { seriesIndex: e2.globals.capturedSeriesIndex, dataPointIndex: e2.globals.capturedDataPointIndex });
          t5.type === "mousemove" || t5.type === "touchmove" ? typeof e2.config.chart.events.mouseMove == "function" && e2.config.chart.events.mouseMove(t5, i2, a3) : t5.type === "mouseleave" || t5.type === "touchleave" ? typeof e2.config.chart.events.mouseLeave == "function" && e2.config.chart.events.mouseLeave(t5, i2, a3) : (t5.type === "mouseup" && t5.which === 1 || t5.type === "touchend") && (typeof e2.config.chart.events.click == "function" && e2.config.chart.events.click(t5, i2, a3), i2.ctx.events.fireEvent("click", [t5, i2, a3]));
        }, { capture: false, passive: true });
      }), this.ctx.eventList.forEach(function(i3) {
        e2.globals.dom.baseEl.addEventListener(i3, t3.documentEvent, { passive: true });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(t3) {
      var e2 = this.w, i2 = t3.target.className;
      if (t3.type === "click") {
        var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-menu");
        a2 && a2.classList.contains("apexcharts-menu-open") && i2 !== "apexcharts-menu-icon" && a2.classList.remove("apexcharts-menu-open");
      }
      e2.globals.clientX = t3.type === "touchmove" ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = t3.type === "touchmove" ? t3.touches[0].clientY : t3.clientY;
    } }]), t2;
  }(), Q = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "setCurrentLocaleValues", value: function(t3) {
      var e2 = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i2 = e2.filter(function(e3) {
        return e3.name === t3;
      })[0];
      if (!i2)
        throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var a2 = x.extend(C, i2);
      this.w.globals.locale = a2.options;
    } }]), t2;
  }(), K = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "drawAxis", value: function(t3, e2) {
      var i2, a2, s2 = this.w.globals, r2 = this.w.config, o2 = new _(this.ctx), n2 = new $(this.ctx);
      s2.axisCharts && t3 !== "radar" && (s2.isBarHorizontal ? (a2 = n2.drawYaxisInversed(0), i2 = o2.drawXaxisInversed(0), s2.dom.elGraphical.add(i2), s2.dom.elGraphical.add(a2)) : (i2 = o2.drawXaxis(), s2.dom.elGraphical.add(i2), r2.yaxis.map(function(t4, e3) {
        s2.ignoreYAxisIndexes.indexOf(e3) === -1 && (a2 = n2.drawYaxis(e3), s2.dom.Paper.add(a2));
      })));
    } }]), t2;
  }(), tt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "drawXCrosshairs", value: function() {
      var t3 = this.w, e2 = new m(this.ctx), i2 = new v(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, o2 = a2.colorFrom, n2 = a2.colorTo, l2 = a2.opacityFrom, h3 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, g2 = s2.left, u2 = s2.top, p3 = s2.blur, f2 = s2.color, b2 = s2.opacity, y2 = t3.config.xaxis.crosshairs.fill.color;
      if (t3.config.xaxis.crosshairs.show) {
        r2 === "gradient" && (y2 = e2.drawGradient("vertical", o2, n2, l2, h3, null, c2, null));
        var w2 = e2.drawRect();
        t3.config.xaxis.crosshairs.width === 1 && (w2 = e2.drawLine());
        var k2 = t3.globals.gridHeight;
        (!x.isNumber(k2) || k2 < 0) && (k2 = 0);
        var A2 = t3.config.xaxis.crosshairs.width;
        (!x.isNumber(A2) || A2 < 0) && (A2 = 0), w2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: k2, width: A2, height: k2, fill: y2, filter: "none", "fill-opacity": t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, "stroke-width": t3.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t3.config.xaxis.crosshairs.stroke.dashArray }), d2 && (w2 = i2.dropShadow(w2, { left: g2, top: u2, blur: p3, color: f2, opacity: b2 })), t3.globals.dom.elGraphical.add(w2);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var t3 = this.w, e2 = new m(this.ctx), i2 = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
      if (t3.config.yaxis[0].crosshairs.show) {
        var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
        s2.attr({ class: "apexcharts-ycrosshairs" }), t3.globals.dom.elGraphical.add(s2);
      }
      var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, 0, 0);
      r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t3.globals.dom.elGraphical.add(r2);
    } }]), t2;
  }(), et = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "checkResponsiveConfig", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = i2.config;
      if (a2.responsive.length !== 0) {
        var s2 = a2.responsive.slice();
        s2.sort(function(t4, e3) {
          return t4.breakpoint > e3.breakpoint ? 1 : e3.breakpoint > t4.breakpoint ? -1 : 0;
        }).reverse();
        var r2 = new N({}), o2 = function() {
          var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a3 = s2[0].breakpoint, o3 = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (o3 > a3) {
            var n3 = y.extendArrayProps(r2, i2.globals.initialConfig, i2);
            t4 = x.extend(n3, t4), t4 = x.extend(i2.config, t4), e2.overrideResponsiveOptions(t4);
          } else
            for (var l2 = 0; l2 < s2.length; l2++)
              o3 < s2[l2].breakpoint && (t4 = y.extendArrayProps(r2, s2[l2].options, i2), t4 = x.extend(i2.config, t4), e2.overrideResponsiveOptions(t4));
        };
        if (t3) {
          var n2 = y.extendArrayProps(r2, t3, i2);
          n2 = x.extend(i2.config, n2), o2(n2 = x.extend(n2, t3));
        } else
          o2({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(t3) {
      var e2 = new N(t3).init({ responsiveOverride: true });
      this.w.config = e2;
    } }]), t2;
  }(), it = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.colors = [], this.w = e2.w;
      var i2 = this.w;
      this.isColorFn = false, this.isHeatmapDistributed = i2.config.chart.type === "treemap" && i2.config.plotOptions.treemap.distributed || i2.config.chart.type === "heatmap" && i2.config.plotOptions.heatmap.distributed, this.isBarDistributed = i2.config.plotOptions.bar.distributed && (i2.config.chart.type === "bar" || i2.config.chart.type === "rangeBar");
    }
    return r(t2, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var t3 = this, e2 = this.w, i2 = new x();
      if (e2.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e2.config.theme.mode)), e2.config.colors === void 0 ? e2.globals.colors = this.predefined() : (e2.globals.colors = e2.config.colors, Array.isArray(e2.config.colors) && e2.config.colors.length > 0 && typeof e2.config.colors[0] == "function" && (e2.globals.colors = e2.config.series.map(function(i3, a3) {
        var s3 = e2.config.colors[a3];
        return s3 || (s3 = e2.config.colors[0]), typeof s3 == "function" ? (t3.isColorFn = true, s3({ value: e2.globals.axisCharts ? e2.globals.series[a3][0] ? e2.globals.series[a3][0] : 0 : e2.globals.series[a3], seriesIndex: a3, dataPointIndex: a3, w: e2 })) : s3;
      }))), e2.globals.seriesColors.map(function(t4, i3) {
        t4 && (e2.globals.colors[i3] = t4);
      }), e2.config.theme.monochrome.enabled) {
        var a2 = [], s2 = e2.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (s2 = e2.globals.series[0].length * e2.globals.series.length);
        for (var r2 = e2.config.theme.monochrome.color, o2 = 1 / (s2 / e2.config.theme.monochrome.shadeIntensity), n2 = e2.config.theme.monochrome.shadeTo, l2 = 0, h3 = 0; h3 < s2; h3++) {
          var c2 = void 0;
          n2 === "dark" ? (c2 = i2.shadeColor(-1 * l2, r2), l2 += o2) : (c2 = i2.shadeColor(l2, r2), l2 += o2), a2.push(c2);
        }
        e2.globals.colors = a2.slice();
      }
      var d2 = e2.globals.colors.slice();
      this.pushExtraColors(e2.globals.colors);
      ["fill", "stroke"].forEach(function(i3) {
        e2.config[i3].colors === void 0 ? e2.globals[i3].colors = t3.isColorFn ? e2.config.colors : d2 : e2.globals[i3].colors = e2.config[i3].colors.slice(), t3.pushExtraColors(e2.globals[i3].colors);
      }), e2.config.dataLabels.style.colors === void 0 ? e2.globals.dataLabels.style.colors = d2 : e2.globals.dataLabels.style.colors = e2.config.dataLabels.style.colors.slice(), this.pushExtraColors(e2.globals.dataLabels.style.colors, 50), e2.config.plotOptions.radar.polygons.fill.colors === void 0 ? e2.globals.radarPolygons.fill.colors = [e2.config.theme.mode === "dark" ? "#424242" : "none"] : e2.globals.radarPolygons.fill.colors = e2.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e2.globals.radarPolygons.fill.colors, 20), e2.config.markers.colors === void 0 ? e2.globals.markers.colors = d2 : e2.globals.markers.colors = e2.config.markers.colors.slice(), this.pushExtraColors(e2.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
      if (i2 === null && (i2 = this.isBarDistributed || this.isHeatmapDistributed || a2.config.chart.type === "heatmap" && a2.config.plotOptions.heatmap.colorScale.inverse), i2 && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length < s2)
        for (var r2 = s2 - t3.length, o2 = 0; o2 < r2; o2++)
          t3.push(t3[o2]);
    } }, { key: "updateThemeOptions", value: function(t3) {
      t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
      var e2 = t3.theme.mode || "light", i2 = t3.theme.palette ? t3.theme.palette : e2 === "dark" ? "palette4" : "palette1", a2 = t3.chart.foreColor ? t3.chart.foreColor : e2 === "dark" ? "#f6f7f8" : "#373d3f";
      return t3.tooltip.theme = e2, t3.chart.foreColor = a2, t3.theme.palette = i2, t3;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
          break;
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
      }
      return this.colors;
    } }]), t2;
  }(), at = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(t3) {
      var e2 = this.w, i2 = t3 === "title" ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i2.offsetY, r2 = "middle";
      if (i2.align === "left" ? (a2 = 10, r2 = "start") : i2.align === "right" && (a2 = e2.globals.svgWidth - 10, r2 = "end"), a2 += i2.offsetX, s2 = s2 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, i2.text !== void 0) {
        var o2 = new m(this.ctx).drawText({ x: a2, y: s2, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
        o2.node.setAttribute("class", "apexcharts-".concat(t3, "-text")), e2.globals.dom.Paper.add(o2);
      }
    } }]), t2;
  }(), st = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.dCtx = e2;
    }
    return r(t2, [{ key: "getTitleSubtitleCoords", value: function(t3) {
      var e2 = this.w, i2 = 0, a2 = 0, s2 = t3 === "title" ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(t3, "-text"));
      if (r2 !== null && !s2) {
        var o2 = r2.getBoundingClientRect();
        i2 = o2.width, a2 = e2.globals.axisCharts ? o2.height + 5 : o2.height;
      }
      return { width: i2, height: a2 };
    } }, { key: "getLegendsRect", value: function() {
      var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelector(".apexcharts-legend");
      t3.config.legend.height || t3.config.legend.position !== "top" && t3.config.legend.position !== "bottom" || (e2.style.maxHeight = t3.globals.svgHeight / 2 + "px");
      var i2 = Object.assign({}, x.getBoundingClientRect(e2));
      return e2 !== null && !t3.config.legend.floating && t3.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: i2.height === 0 ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, t3.config.legend.position !== "left" && t3.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > t3.globals.svgWidth && (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getLargestStringFromMultiArr", value: function(t3, e2) {
      var i2 = t3;
      if (this.w.globals.isMultiLineX) {
        var a2 = e2.map(function(t4, e3) {
          return Array.isArray(t4) ? t4.length : 1;
        }), s2 = Math.max.apply(Math, u(a2));
        i2 = e2[a2.indexOf(s2)];
      }
      return i2;
    } }]), t2;
  }(), rt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.dCtx = e2;
    }
    return r(t2, [{ key: "getxAxisLabelsCoords", value: function() {
      var t3, e2 = this.w, i2 = e2.globals.labels.slice();
      if (e2.config.xaxis.convertedCatToNumeric && i2.length === 0 && (i2 = e2.globals.categoryLabels), e2.globals.timescaleLabels.length > 0) {
        var a2 = this.getxAxisTimeScaleLabelsCoords();
        t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
      } else {
        this.dCtx.lgWidthForSideLegends = e2.config.legend.position !== "left" && e2.config.legend.position !== "right" || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var s2 = e2.globals.xLabelFormatter, r2 = x.getLargestStringFromArr(i2), o2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
        e2.globals.isBarHorizontal && (o2 = r2 = e2.globals.yAxisScale[0].result.reduce(function(t4, e3) {
          return t4.length > e3.length ? t4 : e3;
        }, 0));
        var n2 = new V(this.dCtx.ctx), l2 = r2;
        r2 = n2.xLabelFormat(s2, r2, l2, { i: void 0, dateFormatter: new R(this.dCtx.ctx).formatDate, w: e2 }), o2 = n2.xLabelFormat(s2, o2, l2, { i: void 0, dateFormatter: new R(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric && r2 === void 0 || String(r2).trim() === "") && (o2 = r2 = "1");
        var h3 = new m(this.dCtx.ctx), c2 = h3.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
        if (r2 !== o2 && (d2 = h3.getTextRects(o2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width >= d2.width ? c2.width : d2.width, height: c2.height >= d2.height ? c2.height : d2.height }).width * i2.length > e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && e2.config.xaxis.labels.rotate !== 0 || e2.config.xaxis.labels.rotateAlways) {
          if (!e2.globals.isBarHorizontal) {
            e2.globals.rotateXLabels = true;
            var g2 = function(t4) {
              return h3.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, "rotate(".concat(e2.config.xaxis.labels.rotate, " 0 0)"), false);
            };
            c2 = g2(r2), r2 !== o2 && (d2 = g2(o2)), t3.height = (c2.height > d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width > d2.width ? c2.width : d2.width;
          }
        } else
          e2.globals.rotateXLabels = false;
      }
      return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var t3, e2 = this.w;
      if (!e2.globals.hasGroups)
        return { width: 0, height: 0 };
      var i2, a2 = ((t3 = e2.config.xaxis.group.style) === null || t3 === void 0 ? void 0 : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map(function(t4) {
        return t4.title;
      }), r2 = x.getLargestStringFromArr(s2), o2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), n2 = new m(this.dCtx.ctx), l2 = n2.getTextRects(r2, a2), h3 = l2;
      return r2 !== o2 && (h3 = n2.getTextRects(o2, a2)), i2 = { width: l2.width >= h3.width ? l2.width : h3.width, height: l2.height >= h3.height ? l2.height : h3.height }, e2.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var t3 = this.w, e2 = 0, i2 = 0;
      if (t3.config.xaxis.title.text !== void 0) {
        var a2 = new m(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
        e2 = a2.width, i2 = a2.height;
      }
      return { width: e2, height: i2 };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var t3, e2 = this.w;
      this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
      var i2 = this.dCtx.timescaleLabels.map(function(t4) {
        return t4.value;
      }), a2 = i2.reduce(function(t4, e3) {
        return t4 === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t4.length > e3.length ? t4 : e3;
      }, 0);
      return 1.05 * (t3 = new m(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i2.length > e2.globals.gridWidth && e2.config.xaxis.labels.rotate !== 0 && (e2.globals.overlappingXLabels = true), t3;
    } }, { key: "additionalPaddingXLabels", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = i2.globals, s2 = i2.config, r2 = s2.xaxis.type, o2 = t3.width;
      a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
      var n2 = i2.config.yaxis[0].opposite && i2.globals.isBarHorizontal, l2 = function(t4, n3) {
        (function(t5) {
          return a2.collapsedSeriesIndices.indexOf(t5) !== -1;
        })(n3) || function(t5) {
          if (e2.dCtx.timescaleLabels && e2.dCtx.timescaleLabels.length) {
            var n4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + o2 / 1.75 - e2.dCtx.yAxisWidthRight, h3 = n4.position - o2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = i2.config.legend.position === "right" && e2.dCtx.lgRect.width > 0 ? e2.dCtx.lgRect.width : 0;
            l3 > a2.svgWidth - a2.translateX - c2 && (a2.skipLastTimelinelabel = true), h3 < -(t5.show && !t5.floating || s2.chart.type !== "bar" && s2.chart.type !== "candlestick" && s2.chart.type !== "rangeBar" && s2.chart.type !== "boxPlot" ? 10 : o2 / 1.75) && (a2.skipFirstTimelinelabel = true);
          } else
            r2 === "datetime" ? e2.dCtx.gridPad.right < o2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : r2 !== "datetime" && e2.dCtx.gridPad.right < o2 / 2 - e2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i2.config.xaxis.labels.trim && (i2.config.xaxis.tickPlacement !== "between" || i2.globals.isBarHorizontal) && (e2.dCtx.xPadRight = o2 / 2 + 1);
        }(t4);
      };
      s2.yaxis.forEach(function(t4, i3) {
        n2 ? (e2.dCtx.gridPad.left < o2 && (e2.dCtx.xPadLeft = o2 / 2 + 1), e2.dCtx.xPadRight = o2 / 2 + 1) : l2(t4, i3);
      });
    } }]), t2;
  }(), ot = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.dCtx = e2;
    }
    return r(t2, [{ key: "getyAxisLabelsCoords", value: function() {
      var t3 = this, e2 = this.w, i2 = [], a2 = 10, s2 = new G(this.dCtx.ctx);
      return e2.config.yaxis.map(function(r2, o2) {
        var n2 = e2.globals.yAxisScale[o2], l2 = 0;
        if (!s2.isYAxisHidden(o2) && r2.labels.show && r2.labels.minWidth !== void 0 && (l2 = r2.labels.minWidth), !s2.isYAxisHidden(o2) && r2.labels.show && n2.result.length) {
          var h3 = e2.globals.yLabelFormatters[o2], c2 = n2.niceMin === Number.MIN_VALUE ? 0 : n2.niceMin, d2 = String(c2).length > String(n2.niceMax).length ? c2 : n2.niceMax, g2 = h3(d2, { seriesIndex: o2, dataPointIndex: -1, w: e2 }), u2 = g2;
          if (g2 !== void 0 && g2.length !== 0 || (g2 = d2), e2.globals.isBarHorizontal) {
            a2 = 0;
            var p3 = e2.globals.labels.slice();
            g2 = h3(g2 = x.getLargestStringFromArr(p3), { seriesIndex: o2, dataPointIndex: -1, w: e2 }), u2 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(g2, p3);
          }
          var f2 = new m(t3.dCtx.ctx), b2 = "rotate(".concat(r2.labels.rotate, " 0 0)"), v2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, b2, false), y2 = v2;
          g2 !== u2 && (y2 = f2.getTextRects(u2, r2.labels.style.fontSize, r2.labels.style.fontFamily, b2, false)), i2.push({ width: (l2 > y2.width || l2 > v2.width ? l2 : y2.width > v2.width ? y2.width : v2.width) + a2, height: y2.height > v2.height ? y2.height : v2.height });
        } else
          i2.push({ width: 0, height: 0 });
      }), i2;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var t3 = this, e2 = this.w, i2 = [];
      return e2.config.yaxis.map(function(e3, a2) {
        if (e3.show && e3.title.text !== void 0) {
          var s2 = new m(t3.dCtx.ctx), r2 = "rotate(".concat(e3.title.rotate, " 0 0)"), o2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
          i2.push({ width: o2.width, height: o2.height });
        } else
          i2.push({ width: 0, height: 0 });
      }), i2;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var t3 = this.w, e2 = 0, i2 = 0, a2 = 0, s2 = t3.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new G(this.dCtx.ctx), o2 = function(o3, n2) {
        var l2 = t3.config.yaxis[n2].floating, h3 = 0;
        o3.width > 0 && !l2 ? (h3 = o3.width + s2, function(e3) {
          return t3.globals.ignoreYAxisIndexes.indexOf(e3) > -1;
        }(n2) && (h3 = h3 - o3.width - s2)) : h3 = l2 || r2.isYAxisHidden(n2) ? 0 : 5, t3.config.yaxis[n2].opposite ? a2 += h3 : i2 += h3, e2 += h3;
      };
      return t3.globals.yLabelsCoords.map(function(t4, e3) {
        o2(t4, e3);
      }), t3.globals.yTitleCoords.map(function(t4, e3) {
        o2(t4, e3);
      }), t3.globals.isBarHorizontal && !t3.config.yaxis[0].floating && (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a2, e2;
    } }]), t2;
  }(), nt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.dCtx = e2;
    }
    return r(t2, [{ key: "gridPadForColumnsInNumericAxis", value: function(t3) {
      var e2 = this.w;
      if (e2.globals.noData || e2.globals.allSeriesCollapsed)
        return 0;
      var i2 = function(t4) {
        return t4 === "bar" || t4 === "rangeBar" || t4 === "candlestick" || t4 === "boxPlot";
      }, a2 = e2.config.chart.type, s2 = 0, r2 = i2(a2) ? e2.config.series.length : 1;
      if (e2.globals.comboBarCount > 0 && (r2 = e2.globals.comboBarCount), e2.globals.collapsedSeries.forEach(function(t4) {
        i2(t4.type) && (r2 -= 1);
      }), e2.config.chart.stacked && (r2 = 1), (i2(a2) || e2.globals.comboBarCount > 0) && e2.globals.isXNumeric && !e2.globals.isBarHorizontal && r2 > 0) {
        var o2, n2, l2 = Math.abs(e2.globals.initialMaxX - e2.globals.initialMinX);
        l2 <= 3 && (l2 = e2.globals.dataPoints), o2 = l2 / t3, e2.globals.minXDiff && e2.globals.minXDiff / o2 > 0 && (n2 = e2.globals.minXDiff / o2), n2 > t3 / 2 && (n2 /= 2), (s2 = n2 / r2 * parseInt(e2.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s2 = 1), s2 = s2 / (r2 > 1 ? 1 : 1.5) + 5, e2.globals.barPadForNumericAxis = s2;
      }
      return s2;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dCtx.isSparkline || !e2.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(i3) {
        e2.config[i3].text !== void 0 ? a2 += e2.config[i3].margin : a2 += t3.dCtx.isSparkline || !e2.globals.axisCharts ? 0 : 5;
      }), !e2.config.legend.show || e2.config.legend.position !== "bottom" || e2.config.legend.floating || e2.globals.axisCharts || (a2 += 10);
      var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i2.gridHeight = i2.gridHeight - s2.height - r2.height - a2, i2.translateY = i2.translateY + s2.height + r2.height + a2;
    } }, { key: "setGridXPosForDualYAxis", value: function(t3, e2) {
      var i2 = this.w, a2 = new G(this.dCtx.ctx);
      i2.config.yaxis.map(function(s2, r2) {
        i2.globals.ignoreYAxisIndexes.indexOf(r2) !== -1 || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite && (i2.globals.translateX = i2.globals.translateX - (e2[r2].width + t3[r2].width) - parseInt(i2.config.yaxis[r2].labels.style.fontSize, 10) / 1.2 - 12), i2.globals.translateX < 2 && (i2.globals.translateX = 2));
      });
    } }]), t2;
  }(), lt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new st(this), this.dimYAxis = new ot(this), this.dimXAxis = new rt(this), this.dimGrid = new nt(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return r(t2, [{ key: "plotCoords", value: function() {
      var t3 = this, e2 = this.w, i2 = e2.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (e2.config.markers.discrete.length > 0 || e2.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e3) {
        var i3 = g(e3, 2), a3 = i3[0], s2 = i3[1];
        t3.gridPad[a3] = Math.max(s2, t3.w.globals.markers.largestSize / 1.5);
      }), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var a2 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
      i2.gridWidth = i2.gridWidth - 2 * a2, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (a2 > 0 ? a2 + 4 : 0), i2.translateY = i2.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
      e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map(function(t4, i3) {
        e2.globals.yLabelsCoords.push({ width: a2[i3].width, index: i3 }), e2.globals.yTitleCoords.push({ width: s2[i3].width, index: i3 });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var r2 = this.dimXAxis.getxAxisLabelsCoords(), o2 = this.dimXAxis.getxAxisGroupLabelsCoords(), n2 = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(r2, n2, o2), i2.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e2.globals.rotateXLabels && e2.globals.isXNumeric && e2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal && (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e2.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e2.config.xaxis.labels.offsetX;
      var l2 = this.yAxisWidth, h3 = this.xAxisHeight;
      i2.xAxisLabelsHeight = this.xAxisHeight - n2.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
      var c2 = 10;
      (e2.config.chart.type === "radar" || this.isSparkline) && (l2 = 0, h3 = i2.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || e2.config.chart.type === "treemap") && (l2 = 0, h3 = 0, c2 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r2);
      var d2 = function() {
        i2.translateX = l2, i2.gridHeight = i2.svgHeight - t3.lgRect.height - h3 - (t3.isSparkline || e2.config.chart.type === "treemap" ? 0 : e2.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l2;
      };
      switch (e2.config.xaxis.position === "top" && (c2 = i2.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
        case "bottom":
          i2.translateY = c2, d2();
          break;
        case "top":
          i2.translateY = this.lgRect.height + c2, d2();
          break;
        case "left":
          i2.translateY = c2, i2.translateX = this.lgRect.width + l2, i2.gridHeight = i2.svgHeight - h3 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2;
          break;
        case "right":
          i2.translateY = c2, i2.translateX = l2, i2.gridHeight = i2.svgHeight - h3 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(s2, a2), new $(this.ctx).setYAxisXPosition(a2, s2);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = 0;
      t3.config.legend.show && !t3.config.legend.floating && (a2 = 20);
      var s2 = i2.chart.type === "pie" || i2.chart.type === "polarArea" || i2.chart.type === "donut" ? "pie" : "radialBar", r2 = i2.plotOptions[s2].offsetY, o2 = i2.plotOptions[s2].offsetX;
      if (!i2.legend.show || i2.legend.floating)
        return e2.gridHeight = e2.svgHeight - i2.grid.padding.left + i2.grid.padding.right, e2.gridWidth = e2.gridHeight, e2.translateY = r2, void (e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2);
      switch (i2.legend.position) {
        case "bottom":
          e2.gridHeight = e2.svgHeight - this.lgRect.height - e2.goldenPadding, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2;
          break;
        case "top":
          e2.gridHeight = e2.svgHeight - this.lgRect.height - e2.goldenPadding, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2;
          break;
        case "left":
          e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = i2.chart.height !== "auto" ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = o2 + this.lgRect.width + a2;
          break;
        case "right":
          e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = i2.chart.height !== "auto" ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = o2 + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = a2.globals.hasGroups ? 2 : 1, r2 = i2.height + t3.height + e2.height, o2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, n2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels && a2.config.legend.position === "bottom" ? 10 : 0;
      this.xAxisHeight = r2 * o2 + s2 * n2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
      var h3 = 0, c2 = 0;
      a2.config.yaxis.forEach(function(t4) {
        h3 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
      }), this.yAxisWidth < h3 && (this.yAxisWidth = h3), this.yAxisWidth > c2 && (this.yAxisWidth = c2);
    } }]), t2;
  }(), ht = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.lgCtx = e2;
    }
    return r(t2, [{ key: "getLegendStyles", value: function() {
      var t3 = document.createElement("style");
      t3.setAttribute("type", "text/css");
      var e2 = document.createTextNode("	\n    	\n      .apexcharts-legend {	\n        display: flex;	\n        overflow: auto;	\n        padding: 0 10px;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {	\n        flex-wrap: wrap	\n      }	\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	\n        flex-direction: column;	\n        bottom: 0;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	\n        justify-content: flex-start;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {	\n        justify-content: center;  	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {	\n        justify-content: flex-end;	\n      }	\n      .apexcharts-legend-series {	\n        cursor: pointer;	\n        line-height: normal;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{	\n        display: flex;	\n        align-items: center;	\n      }	\n      .apexcharts-legend-text {	\n        position: relative;	\n        font-size: 14px;	\n      }	\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {	\n        pointer-events: none;	\n      }	\n      .apexcharts-legend-marker {	\n        position: relative;	\n        display: inline-block;	\n        cursor: pointer;	\n        margin-right: 3px;	\n        border-style: solid;\n      }	\n      	\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{	\n        display: inline-block;	\n      }	\n      .apexcharts-legend-series.apexcharts-no-click {	\n        cursor: auto;	\n      }	\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {	\n        display: none !important;	\n      }	\n      .apexcharts-inactive-legend {	\n        opacity: 0.45;	\n      }");
      return t3.appendChild(e2), t3;
    } }, { key: "getLegendBBox", value: function() {
      var t3 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e2 = t3.width;
      return { clwh: t3.height, clww: e2 };
    } }, { key: "appendToForeignObject", value: function() {
      var t3 = this.w.globals;
      t3.dom.elLegendForeign = document.createElementNS(t3.SVGNS, "foreignObject");
      var e2 = t3.dom.elLegendForeign;
      e2.setAttribute("x", 0), e2.setAttribute("y", 0), e2.setAttribute("width", t3.svgWidth), e2.setAttribute("height", t3.svgHeight), t3.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e2.appendChild(t3.dom.elLegendWrap), e2.appendChild(this.getLegendStyles()), t3.dom.Paper.node.insertBefore(e2, t3.dom.elGraphical.node);
    } }, { key: "toggleDataSeries", value: function(t3, e2) {
      var i2 = this, a2 = this.w;
      if (a2.globals.axisCharts || a2.config.chart.type === "radialBar") {
        a2.globals.resized = true;
        var s2 = null, r2 = null;
        if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t3, "']")), r2 = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t3 + 1, "']")), r2 = parseInt(s2.getAttribute("rel"), 10) - 1), e2)
          [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t4) {
            i2.riseCollapsedSeries(t4.cs, t4.csi, r2);
          });
        else
          this.hideSeries({ seriesEl: s2, realIndex: r2 });
      } else {
        var o2 = a2.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t3 + 1, "'] path")), n2 = a2.config.chart.type;
        if (n2 === "pie" || n2 === "polarArea" || n2 === "donut") {
          var l2 = a2.config.plotOptions.pie.donut.labels;
          new m(this.lgCtx.ctx).pathMouseDown(o2.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o2.members[0].node, l2);
        }
        o2.fire("click");
      }
    } }, { key: "hideSeries", value: function(t3) {
      var e2 = t3.seriesEl, i2 = t3.realIndex, a2 = this.w, s2 = x.clone(a2.config.series);
      if (a2.globals.axisCharts) {
        var r2 = false;
        if (a2.config.yaxis[i2] && a2.config.yaxis[i2].show && a2.config.yaxis[i2].showAlways && (r2 = true, a2.globals.ancillaryCollapsedSeriesIndices.indexOf(i2) < 0 && (a2.globals.ancillaryCollapsedSeries.push({ index: i2, data: s2[i2].data.slice(), type: e2.parentNode.className.baseVal.split("-")[1] }), a2.globals.ancillaryCollapsedSeriesIndices.push(i2))), !r2) {
          a2.globals.collapsedSeries.push({ index: i2, data: s2[i2].data.slice(), type: e2.parentNode.className.baseVal.split("-")[1] }), a2.globals.collapsedSeriesIndices.push(i2);
          var o2 = a2.globals.risingSeries.indexOf(i2);
          a2.globals.risingSeries.splice(o2, 1);
        }
      } else
        a2.globals.collapsedSeries.push({ index: i2, data: s2[i2] }), a2.globals.collapsedSeriesIndices.push(i2);
      for (var n2 = e2.childNodes, l2 = 0; l2 < n2.length; l2++)
        n2[l2].classList.contains("apexcharts-series-markers-wrap") && (n2[l2].classList.contains("apexcharts-hide") ? n2[l2].classList.remove("apexcharts-hide") : n2[l2].classList.add("apexcharts-hide"));
      a2.globals.allSeriesCollapsed = a2.globals.collapsedSeries.length === a2.config.series.length, s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = x.clone(a2.config.series);
      if (t3.length > 0) {
        for (var r2 = 0; r2 < t3.length; r2++)
          t3[r2].index === i2 && (a2.globals.axisCharts ? (s2[i2].data = t3[r2].data.slice(), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2)) : (s2[i2] = t3[r2].data, t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2)));
        s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t3) {
      var e2 = this.w;
      return e2.globals.axisCharts ? t3.forEach(function(i2, a2) {
        e2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (t3[a2].data = []);
      }) : t3.forEach(function(i2, a2) {
        e2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (t3[a2] = 0);
      }), t3;
    } }]), t2;
  }(), ct = function() {
    function t2(e2, i2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new ht(this);
    }
    return r(t2, [{ key: "init", value: function() {
      var t3 = this.w, e2 = t3.globals, i2 = t3.config;
      if ((i2.legend.showForSingleSeries && e2.series.length === 1 || this.isBarsDistributed || e2.series.length > 1 || !e2.axisCharts) && i2.legend.show) {
        for (; e2.dom.elLegendWrap.firstChild; )
          e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
        this.drawLegends(), x.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i2.legend.position === "bottom" || i2.legend.position === "top" ? this.legendAlignHorizontal() : i2.legend.position !== "right" && i2.legend.position !== "left" || this.legendAlignVertical();
      }
    } }, { key: "drawLegends", value: function() {
      var t3 = this, e2 = this.w, i2 = e2.config.legend.fontFamily, a2 = e2.globals.seriesNames, s2 = e2.globals.colors.slice();
      if (e2.config.chart.type === "heatmap") {
        var r2 = e2.config.plotOptions.heatmap.colorScale.ranges;
        a2 = r2.map(function(t4) {
          return t4.name ? t4.name : t4.from + " - " + t4.to;
        }), s2 = r2.map(function(t4) {
          return t4.color;
        });
      } else
        this.isBarsDistributed && (a2 = e2.globals.labels.slice());
      e2.config.legend.customLegendItems.length && (a2 = e2.config.legend.customLegendItems);
      for (var o2 = e2.globals.legendFormatter, n2 = e2.config.legend.inverseOrder, l2 = n2 ? a2.length - 1 : 0; n2 ? l2 >= 0 : l2 <= a2.length - 1; n2 ? l2-- : l2++) {
        var h3 = o2(a2[l2], { seriesIndex: l2, w: e2 }), c2 = false, d2 = false;
        if (e2.globals.collapsedSeries.length > 0)
          for (var g2 = 0; g2 < e2.globals.collapsedSeries.length; g2++)
            e2.globals.collapsedSeries[g2].index === l2 && (c2 = true);
        if (e2.globals.ancillaryCollapsedSeriesIndices.length > 0)
          for (var u2 = 0; u2 < e2.globals.ancillaryCollapsedSeriesIndices.length; u2++)
            e2.globals.ancillaryCollapsedSeriesIndices[u2] === l2 && (d2 = true);
        var p3 = document.createElement("span");
        p3.classList.add("apexcharts-legend-marker");
        var f2 = e2.config.legend.markers.offsetX, b2 = e2.config.legend.markers.offsetY, v2 = e2.config.legend.markers.height, w2 = e2.config.legend.markers.width, k2 = e2.config.legend.markers.strokeWidth, A2 = e2.config.legend.markers.strokeColor, S2 = e2.config.legend.markers.radius, C2 = p3.style;
        C2.background = s2[l2], C2.color = s2[l2], C2.setProperty("background", s2[l2], "important"), e2.config.legend.markers.fillColors && e2.config.legend.markers.fillColors[l2] && (C2.background = e2.config.legend.markers.fillColors[l2]), e2.globals.seriesColors[l2] !== void 0 && (C2.background = e2.globals.seriesColors[l2], C2.color = e2.globals.seriesColors[l2]), C2.height = Array.isArray(v2) ? parseFloat(v2[l2]) + "px" : parseFloat(v2) + "px", C2.width = Array.isArray(w2) ? parseFloat(w2[l2]) + "px" : parseFloat(w2) + "px", C2.left = (Array.isArray(f2) ? parseFloat(f2[l2]) : parseFloat(f2)) + "px", C2.top = (Array.isArray(b2) ? parseFloat(b2[l2]) : parseFloat(b2)) + "px", C2.borderWidth = Array.isArray(k2) ? k2[l2] : k2, C2.borderColor = Array.isArray(A2) ? A2[l2] : A2, C2.borderRadius = Array.isArray(S2) ? parseFloat(S2[l2]) + "px" : parseFloat(S2) + "px", e2.config.legend.markers.customHTML && (Array.isArray(e2.config.legend.markers.customHTML) ? e2.config.legend.markers.customHTML[l2] && (p3.innerHTML = e2.config.legend.markers.customHTML[l2]()) : p3.innerHTML = e2.config.legend.markers.customHTML()), m.setAttrs(p3, { rel: l2 + 1, "data:collapsed": c2 || d2 }), (c2 || d2) && p3.classList.add("apexcharts-inactive-legend");
        var L2 = document.createElement("div"), P2 = document.createElement("span");
        P2.classList.add("apexcharts-legend-text"), P2.innerHTML = Array.isArray(h3) ? h3.join(" ") : h3;
        var T2 = e2.config.legend.labels.useSeriesColors ? e2.globals.colors[l2] : e2.config.legend.labels.colors;
        T2 || (T2 = e2.config.chart.foreColor), P2.style.color = T2, P2.style.fontSize = parseFloat(e2.config.legend.fontSize) + "px", P2.style.fontWeight = e2.config.legend.fontWeight, P2.style.fontFamily = i2 || e2.config.chart.fontFamily, m.setAttrs(P2, { rel: l2 + 1, i: l2, "data:default-text": encodeURIComponent(h3), "data:collapsed": c2 || d2 }), L2.appendChild(p3), L2.appendChild(P2);
        var M2 = new y(this.ctx);
        if (!e2.config.legend.showForZeroSeries)
          M2.getSeriesTotalByIndex(l2) === 0 && M2.seriesHaveSameValues(l2) && !M2.isSeriesNull(l2) && e2.globals.collapsedSeriesIndices.indexOf(l2) === -1 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(l2) === -1 && L2.classList.add("apexcharts-hidden-zero-series");
        e2.config.legend.showForNullSeries || M2.isSeriesNull(l2) && e2.globals.collapsedSeriesIndices.indexOf(l2) === -1 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(l2) === -1 && L2.classList.add("apexcharts-hidden-null-series"), e2.globals.dom.elLegendWrap.appendChild(L2), e2.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e2.config.legend.horizontalAlign)), e2.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e2.config.legend.position), L2.classList.add("apexcharts-legend-series"), L2.style.margin = "".concat(e2.config.legend.itemMargin.vertical, "px ").concat(e2.config.legend.itemMargin.horizontal, "px"), e2.globals.dom.elLegendWrap.style.width = e2.config.legend.width ? e2.config.legend.width + "px" : "", e2.globals.dom.elLegendWrap.style.height = e2.config.legend.height ? e2.config.legend.height + "px" : "", m.setAttrs(L2, { rel: l2 + 1, seriesName: x.escapeString(a2[l2]), "data:collapsed": c2 || d2 }), (c2 || d2) && L2.classList.add("apexcharts-inactive-legend"), e2.config.legend.onItemClick.toggleDataSeries || L2.classList.add("apexcharts-no-click");
      }
      e2.globals.dom.elWrap.addEventListener("click", t3.onLegendClick, true), e2.config.legend.onItemHover.highlightDataSeries && e2.config.legend.customLegendItems.length === 0 && (e2.globals.dom.elWrap.addEventListener("mousemove", t3.onLegendHovered, true), e2.globals.dom.elWrap.addEventListener("mouseout", t3.onLegendHovered, true));
    } }, { key: "setLegendWrapXY", value: function(t3, e2) {
      var i2 = this.w, a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-legend"), s2 = a2.getBoundingClientRect(), r2 = 0, o2 = 0;
      if (i2.config.legend.position === "bottom")
        o2 += i2.globals.svgHeight - s2.height / 2;
      else if (i2.config.legend.position === "top") {
        var n2 = new lt(this.ctx), l2 = n2.dimHelpers.getTitleSubtitleCoords("title").height, h3 = n2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        o2 = o2 + (l2 > 0 ? l2 - 10 : 0) + (h3 > 0 ? h3 - 10 : 0);
      }
      a2.style.position = "absolute", r2 = r2 + t3 + i2.config.legend.offsetX, o2 = o2 + e2 + i2.config.legend.offsetY, a2.style.left = r2 + "px", a2.style.top = o2 + "px", i2.config.legend.position === "bottom" ? (a2.style.top = "auto", a2.style.bottom = 5 - i2.config.legend.offsetY + "px") : i2.config.legend.position === "right" && (a2.style.left = "auto", a2.style.right = 25 + i2.config.legend.offsetX + "px");
      ["width", "height"].forEach(function(t4) {
        a2.style[t4] && (a2.style[t4] = parseInt(i2.config.legend[t4], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var t3 = this.w;
      t3.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
      var e2 = this.legendHelpers.getLegendBBox(), i2 = new lt(this.ctx), a2 = i2.dimHelpers.getTitleSubtitleCoords("title"), s2 = i2.dimHelpers.getTitleSubtitleCoords("subtitle"), r2 = 0;
      t3.config.legend.position === "bottom" ? r2 = -e2.clwh / 1.8 : t3.config.legend.position === "top" && (r2 = a2.height + s2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, r2);
    } }, { key: "legendAlignVertical", value: function() {
      var t3 = this.w, e2 = this.legendHelpers.getLegendBBox(), i2 = 0;
      t3.config.legend.position === "left" && (i2 = 20), t3.config.legend.position === "right" && (i2 = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i2, 20);
    } }, { key: "onLegendHovered", value: function(t3) {
      var e2 = this.w, i2 = t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker");
      if (e2.config.chart.type === "heatmap" || this.isBarsDistributed) {
        if (i2) {
          var a2 = parseInt(t3.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new E(this.ctx).highlightRangeInSeries(t3, t3.target);
        }
      } else
        !t3.target.classList.contains("apexcharts-inactive-legend") && i2 && new E(this.ctx).toggleSeriesOnHover(t3, t3.target);
    } }, { key: "onLegendClick", value: function(t3) {
      var e2 = this.w;
      if (!e2.config.legend.customLegendItems.length && (t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker"))) {
        var i2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, a2 = t3.target.getAttribute("data:collapsed") === "true", s2 = this.w.config.chart.events.legendClick;
        typeof s2 == "function" && s2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i2, this.w]);
        var r2 = this.w.config.legend.markers.onClick;
        typeof r2 == "function" && t3.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i2, this.w])), e2.config.chart.type !== "treemap" && e2.config.chart.type !== "heatmap" && !this.isBarsDistributed && e2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i2, a2);
      }
    } }]), t2;
  }(), dt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var i2 = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i2.globals.minX, this.maxX = i2.globals.maxX;
    }
    return r(t2, [{ key: "createToolbar", value: function() {
      var t3 = this, e2 = this.w, i2 = function() {
        return document.createElement("div");
      }, a2 = i2();
      if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = e2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - e2.config.chart.toolbar.offsetX + "px", e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
        for (var s2 = 0; s2 < this.t.customIcons.length; s2++)
          this.elCustomIcons.push(i2());
      var r2 = [], o2 = function(i3, a3, s3) {
        var o3 = i3.toLowerCase();
        t3.t[o3] && e2.config.chart.zoom.enabled && r2.push({ el: a3, icon: typeof t3.t[o3] == "string" ? t3.t[o3] : s3, title: t3.localeValues[i3], class: "apexcharts-".concat(o3, "-icon") });
      };
      o2("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o2("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
      var n2 = function(i3) {
        t3.t[i3] && e2.config.chart[i3].enabled && r2.push({ el: i3 === "zoom" ? t3.elZoom : t3.elSelection, icon: typeof t3.t[i3] == "string" ? t3.t[i3] : i3 === "zoom" ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t3.localeValues[i3 === "zoom" ? "selectionZoom" : "selection"], class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i3, "-icon") });
      };
      n2("zoom"), n2("selection"), this.t.pan && e2.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o2("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var l2 = 0; l2 < this.elCustomIcons.length; l2++)
        r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l2].class });
      r2.forEach(function(t4, e3) {
        t4.index && x.moveIndexInArray(r2, e3, t4.index);
      });
      for (var h3 = 0; h3 < r2.length; h3++)
        m.setAttrs(r2[h3].el, { class: r2[h3].class, title: r2[h3].title }), r2[h3].el.innerHTML = r2[h3].icon, a2.appendChild(r2[h3].el);
      this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(t3) {
      this.elMenuItems = [], t3.appendChild(this.elMenu), m.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      var e2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }];
      this.w.globals.allSeriesHasEqualX || e2.splice(2, 1);
      for (var i2 = 0; i2 < e2.length; i2++)
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i2].innerHTML = e2[i2].title, m.setAttrs(this.elMenuItems[i2], { class: "apexcharts-menu-item ".concat(e2[i2].name), title: e2[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var t3 = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e3) {
        e3.classList.contains("exportSVG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "svg")) : e3.classList.contains("exportPNG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "png")) : e3.classList.contains("exportCSV") && e3.addEventListener("click", t3.handleDownload.bind(t3, "csv"));
      });
      for (var e2 = 0; e2 < this.t.customIcons.length; e2++)
        this.elCustomIcons[e2].addEventListener("click", this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(t3) {
      this.ctx.getSyncedCharts().forEach(function(e2) {
        e2.ctx.toolbar.toggleOtherControls();
        var i2 = t3 === "selection" ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = t3 === "selection" ? "selectionEnabled" : "zoomEnabled";
        e2.w.globals[a2] = !e2.w.globals[a2], i2.classList.contains(e2.ctx.toolbar.selectedClass) ? i2.classList.remove(e2.ctx.toolbar.selectedClass) : i2.classList.add(e2.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var t3 = this.w;
      this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(t3) {
      this.toggleOtherControls(), t3 === "pan" ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
      var e2 = t3 === "pan" ? this.elPan : this.elZoom, i2 = t3 === "pan" ? this.elZoom : this.elPan;
      e2 && e2.classList.add(this.selectedClass), i2 && i2.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(t3) {
        t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var t3 = this, e2 = this.w;
      e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e3) {
        e3 && e3.classList.remove(t3.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var t3 = this.w;
      t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
      var e2 = (this.minX + this.maxX) / 2, i2 = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i2, a2);
      t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var t3 = this.w;
      if (t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !(t3.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var e2 = (this.minX + this.maxX) / 2, i2 = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i2, a2);
        t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(t3, e2) {
      var i2 = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: i2 ? Math.floor(t3) : t3, maxX: i2 ? Math.floor(e2) : e2 };
    } }, { key: "zoomUpdateOptions", value: function(t3, e2) {
      var i2 = this.w;
      if (t3 !== void 0 || e2 !== void 0) {
        if (!(i2.config.xaxis.convertedCatToNumeric && (t3 < 1 && (t3 = 1, e2 = i2.globals.dataPoints), e2 - t3 < 2))) {
          var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
          s2 && (a2 = s2.xaxis);
          var r2 = { xaxis: a2 }, o2 = x.clone(i2.globals.initialConfig.yaxis);
          if (i2.config.chart.zoom.autoScaleYaxis)
            o2 = new q(this.ctx).autoScaleY(this.ctx, o2, { xaxis: a2 });
          i2.config.chart.group || (r2.yaxis = o2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, o2);
        }
      } else
        this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(t3, e2) {
      typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 });
    } }, { key: "getBeforeZoomRange", value: function(t3, e2) {
      var i2 = null;
      return typeof this.ev.beforeZoom == "function" && (i2 = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i2;
    } }, { key: "toggleMenu", value: function() {
      var t3 = this;
      window.setTimeout(function() {
        t3.elMenu.classList.contains("apexcharts-menu-open") ? t3.elMenu.classList.remove("apexcharts-menu-open") : t3.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(t3) {
      var e2 = this.w, i2 = new j(this.ctx);
      switch (t3) {
        case "svg":
          i2.exportToSVG(this.ctx);
          break;
        case "png":
          i2.exportToPng(this.ctx);
          break;
        case "csv":
          i2.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(t3) {
      this.ctx.getSyncedCharts().forEach(function(t4) {
        var e2 = t4.w;
        if (e2.globals.lastXAxis.min = void 0, e2.globals.lastXAxis.max = void 0, t4.updateHelpers.revertDefaultAxisMinMax(), typeof e2.config.chart.events.beforeResetZoom == "function") {
          var i2 = e2.config.chart.events.beforeResetZoom(t4, e2);
          i2 && t4.updateHelpers.revertDefaultAxisMinMax(i2);
        }
        typeof e2.config.chart.events.zoomed == "function" && t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
        var a2 = t4.ctx.series.emptyCollapsedSeries(x.clone(e2.globals.initialSeries));
        t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), t2;
  }(), gt = function(t2) {
    n(i2, dt);
    var e2 = d(i2);
    function i2(t3) {
      var s2;
      return a(this, i2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new m(s2.ctx), s2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = "none", s2;
    }
    return r(i2, [{ key: "init", value: function(t3) {
      var e3 = this, i3 = t3.xyRatios, a2 = this.w, s2 = this;
      this.xyRatios = i3, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a2.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a2.globals.dom.elGraphical.add(this.zoomRect), a2.globals.dom.elGraphical.add(this.selectionRect), a2.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a2.globals.gridWidth, maxY: a2.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : a2.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a2.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a2.globals.dom.baseEl.querySelector("".concat(a2.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t4) {
        e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i3), { capture: false, passive: true });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(t3, e3) {
      var i3 = this.w, a2 = this, s2 = this.ctx.toolbar, r2 = i3.globals.zoomEnabled ? i3.config.chart.zoom.type : i3.config.chart.selection.type, o2 = i3.config.chart.toolbar.autoSelected;
      if (e3.shiftKey ? (this.shiftWasPressed = true, s2.enableZoomPanFromToolbar(o2 === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (s2.enableZoomPanFromToolbar(o2), this.shiftWasPressed = false), e3.target) {
        var n2, l2 = e3.target.classList;
        if (e3.target.parentNode && e3.target.parentNode !== null && (n2 = e3.target.parentNode.classList), !(l2.contains("apexcharts-selection-rect") || l2.contains("apexcharts-legend-marker") || l2.contains("apexcharts-legend-text") || n2 && n2.contains("apexcharts-toolbar"))) {
          if (a2.clientX = e3.type === "touchmove" || e3.type === "touchstart" ? e3.touches[0].clientX : e3.type === "touchend" ? e3.changedTouches[0].clientX : e3.clientX, a2.clientY = e3.type === "touchmove" || e3.type === "touchstart" ? e3.touches[0].clientY : e3.type === "touchend" ? e3.changedTouches[0].clientY : e3.clientY, e3.type === "mousedown" && e3.which === 1) {
            var h3 = a2.gridRect.getBoundingClientRect();
            a2.startX = a2.clientX - h3.left, a2.startY = a2.clientY - h3.top, a2.dragged = false, a2.w.globals.mousedown = true;
          }
          if ((e3.type === "mousemove" && e3.which === 1 || e3.type === "touchmove") && (a2.dragged = true, i3.globals.panEnabled ? (i3.globals.selection = null, a2.w.globals.mousedown && a2.panDragging({ context: a2, zoomtype: r2, xyRatios: t3 })) : (a2.w.globals.mousedown && i3.globals.zoomEnabled || a2.w.globals.mousedown && i3.globals.selectionEnabled) && (a2.selection = a2.selectionDrawing({ context: a2, zoomtype: r2 }))), e3.type === "mouseup" || e3.type === "touchend" || e3.type === "mouseleave") {
            var c2 = a2.gridRect.getBoundingClientRect();
            a2.w.globals.mousedown && (a2.endX = a2.clientX - c2.left, a2.endY = a2.clientY - c2.top, a2.dragX = Math.abs(a2.endX - a2.startX), a2.dragY = Math.abs(a2.endY - a2.startY), (i3.globals.zoomEnabled || i3.globals.selectionEnabled) && a2.selectionDrawn({ context: a2, zoomtype: r2 }), i3.globals.panEnabled && i3.config.xaxis.convertedCatToNumeric && a2.delayedPanScrolled()), i3.globals.zoomEnabled && a2.hideSelectionRect(this.selectionRect), a2.dragged = false, a2.w.globals.mousedown = false;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var t3 = this.w;
      if (this.selectionRect) {
        var e3 = this.selectionRect.node.getBoundingClientRect();
        e3.width > 0 && e3.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: t3.globals.gridWidth, maxY: t3.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var t3 = this.w, e3 = this.xyRatios;
      if (!t3.globals.zoomEnabled) {
        if (t3.globals.selection !== void 0 && t3.globals.selection !== null)
          this.drawSelectionRect(t3.globals.selection);
        else if (t3.config.chart.selection.xaxis.min !== void 0 && t3.config.chart.selection.xaxis.max !== void 0) {
          var i3 = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a2 = { x: i3, y: 0, width: t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i3, height: t3.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
          this.drawSelectionRect(a2), this.makeSelectionRectDraggable(), typeof t3.config.chart.events.selection == "function" && t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(t3) {
      var e3 = t3.x, i3 = t3.y, a2 = t3.width, s2 = t3.height, r2 = t3.translateX, o2 = r2 === void 0 ? 0 : r2, n2 = t3.translateY, l2 = n2 === void 0 ? 0 : n2, h3 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
      if (this.dragged || h3.globals.selection !== null) {
        var g2 = { transform: "translate(" + o2 + ", " + l2 + ")" };
        h3.globals.zoomEnabled && this.dragged && (a2 < 0 && (a2 = 1), c2.attr({ x: e3, y: i3, width: a2, height: s2, fill: h3.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h3.config.chart.zoom.zoomedArea.fill.opacity, stroke: h3.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h3.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h3.config.chart.zoom.zoomedArea.stroke.opacity }), m.setAttrs(c2.node, g2)), h3.globals.selectionEnabled && (d2.attr({ x: e3, y: i3, width: a2 > 0 ? a2 : 0, height: s2 > 0 ? s2 : 0, fill: h3.config.chart.selection.fill.color, "fill-opacity": h3.config.chart.selection.fill.opacity, stroke: h3.config.chart.selection.stroke.color, "stroke-width": h3.config.chart.selection.stroke.width, "stroke-dasharray": h3.config.chart.selection.stroke.dashArray, "stroke-opacity": h3.config.chart.selection.stroke.opacity }), m.setAttrs(d2.node, g2));
      }
    } }, { key: "hideSelectionRect", value: function(t3) {
      t3 && t3.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(t3) {
      var e3 = t3.context, i3 = t3.zoomtype, a2 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), o2 = s2.startX - 1, n2 = s2.startY, l2 = false, h3 = false, c2 = s2.clientX - r2.left - o2, d2 = s2.clientY - r2.top - n2, g2 = {};
      return Math.abs(c2 + o2) > a2.globals.gridWidth ? c2 = a2.globals.gridWidth - o2 : s2.clientX - r2.left < 0 && (c2 = o2), o2 > s2.clientX - r2.left && (l2 = true, c2 = Math.abs(c2)), n2 > s2.clientY - r2.top && (h3 = true, d2 = Math.abs(d2)), g2 = i3 === "x" ? { x: l2 ? o2 - c2 : o2, y: 0, width: c2, height: a2.globals.gridHeight } : i3 === "y" ? { x: 0, y: h3 ? n2 - d2 : n2, width: a2.globals.gridWidth, height: d2 } : { x: l2 ? o2 - c2 : o2, y: h3 ? n2 - d2 : n2, width: c2, height: d2 }, s2.drawSelectionRect(g2), s2.selectionDragging("resizing"), g2;
    } }, { key: "selectionDragging", value: function(t3, e3) {
      var i3 = this, a2 = this.w, s2 = this.xyRatios, r2 = this.selectionRect, o2 = 0;
      t3 === "resizing" && (o2 = 30);
      var n2 = function(t4) {
        return parseFloat(r2.node.getAttribute(t4));
      }, l2 = { x: n2("x"), y: n2("y"), width: n2("width"), height: n2("height") };
      a2.globals.selection = l2, typeof a2.config.chart.events.selection == "function" && a2.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var t4 = i3.gridRect.getBoundingClientRect(), e4 = r2.node.getBoundingClientRect(), o3 = { xaxis: { min: a2.globals.xAxisScale.niceMin + (e4.left - t4.left) * s2.xRatio, max: a2.globals.xAxisScale.niceMin + (e4.right - t4.left) * s2.xRatio }, yaxis: { min: a2.globals.yAxisScale[0].niceMin + (t4.bottom - e4.bottom) * s2.yRatio[0], max: a2.globals.yAxisScale[0].niceMax - (e4.top - t4.top) * s2.yRatio[0] } };
        a2.config.chart.events.selection(i3.ctx, o3), a2.config.chart.brush.enabled && a2.config.chart.events.brushScrolled !== void 0 && a2.config.chart.events.brushScrolled(i3.ctx, o3);
      }, o2));
    } }, { key: "selectionDrawn", value: function(t3) {
      var e3 = t3.context, i3 = t3.zoomtype, a2 = this.w, s2 = e3, r2 = this.xyRatios, o2 = this.ctx.toolbar;
      if (s2.startX > s2.endX) {
        var n2 = s2.startX;
        s2.startX = s2.endX, s2.endX = n2;
      }
      if (s2.startY > s2.endY) {
        var l2 = s2.startY;
        s2.startY = s2.endY, s2.endY = l2;
      }
      var h3 = void 0, c2 = void 0;
      a2.globals.isRangeBar ? (h3 = a2.globals.yAxisScale[0].niceMin + s2.startX * r2.invertedYRatio, c2 = a2.globals.yAxisScale[0].niceMin + s2.endX * r2.invertedYRatio) : (h3 = a2.globals.xAxisScale.niceMin + s2.startX * r2.xRatio, c2 = a2.globals.xAxisScale.niceMin + s2.endX * r2.xRatio);
      var d2 = [], g2 = [];
      if (a2.config.yaxis.forEach(function(t4, e4) {
        d2.push(a2.globals.yAxisScale[e4].niceMax - r2.yRatio[e4] * s2.startY), g2.push(a2.globals.yAxisScale[e4].niceMax - r2.yRatio[e4] * s2.endY);
      }), s2.dragged && (s2.dragX > 10 || s2.dragY > 10) && h3 !== c2) {
        if (a2.globals.zoomEnabled) {
          var u2 = x.clone(a2.globals.initialConfig.yaxis), p3 = x.clone(a2.globals.initialConfig.xaxis);
          if (a2.globals.zoomed = true, a2.config.xaxis.convertedCatToNumeric && (h3 = Math.floor(h3), c2 = Math.floor(c2), h3 < 1 && (h3 = 1, c2 = a2.globals.dataPoints), c2 - h3 < 2 && (c2 = h3 + 1)), i3 !== "xy" && i3 !== "x" || (p3 = { min: h3, max: c2 }), i3 !== "xy" && i3 !== "y" || u2.forEach(function(t4, e4) {
            u2[e4].min = g2[e4], u2[e4].max = d2[e4];
          }), a2.config.chart.zoom.autoScaleYaxis) {
            var f2 = new q(s2.ctx);
            u2 = f2.autoScaleY(s2.ctx, u2, { xaxis: p3 });
          }
          if (o2) {
            var b2 = o2.getBeforeZoomRange(p3, u2);
            b2 && (p3 = b2.xaxis ? b2.xaxis : p3, u2 = b2.yaxis ? b2.yaxis : u2);
          }
          var v2 = { xaxis: p3 };
          a2.config.chart.group || (v2.yaxis = u2), s2.ctx.updateHelpers._updateOptions(v2, false, s2.w.config.chart.animations.dynamicAnimation.enabled), typeof a2.config.chart.events.zoomed == "function" && o2.zoomCallback(p3, u2);
        } else if (a2.globals.selectionEnabled) {
          var m2, y2 = null;
          m2 = { min: h3, max: c2 }, i3 !== "xy" && i3 !== "y" || (y2 = x.clone(a2.config.yaxis)).forEach(function(t4, e4) {
            y2[e4].min = g2[e4], y2[e4].max = d2[e4];
          }), a2.globals.selection = s2.selection, typeof a2.config.chart.events.selection == "function" && a2.config.chart.events.selection(s2.ctx, { xaxis: m2, yaxis: y2 });
        }
      }
    } }, { key: "panDragging", value: function(t3) {
      var e3 = t3.context, i3 = this.w, a2 = e3;
      if (i3.globals.lastClientPosition.x !== void 0) {
        var s2 = i3.globals.lastClientPosition.x - a2.clientX, r2 = i3.globals.lastClientPosition.y - a2.clientY;
        Math.abs(s2) > Math.abs(r2) && s2 > 0 ? this.moveDirection = "left" : Math.abs(s2) > Math.abs(r2) && s2 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s2) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s2) && r2 < 0 && (this.moveDirection = "down");
      }
      i3.globals.lastClientPosition = { x: a2.clientX, y: a2.clientY };
      var o2 = i3.globals.isRangeBar ? i3.globals.minY : i3.globals.minX, n2 = i3.globals.isRangeBar ? i3.globals.maxY : i3.globals.maxX;
      i3.config.xaxis.convertedCatToNumeric || a2.panScrolled(o2, n2);
    } }, { key: "delayedPanScrolled", value: function() {
      var t3 = this.w, e3 = t3.globals.minX, i3 = t3.globals.maxX, a2 = (t3.globals.maxX - t3.globals.minX) / 2;
      this.moveDirection === "left" ? (e3 = t3.globals.minX + a2, i3 = t3.globals.maxX + a2) : this.moveDirection === "right" && (e3 = t3.globals.minX - a2, i3 = t3.globals.maxX - a2), e3 = Math.floor(e3), i3 = Math.floor(i3), this.updateScrolledChart({ xaxis: { min: e3, max: i3 } }, e3, i3);
    } }, { key: "panScrolled", value: function(t3, e3) {
      var i3 = this.w, a2 = this.xyRatios, s2 = x.clone(i3.globals.initialConfig.yaxis), r2 = a2.xRatio, o2 = i3.globals.minX, n2 = i3.globals.maxX;
      i3.globals.isRangeBar && (r2 = a2.invertedYRatio, o2 = i3.globals.minY, n2 = i3.globals.maxY), this.moveDirection === "left" ? (t3 = o2 + i3.globals.gridWidth / 15 * r2, e3 = n2 + i3.globals.gridWidth / 15 * r2) : this.moveDirection === "right" && (t3 = o2 - i3.globals.gridWidth / 15 * r2, e3 = n2 - i3.globals.gridWidth / 15 * r2), i3.globals.isRangeBar || (t3 < i3.globals.initialMinX || e3 > i3.globals.initialMaxX) && (t3 = o2, e3 = n2);
      var l2 = { min: t3, max: e3 };
      i3.config.chart.zoom.autoScaleYaxis && (s2 = new q(this.ctx).autoScaleY(this.ctx, s2, { xaxis: l2 }));
      var h3 = { xaxis: { min: t3, max: e3 } };
      i3.config.chart.group || (h3.yaxis = s2), this.updateScrolledChart(h3, t3, e3);
    } }, { key: "updateScrolledChart", value: function(t3, e3, i3) {
      var a2 = this.w;
      this.ctx.updateHelpers._updateOptions(t3, false, false), typeof a2.config.chart.events.scrolled == "function" && a2.config.chart.events.scrolled(this.ctx, { xaxis: { min: e3, max: i3 } });
    } }]), i2;
  }(), ut = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
    }
    return r(t2, [{ key: "getNearestValues", value: function(t3) {
      var e2 = t3.hoverArea, i2 = t3.elGrid, a2 = t3.clientX, s2 = t3.clientY, r2 = this.w, o2 = i2.getBoundingClientRect(), n2 = o2.width, l2 = o2.height, h3 = n2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
      !r2.globals.comboCharts && !d2 || r2.config.xaxis.convertedCatToNumeric || (h3 = n2 / r2.globals.dataPoints);
      var g2 = a2 - o2.left - r2.globals.barPadForNumericAxis, u2 = s2 - o2.top;
      g2 < 0 || u2 < 0 || g2 > n2 || u2 > l2 ? (e2.classList.remove("hovering-zoom"), e2.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e2.classList.remove("hovering-pan"), e2.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e2.classList.remove("hovering-zoom"), e2.classList.add("hovering-pan"));
      var p3 = Math.round(g2 / h3), f2 = Math.floor(u2 / c2);
      d2 && !r2.config.xaxis.convertedCatToNumeric && (p3 = Math.ceil(g2 / h3), p3 -= 1);
      var b2 = null, v2 = null, m2 = [], y2 = [];
      if (r2.globals.seriesXvalues.forEach(function(t4) {
        m2.push([t4[0] + 1e-6].concat(t4));
      }), r2.globals.seriesYvalues.forEach(function(t4) {
        y2.push([t4[0] + 1e-6].concat(t4));
      }), m2 = m2.map(function(t4) {
        return t4.filter(function(t5) {
          return x.isNumber(t5);
        });
      }), y2 = y2.map(function(t4) {
        return t4.filter(function(t5) {
          return x.isNumber(t5);
        });
      }), r2.globals.isXNumeric) {
        var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = g2 * (w2.width / n2), A2 = u2 * (w2.height / l2);
        b2 = (v2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p3 = v2.j, b2 !== null && (m2 = r2.globals.seriesXvalues[b2], p3 = (v2 = this.closestInArray(k2, m2)).index);
      }
      return r2.globals.capturedSeriesIndex = b2 === null ? -1 : b2, (!p3 || p3 < 1) && (p3 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p3, { capturedSeries: b2, j: r2.globals.isBarHorizontal ? f2 : p3, hoverX: g2, hoverY: u2 };
    } }, { key: "closestInMultiArray", value: function(t3, e2, i2, a2) {
      var s2 = this.w, r2 = 0, o2 = null, n2 = -1;
      s2.globals.series.length > 1 ? r2 = this.getFirstActiveXArray(i2) : o2 = 0;
      var l2 = i2[r2][0], h3 = Math.abs(t3 - l2);
      if (i2.forEach(function(e3) {
        e3.forEach(function(e4, i3) {
          var a3 = Math.abs(t3 - e4);
          a3 < h3 && (h3 = a3, n2 = i3);
        });
      }), n2 !== -1) {
        var c2 = a2[r2][n2], d2 = Math.abs(e2 - c2);
        o2 = r2, a2.forEach(function(t4, i3) {
          var a3 = Math.abs(e2 - t4[n2]);
          a3 < d2 && (d2 = a3, o2 = i3);
        });
      }
      return { index: o2, j: n2 };
    } }, { key: "getFirstActiveXArray", value: function(t3) {
      for (var e2 = this.w, i2 = 0, a2 = t3.map(function(t4, e3) {
        return t4.length > 0 ? e3 : -1;
      }), s2 = 0; s2 < a2.length; s2++)
        if (a2[s2] !== -1 && e2.globals.collapsedSeriesIndices.indexOf(s2) === -1 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) === -1) {
          i2 = a2[s2];
          break;
        }
      return i2;
    } }, { key: "closestInArray", value: function(t3, e2) {
      for (var i2 = e2[0], a2 = null, s2 = Math.abs(t3 - i2), r2 = 0; r2 < e2.length; r2++) {
        var o2 = Math.abs(t3 - e2[r2]);
        o2 < s2 && (s2 = o2, a2 = r2);
      }
      return { index: a2 };
    } }, { key: "isXoverlap", value: function(t3) {
      var e2 = [], i2 = this.w.globals.seriesX.filter(function(t4) {
        return t4[0] !== void 0;
      });
      if (i2.length > 0)
        for (var a2 = 0; a2 < i2.length - 1; a2++)
          i2[a2][t3] !== void 0 && i2[a2 + 1][t3] !== void 0 && i2[a2][t3] !== i2[a2 + 1][t3] && e2.push("unEqual");
      return e2.length === 0;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var t3 = true, e2 = this.w.globals.initialSeries, i2 = 0; i2 < e2.length - 1; i2++)
        if (e2[i2].data.length !== e2[i2 + 1].data.length) {
          t3 = false;
          break;
        }
      return t3;
    } }, { key: "getBarsHeight", value: function(t3) {
      return u(t3).reduce(function(t4, e2) {
        return t4 + e2.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers");
    } }, { key: "getAllMarkers", value: function() {
      var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t3 = u(t3)).sort(function(t4, e3) {
        return Number(e3.getAttribute("data:realIndex")) < Number(t4.getAttribute("data:realIndex")) ? 0 : -1;
      });
      var e2 = [];
      return t3.forEach(function(t4) {
        e2.push(t4.querySelector(".apexcharts-marker"));
      }), e2;
    } }, { key: "hasMarkers", value: function() {
      return this.getElMarkers().length > 0;
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(t3) {
      var e2 = this.w, i2 = e2.config.markers.hover.size;
      return i2 === void 0 && (i2 = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i2;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(t3) {
      var e2 = this.w, i2 = this.ttCtx;
      i2.allTooltipSeriesGroups.length === 0 && (i2.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var a2 = i2.allTooltipSeriesGroups, s2 = 0; s2 < a2.length; s2++)
        t3 === "enable" ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
    } }]), t2;
  }(), pt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new ut(e2);
    }
    return r(t2, [{ key: "drawSeriesTexts", value: function(t3) {
      var e2 = t3.shared, i2 = e2 === void 0 || e2, a2 = t3.ttItems, s2 = t3.i, r2 = s2 === void 0 ? 0 : s2, o2 = t3.j, n2 = o2 === void 0 ? null : o2, l2 = t3.y1, h3 = t3.y2, c2 = t3.e, d2 = this.w;
      d2.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: r2, j: n2, y1: l2, y2: h3, w: d2 }) : this.toggleActiveInactiveSeries(i2);
      var g2 = this.getValuesToPrint({ i: r2, j: n2 });
      this.printLabels({ i: r2, j: n2, values: g2, ttItems: a2, shared: i2, e: c2 });
      var u2 = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = u2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u2.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(t3) {
      var i2, a2 = this, s2 = t3.i, r2 = t3.j, o2 = t3.values, n2 = t3.ttItems, l2 = t3.shared, h3 = t3.e, c2 = this.w, d2 = [], g2 = function(t4) {
        return c2.globals.seriesGoals[t4] && c2.globals.seriesGoals[t4][r2] && Array.isArray(c2.globals.seriesGoals[t4][r2]);
      }, u2 = o2.xVal, p3 = o2.zVal, f2 = o2.xAxisTTVal, x2 = "", b2 = c2.globals.colors[s2];
      r2 !== null && c2.config.plotOptions.bar.distributed && (b2 = c2.globals.colors[r2]);
      for (var v2 = function(t4, o3) {
        var v3 = a2.getFormatters(s2);
        x2 = a2.getSeriesName({ fn: v3.yLbTitleFormatter, index: s2, seriesIndex: s2, j: r2 }), c2.config.chart.type === "treemap" && (x2 = v3.yLbTitleFormatter(String(c2.config.series[s2].data[r2].x), { series: c2.globals.series, seriesIndex: s2, dataPointIndex: r2, w: c2 }));
        var m3 = c2.config.tooltip.inverseOrder ? o3 : t4;
        if (c2.globals.axisCharts) {
          var y3 = function(t5) {
            return v3.yLbFormatter(c2.globals.series[t5][r2], { series: c2.globals.series, seriesIndex: t5, dataPointIndex: r2, w: c2 });
          };
          if (l2)
            v3 = a2.getFormatters(m3), x2 = a2.getSeriesName({ fn: v3.yLbTitleFormatter, index: m3, seriesIndex: s2, j: r2 }), b2 = c2.globals.colors[m3], i2 = y3(m3), g2(m3) && (d2 = c2.globals.seriesGoals[m3][r2].map(function(t5) {
              return { attrs: t5, val: v3.yLbFormatter(t5.value, { seriesIndex: m3, dataPointIndex: r2, w: c2 }) };
            }));
          else {
            var w2, k2 = h3 == null || (w2 = h3.target) === null || w2 === void 0 ? void 0 : w2.getAttribute("fill");
            k2 && (b2 = k2.indexOf("url") !== -1 ? document.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k2), i2 = y3(s2), g2(s2) && Array.isArray(c2.globals.seriesGoals[s2][r2]) && (d2 = c2.globals.seriesGoals[s2][r2].map(function(t5) {
              return { attrs: t5, val: v3.yLbFormatter(t5.value, { seriesIndex: s2, dataPointIndex: r2, w: c2 }) };
            }));
          }
        }
        r2 === null && (i2 = v3.yLbFormatter(c2.globals.series[s2], e(e({}, c2), {}, { seriesIndex: s2, dataPointIndex: s2 }))), a2.DOMHandling({ i: s2, t: m3, j: r2, ttItems: n2, values: { val: i2, goalVals: d2, xVal: u2, xAxisTTVal: f2, zVal: p3 }, seriesName: x2, shared: l2, pColor: b2 });
      }, m2 = 0, y2 = c2.globals.series.length - 1; m2 < c2.globals.series.length; m2++, y2--)
        v2(m2, y2);
    } }, { key: "getFormatters", value: function(t3) {
      var e2, i2 = this.w, a2 = i2.globals.yLabelFormatters[t3];
      return i2.globals.ttVal !== void 0 ? Array.isArray(i2.globals.ttVal) ? (a2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].formatter, e2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].title && i2.globals.ttVal[t3].title.formatter) : (a2 = i2.globals.ttVal.formatter, typeof i2.globals.ttVal.title.formatter == "function" && (e2 = i2.globals.ttVal.title.formatter)) : e2 = i2.config.tooltip.y.title.formatter, typeof a2 != "function" && (a2 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t4) {
        return t4;
      }), typeof e2 != "function" && (e2 = function(t4) {
        return t4;
      }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
    } }, { key: "getSeriesName", value: function(t3) {
      var e2 = t3.fn, i2 = t3.index, a2 = t3.seriesIndex, s2 = t3.j, r2 = this.w;
      return e2(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
    } }, { key: "DOMHandling", value: function(t3) {
      t3.i;
      var e2 = t3.t, i2 = t3.j, a2 = t3.ttItems, s2 = t3.values, r2 = t3.seriesName, o2 = t3.shared, n2 = t3.pColor, l2 = this.w, h3 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, g2 = s2.xVal, u2 = s2.xAxisTTVal, p3 = s2.zVal, f2 = null;
      f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor && (a2[e2].style.backgroundColor = n2, f2[0].style.display = "none"), h3.showTooltipTitle && (h3.tooltipTitle === null && (h3.tooltipTitle = l2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h3.tooltipTitle.innerHTML = g2), h3.isXAxisTooltipEnabled && (h3.xaxisTooltipText.innerHTML = u2 !== "" ? u2 : g2);
      var x2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-label");
      x2 && (x2.innerHTML = r2 || "");
      var b2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-value");
      b2 && (b2.innerHTML = c2 !== void 0 ? c2 : ""), f2[0] && f2[0].classList.contains("apexcharts-tooltip-marker") && (l2.config.tooltip.marker.fillColors && Array.isArray(l2.config.tooltip.marker.fillColors) && (n2 = l2.config.tooltip.marker.fillColors[e2]), f2[0].style.backgroundColor = n2), l2.config.tooltip.marker.show || (f2[0].style.display = "none");
      var v2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-label"), m2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-value");
      if (d2.length && l2.globals.seriesGoals[e2]) {
        var y2 = function() {
          var t4 = "<div >", e3 = "<div>";
          d2.forEach(function(i3, a3) {
            t4 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i3.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i3.attrs.name, "</div>"), e3 += "<div>".concat(i3.val, "</div>");
          }), v2.innerHTML = t4 + "</div>", m2.innerHTML = e3 + "</div>";
        };
        o2 ? l2.globals.seriesGoals[e2][i2] && Array.isArray(l2.globals.seriesGoals[e2][i2]) ? y2() : (v2.innerHTML = "", m2.innerHTML = "") : y2();
      } else
        v2.innerHTML = "", m2.innerHTML = "";
      p3 !== null && (a2[e2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = p3 !== void 0 ? p3 : "");
      o2 && f2[0] && (c2 == null || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) > -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) > -1 ? f2[0].parentNode.style.display = "none" : f2[0].parentNode.style.display = l2.config.tooltip.items.display);
    } }, { key: "toggleActiveInactiveSeries", value: function(t3) {
      var e2 = this.w;
      if (t3)
        this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var i2 = e2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        i2 && (i2.classList.add("apexcharts-active"), i2.style.display = e2.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(t3) {
      var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = "", o2 = "", n2 = null, l2 = null, h3 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i2, w: a2 }, c2 = a2.globals.ttZFormatter;
      i2 === null ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric && a2.config.chart.type !== "treemap" ? (r2 = s2[e2][i2], s2[e2].length === 0 && (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i2])) : r2 = a2.globals.labels[i2] !== void 0 ? a2.globals.labels[i2] : "";
      var d2 = r2;
      a2.globals.isXNumeric && a2.config.xaxis.type === "datetime" ? r2 = new V(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new R(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h3) : a2.globals.xLabelFormatter(d2, h3);
      return a2.config.tooltip.x.formatter !== void 0 && (r2 = a2.globals.ttKeyFormatter(d2, h3)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[e2].length > 0 && (n2 = c2(a2.globals.seriesZ[e2][i2], a2)), o2 = typeof a2.config.xaxis.tooltip.formatter == "function" ? a2.globals.xaxisTooltipFormatter(d2, h3) : r2, { val: Array.isArray(l2) ? l2.join(" ") : l2, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(o2) ? o2.join(" ") : o2, zVal: n2 };
    } }, { key: "handleCustomTooltip", value: function(t3) {
      var e2 = t3.i, i2 = t3.j, a2 = t3.y1, s2 = t3.y2, r2 = t3.w, o2 = this.ttCtx.getElTooltip(), n2 = r2.config.tooltip.custom;
      Array.isArray(n2) && n2[e2] && (n2 = n2[e2]), o2.innerHTML = n2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i2, y1: a2, y2: s2, w: r2 });
    } }]), t2;
  }(), ft = function() {
    function t2(e2) {
      a(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
    }
    return r(t2, [{ key: "moveXCrosshairs", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i2 = this.ttCtx, a2 = this.w, s2 = i2.getElXCrosshairs(), r2 = t3 - i2.xcrosshairsWidth / 2, o2 = a2.globals.labels.slice().length;
      if (e2 !== null && (r2 = a2.globals.gridWidth / o2 * e2), s2 === null || a2.globals.isBarHorizontal || (s2.setAttribute("x", r2), s2.setAttribute("x1", r2), s2.setAttribute("x2", r2), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a2.globals.gridWidth && (r2 = a2.globals.gridWidth), i2.isXAxisTooltipEnabled) {
        var n2 = r2;
        a2.config.xaxis.crosshairs.width !== "tickWidth" && a2.config.xaxis.crosshairs.width !== "barWidth" || (n2 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(n2);
      }
    } }, { key: "moveYCrosshairs", value: function(t3) {
      var e2 = this.ttCtx;
      e2.ycrosshairs !== null && m.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), e2.ycrosshairsHidden !== null && m.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
    } }, { key: "moveXAxisTooltip", value: function(t3) {
      var e2 = this.w, i2 = this.ttCtx;
      if (i2.xaxisTooltip !== null && i2.xcrosshairsWidth !== 0) {
        i2.xaxisTooltip.classList.add("apexcharts-active");
        var a2 = i2.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
        if (t3 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
          t3 += e2.globals.translateX;
          var s2;
          s2 = new m(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s2.width + "px", i2.xaxisTooltip.style.left = t3 + "px", i2.xaxisTooltip.style.top = a2 + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(t3) {
      var e2 = this.w, i2 = this.ttCtx;
      i2.yaxisTTEls === null && (i2.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var a2 = parseInt(i2.ycrosshairsHidden.getAttribute("y1"), 10), s2 = e2.globals.translateY + a2, r2 = i2.yaxisTTEls[t3].getBoundingClientRect().height, o2 = e2.globals.translateYAxisX[t3] - 2;
      e2.config.yaxis[t3].opposite && (o2 -= 26), s2 -= r2 / 2, e2.globals.ignoreYAxisIndexes.indexOf(t3) === -1 ? (i2.yaxisTTEls[t3].classList.add("apexcharts-active"), i2.yaxisTTEls[t3].style.top = s2 + "px", i2.yaxisTTEls[t3].style.left = o2 + e2.config.yaxis[t3].tooltip.offsetX + "px") : i2.yaxisTTEls[t3].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), o2 = s2.tooltipRect, n2 = i2 !== null ? parseFloat(i2) : 1, l2 = parseFloat(t3) + n2 + 5, h3 = parseFloat(e2) + n2 / 2;
      if (l2 > a2.globals.gridWidth / 2 && (l2 = l2 - o2.ttWidth - n2 - 10), l2 > a2.globals.gridWidth - o2.ttWidth - 10 && (l2 = a2.globals.gridWidth - o2.ttWidth), l2 < -20 && (l2 = -20), a2.config.tooltip.followCursor) {
        var c2 = s2.getElGrid(), d2 = c2.getBoundingClientRect();
        h3 = s2.e.clientY + a2.globals.translateY - d2.top - o2.ttHeight / 2;
      } else
        a2.globals.isBarHorizontal || (o2.ttHeight / 2 + h3 > a2.globals.gridHeight && (h3 = a2.globals.gridHeight - o2.ttHeight + a2.globals.translateY), h3 < 0 && (h3 = 0));
      isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + "px", r2.style.top = h3 + "px");
    } }, { key: "moveMarkers", value: function(t3, e2) {
      var i2 = this.w, a2 = this.ttCtx;
      if (i2.globals.markers.size[t3] > 0)
        for (var s2 = i2.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-marker")), r2 = 0; r2 < s2.length; r2++)
          parseInt(s2[r2].getAttribute("rel"), 10) === e2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
      else
        a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
    } }, { key: "moveDynamicPointOnHover", value: function(t3, e2) {
      var i2, a2, s2 = this.w, r2 = this.ttCtx, o2 = s2.globals.pointsArray, n2 = r2.tooltipUtil.getHoverMarkerSize(e2), l2 = s2.config.series[e2].type;
      if (!l2 || l2 !== "column" && l2 !== "candlestick" && l2 !== "boxPlot") {
        i2 = o2[e2][t3][0], a2 = o2[e2][t3][1] ? o2[e2][t3][1] : 0;
        var h3 = s2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers circle"));
        h3 && a2 < s2.globals.gridHeight && a2 > 0 && (h3.setAttribute("r", n2), h3.setAttribute("cx", i2), h3.setAttribute("cy", a2)), this.moveXCrosshairs(i2), r2.fixedTooltip || this.moveTooltip(i2, a2, n2);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(t3) {
      var e2, i2 = this.ttCtx, a2 = i2.w, s2 = 0, r2 = 0, o2 = a2.globals.pointsArray;
      e2 = new E(this.ctx).getActiveConfigSeriesIndex(true);
      var n2 = i2.tooltipUtil.getHoverMarkerSize(e2);
      o2[e2] && (s2 = o2[e2][t3][0], r2 = o2[e2][t3][1]);
      var l2 = i2.tooltipUtil.getAllMarkers();
      if (l2 !== null)
        for (var h3 = 0; h3 < a2.globals.series.length; h3++) {
          var c2 = o2[h3];
          if (a2.globals.comboCharts && c2 === void 0 && l2.splice(h3, 0, null), c2 && c2.length) {
            var d2 = o2[h3][t3][1];
            l2[h3].setAttribute("cx", s2), d2 !== null && !isNaN(d2) && d2 < a2.globals.gridHeight + n2 && d2 + n2 > 0 ? (l2[h3] && l2[h3].setAttribute("r", n2), l2[h3] && l2[h3].setAttribute("cy", d2)) : l2[h3] && l2[h3].setAttribute("r", 0);
          }
        }
      if (this.moveXCrosshairs(s2), !i2.fixedTooltip) {
        var g2 = r2 || a2.globals.gridHeight;
        this.moveTooltip(s2, g2, n2);
      }
    } }, { key: "moveStickyTooltipOverBars", value: function(t3) {
      var e2 = this.w, i2 = this.ttCtx, a2 = e2.globals.columnSeries ? e2.globals.columnSeries.length : e2.globals.series.length, s2 = a2 >= 2 && a2 % 2 == 0 ? Math.floor(a2 / 2) : Math.floor(a2 / 2) + 1;
      e2.globals.isBarHorizontal && (s2 = new E(this.ctx).getActiveConfigSeriesIndex(false, "desc") + 1);
      var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(s2, "'] path[j='").concat(t3, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(s2, "'] path[j='").concat(t3, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(s2, "'] path[j='").concat(t3, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(s2, "'] path[j='").concat(t3, "']")), o2 = r2 ? parseFloat(r2.getAttribute("cx")) : 0, n2 = r2 ? parseFloat(r2.getAttribute("cy")) : 0, l2 = r2 ? parseFloat(r2.getAttribute("barWidth")) : 0, h3 = r2 ? parseFloat(r2.getAttribute("barHeight")) : 0, c2 = i2.getElGrid().getBoundingClientRect(), d2 = r2.classList.contains("apexcharts-candlestick-area") || r2.classList.contains("apexcharts-boxPlot-area");
      if (e2.globals.isXNumeric ? (r2 && !d2 && (o2 -= a2 % 2 != 0 ? l2 / 2 : 0), r2 && d2 && e2.globals.comboCharts && (o2 -= l2 / 2)) : e2.globals.isBarHorizontal || (o2 = i2.xAxisTicksPositions[t3 - 1] + i2.dataPointsDividedWidth / 2, isNaN(o2) && (o2 = i2.xAxisTicksPositions[t3] - i2.dataPointsDividedWidth / 2)), e2.globals.isBarHorizontal ? (n2 > e2.globals.gridHeight / 2 && (n2 -= i2.tooltipRect.ttHeight), (n2 = n2 + e2.config.grid.padding.top + h3 / 3) + h3 > e2.globals.gridHeight && (n2 = e2.globals.gridHeight - h3)) : e2.config.tooltip.followCursor ? n2 = i2.e.clientY - c2.top - i2.tooltipRect.ttHeight / 2 : n2 + i2.tooltipRect.ttHeight + 15 > e2.globals.gridHeight && (n2 = e2.globals.gridHeight), n2 < -10 && (n2 = -10), e2.globals.isBarHorizontal || this.moveXCrosshairs(o2), !i2.fixedTooltip) {
        var g2 = n2 || e2.globals.gridHeight;
        this.moveTooltip(o2, g2);
      }
    } }]), t2;
  }(), xt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new ft(e2);
    }
    return r(t2, [{ key: "drawDynamicPoints", value: function() {
      var t3 = this.w, e2 = new m(this.ctx), i2 = new M(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      a2 = u(a2), t3.config.chart.stacked && a2.sort(function(t4, e3) {
        return parseFloat(t4.getAttribute("data:realIndex")) - parseFloat(e3.getAttribute("data:realIndex"));
      });
      for (var s2 = 0; s2 < a2.length; s2++) {
        var r2 = a2[s2].querySelector(".apexcharts-series-markers-wrap");
        if (r2 !== null) {
          var o2 = void 0, n2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          t3.config.chart.type !== "line" && t3.config.chart.type !== "area" || t3.globals.comboCharts || t3.config.tooltip.intersect || (n2 += " no-pointer-events");
          var l2 = i2.getMarkerConfig({ cssClass: n2, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
          (o2 = e2.drawMarker(0, 0, l2)).node.setAttribute("default-marker-size", 0);
          var h3 = document.createElementNS(t3.globals.SVGNS, "g");
          h3.classList.add("apexcharts-series-markers"), h3.appendChild(o2.node), r2.appendChild(h3);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, s2 = this.w;
      s2.config.chart.type !== "bubble" && this.newPointSize(t3, e2);
      var r2 = e2.getAttribute("cx"), o2 = e2.getAttribute("cy");
      if (i2 !== null && a2 !== null && (r2 = i2, o2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
        if (s2.config.chart.type === "radar") {
          var n2 = this.ttCtx.getElGrid(), l2 = n2.getBoundingClientRect();
          r2 = this.ttCtx.e.clientX - l2.left;
        }
        this.tooltipPosition.moveTooltip(r2, o2, s2.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(t3) {
      for (var e2 = this.w, i2 = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o2 = e2.config.markers.hover.size, n2 = 0; n2 < r2.length; n2++) {
        var l2 = r2[n2].getAttribute("rel"), h3 = r2[n2].getAttribute("index");
        if (o2 === void 0 && (o2 = e2.globals.markers.size[h3] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
          i2.newPointSize(s2, r2[n2]);
          var c2 = r2[n2].getAttribute("cx"), d2 = r2[n2].getAttribute("cy");
          i2.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i2.tooltipPosition.moveTooltip(c2, d2, o2);
        } else
          i2.oldPointSize(r2[n2]);
      }
    } }, { key: "newPointSize", value: function(t3, e2) {
      var i2 = this.w, a2 = i2.config.markers.hover.size, s2 = t3 === 0 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
      if (s2.getAttribute("default-marker-size") !== "0") {
        var r2 = parseInt(s2.getAttribute("index"), 10);
        a2 === void 0 && (a2 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0), s2.setAttribute("r", a2);
      }
    } }, { key: "oldPointSize", value: function(t3) {
      var e2 = parseFloat(t3.getAttribute("default-marker-size"));
      t3.setAttribute("r", e2);
    } }, { key: "resetPointsSize", value: function() {
      for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e2 = 0; e2 < t3.length; e2++) {
        var i2 = parseFloat(t3[e2].getAttribute("default-marker-size"));
        x.isNumber(i2) && i2 >= 0 ? t3[e2].setAttribute("r", i2) : t3[e2].setAttribute("r", 0);
      }
    } }]), t2;
  }(), bt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.ttCtx = e2;
    }
    return r(t2, [{ key: "getAttr", value: function(t3, e2) {
      return parseFloat(t3.target.getAttribute(e2));
    } }, { key: "handleHeatTreeTooltip", value: function(t3) {
      var e2 = t3.e, i2 = t3.opt, a2 = t3.x, s2 = t3.y, r2 = t3.type, o2 = this.ttCtx, n2 = this.w;
      if (e2.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
        var l2 = this.getAttr(e2, "i"), h3 = this.getAttr(e2, "j"), c2 = this.getAttr(e2, "cx"), d2 = this.getAttr(e2, "cy"), g2 = this.getAttr(e2, "width"), u2 = this.getAttr(e2, "height");
        if (o2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l2, j: h3, shared: false, e: e2 }), n2.globals.capturedSeriesIndex = l2, n2.globals.capturedDataPointIndex = h3, a2 = c2 + o2.tooltipRect.ttWidth / 2 + g2, s2 = d2 + o2.tooltipRect.ttHeight / 2 - u2 / 2, o2.tooltipPosition.moveXCrosshairs(c2 + g2 / 2), a2 > n2.globals.gridWidth / 2 && (a2 = c2 - o2.tooltipRect.ttWidth / 2 + g2), o2.w.config.tooltip.followCursor) {
          var p3 = n2.globals.dom.elWrap.getBoundingClientRect();
          a2 = n2.globals.clientX - p3.left - (a2 > n2.globals.gridWidth / 2 ? o2.tooltipRect.ttWidth : 0), s2 = n2.globals.clientY - p3.top - (s2 > n2.globals.gridHeight / 2 ? o2.tooltipRect.ttHeight : 0);
        }
      }
      return { x: a2, y: s2 };
    } }, { key: "handleMarkerTooltip", value: function(t3) {
      var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = t3.x, o2 = t3.y, n2 = this.w, l2 = this.ttCtx;
      if (a2.target.classList.contains("apexcharts-marker")) {
        var h3 = parseInt(s2.paths.getAttribute("cx"), 10), c2 = parseInt(s2.paths.getAttribute("cy"), 10), d2 = parseFloat(s2.paths.getAttribute("val"));
        if (i2 = parseInt(s2.paths.getAttribute("rel"), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l2.intersect) {
          var g2 = x.findAncestor(s2.paths, "apexcharts-series");
          g2 && (e2 = parseInt(g2.getAttribute("data:realIndex"), 10));
        }
        if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i2, shared: !l2.showOnIntersect && n2.config.tooltip.shared, e: a2 }), a2.type === "mouseup" && l2.markerClick(a2, e2, i2), n2.globals.capturedSeriesIndex = e2, n2.globals.capturedDataPointIndex = i2, r2 = h3, o2 = c2 + n2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
          var u2 = l2.getElGrid().getBoundingClientRect();
          o2 = l2.e.clientY + n2.globals.translateY - u2.top;
        }
        d2 < 0 && (o2 = c2), l2.marker.enlargeCurrentPoint(i2, s2.paths, r2, o2);
      }
      return { x: r2, y: o2 };
    } }, { key: "handleBarTooltip", value: function(t3) {
      var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, o2 = this.ttCtx, n2 = o2.getElTooltip(), l2 = 0, h3 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
      e2 = d2.i;
      var g2 = d2.barHeight, u2 = d2.j;
      r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u2, r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h3 = d2.x, c2 = d2.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h3) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) ? c2 = r2.globals.svgHeight - o2.tooltipRect.ttHeight : c2 < 0 && (c2 = 0);
      var p3 = parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), f2 = r2.globals.isMultipleYAxis ? r2.config.yaxis[p3] && r2.config.yaxis[p3].reversed : r2.config.yaxis[0].reversed;
      if (h3 + o2.tooltipRect.ttWidth > r2.globals.gridWidth && !f2 ? h3 -= o2.tooltipRect.ttWidth : h3 < 0 && (h3 = 0), o2.w.config.tooltip.followCursor) {
        var x2 = o2.getElGrid().getBoundingClientRect();
        c2 = o2.e.clientY - x2.top;
      }
      o2.tooltip === null && (o2.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? o2.tooltipPosition.moveXCrosshairs(l2 + i2 / 2) : o2.tooltipPosition.moveXCrosshairs(l2)), !o2.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars()) && (f2 && (h3 -= o2.tooltipRect.ttWidth) < 0 && (h3 = 0), !f2 || r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars() || (c2 = c2 + g2 - 2 * (r2.globals.series[e2][u2] < 0 ? g2 : 0)), o2.tooltipRect.ttHeight + c2 > r2.globals.gridHeight ? c2 = r2.globals.gridHeight - o2.tooltipRect.ttHeight + r2.globals.translateY : (c2 = c2 + r2.globals.translateY - o2.tooltipRect.ttHeight / 2) < 0 && (c2 = 0), n2.style.left = h3 + r2.globals.translateX + "px", n2.style.top = c2 + "px");
    } }, { key: "getBarTooltipXY", value: function(t3) {
      var e2 = t3.e, i2 = t3.opt, a2 = this.w, s2 = null, r2 = this.ttCtx, o2 = 0, n2 = 0, l2 = 0, h3 = 0, c2 = 0, d2 = e2.target.classList;
      if (d2.contains("apexcharts-bar-area") || d2.contains("apexcharts-candlestick-area") || d2.contains("apexcharts-boxPlot-area") || d2.contains("apexcharts-rangebar-area")) {
        var g2 = e2.target, u2 = g2.getBoundingClientRect(), p3 = i2.elGrid.getBoundingClientRect(), f2 = u2.height;
        c2 = u2.height;
        var x2 = u2.width, b2 = parseInt(g2.getAttribute("cx"), 10), v2 = parseInt(g2.getAttribute("cy"), 10);
        h3 = parseFloat(g2.getAttribute("barWidth"));
        var m2 = e2.type === "touchmove" ? e2.touches[0].clientX : e2.clientX;
        s2 = parseInt(g2.getAttribute("j"), 10), o2 = parseInt(g2.parentNode.getAttribute("rel"), 10) - 1;
        var y2 = g2.getAttribute("data-range-y1"), w2 = g2.getAttribute("data-range-y2");
        a2.globals.comboCharts && (o2 = parseInt(g2.parentNode.getAttribute("data:realIndex"), 10)), r2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: o2, j: s2, y1: y2 ? parseInt(y2, 10) : null, y2: w2 ? parseInt(w2, 10) : null, shared: !r2.showOnIntersect && a2.config.tooltip.shared, e: e2 }), a2.config.tooltip.followCursor ? a2.globals.isBarHorizontal ? (n2 = m2 - p3.left + 15, l2 = v2 - r2.dataPointsDividedHeight + f2 / 2 - r2.tooltipRect.ttHeight / 2) : (n2 = a2.globals.isXNumeric ? b2 - x2 / 2 : b2 - r2.dataPointsDividedWidth + x2 / 2, l2 = e2.clientY - p3.top - r2.tooltipRect.ttHeight / 2 - 15) : a2.globals.isBarHorizontal ? ((n2 = b2) < r2.xyRatios.baseLineInvertedY && (n2 = b2 - r2.tooltipRect.ttWidth), l2 = v2 - r2.dataPointsDividedHeight + f2 / 2 - r2.tooltipRect.ttHeight / 2) : (n2 = a2.globals.isXNumeric ? b2 - x2 / 2 : b2 - r2.dataPointsDividedWidth + x2 / 2, l2 = v2);
      }
      return { x: n2, y: l2, barHeight: c2, barWidth: h3, i: o2, j: s2 };
    } }]), t2;
  }(), vt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.ttCtx = e2;
    }
    return r(t2, [{ key: "drawXaxisTooltip", value: function() {
      var t3 = this.w, e2 = this.ttCtx, i2 = t3.config.xaxis.position === "bottom";
      e2.xaxisOffY = i2 ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
      var a2 = i2 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = t3.globals.dom.elWrap;
      e2.isXAxisTooltipEnabled && (t3.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (e2.xaxisTooltip = document.createElement("div"), e2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement("div"), e2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var t3 = this.w, e2 = this.ttCtx, i2 = function(i3) {
        var a3 = t3.config.yaxis[i3].opposite || t3.config.yaxis[i3].crosshairs.opposite;
        e2.yaxisOffX = a3 ? t3.globals.gridWidth + 1 : 1;
        var s2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i3, a3 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
        t3.globals.yAxisSameScaleIndices.map(function(e3, a4) {
          e3.map(function(e4, a5) {
            a5 === i3 && (s2 += t3.config.yaxis[a5].show ? " " : " apexcharts-yaxistooltip-hidden");
          });
        });
        var r2 = t3.globals.dom.elWrap;
        t3.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i3)) === null && (e2.yaxisTooltip = document.createElement("div"), e2.yaxisTooltip.setAttribute("class", s2 + " apexcharts-theme-" + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), i3 === 0 && (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i3] = document.createElement("div"), e2.yaxisTooltipText[i3].classList.add("apexcharts-yaxistooltip-text"), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i3]));
      }, a2 = 0; a2 < t3.config.yaxis.length; a2++)
        i2(a2);
    } }, { key: "setXCrosshairWidth", value: function() {
      var t3 = this.w, e2 = this.ttCtx, i2 = e2.getElXCrosshairs();
      if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
        var a2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (a2 !== null && t3.config.xaxis.crosshairs.width === "barWidth") {
          var s2 = parseFloat(a2.getAttribute("barWidth"));
          e2.xcrosshairsWidth = s2;
        } else if (t3.config.xaxis.crosshairs.width === "tickWidth") {
          var r2 = t3.globals.labels.length;
          e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
        }
      } else if (t3.config.xaxis.crosshairs.width === "tickWidth") {
        var o2 = t3.globals.labels.length;
        e2.xcrosshairsWidth = t3.globals.gridWidth / o2;
      } else if (t3.config.xaxis.crosshairs.width === "barWidth") {
        var n2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (n2 !== null) {
          var l2 = parseFloat(n2.getAttribute("barWidth"));
          e2.xcrosshairsWidth = l2;
        } else
          e2.xcrosshairsWidth = 1;
      }
      t3.globals.isBarHorizontal && (e2.xcrosshairsWidth = 0), i2 !== null && e2.xcrosshairsWidth > 0 && i2.setAttribute("width", e2.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var t3 = this.w, e2 = this.ttCtx;
      e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(t3, e2, i2) {
      var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals.yLabelFormatters[t3];
      if (a2.yaxisTooltips[t3]) {
        var o2 = a2.getElGrid().getBoundingClientRect(), n2 = (e2 - o2.top) * i2.yRatio[t3], l2 = s2.globals.maxYArr[t3] - s2.globals.minYArr[t3], h3 = s2.globals.minYArr[t3] + (l2 - n2);
        a2.tooltipPosition.moveYCrosshairs(e2 - o2.top), a2.yaxisTooltipText[t3].innerHTML = r2(h3), a2.tooltipPosition.moveYAxisTooltip(t3);
      }
    } }]), t2;
  }(), mt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var i2 = this.w;
      this.tConfig = i2.config.tooltip, this.tooltipUtil = new ut(this), this.tooltipLabels = new pt(this), this.tooltipPosition = new ft(this), this.marker = new xt(this), this.intersect = new bt(this), this.axesTooltip = new vt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return r(t2, [{ key: "getElTooltip", value: function(t3) {
      return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(t3) {
      var e2 = this.w;
      this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled && e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map(function(t4, i3) {
        return !!(t4.show && t4.tooltip.enabled && e2.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
      var i2 = document.createElement("div");
      if (i2.classList.add("apexcharts-tooltip"), e2.config.tooltip.cssClass && i2.classList.add(e2.config.tooltip.cssClass), i2.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e2.globals.dom.elWrap.appendChild(i2), e2.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var a2 = new _(this.ctx);
        this.xAxisTicksPositions = a2.getXAxisTicksPositions();
      }
      if (!e2.globals.comboCharts && !this.tConfig.intersect && e2.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = true), e2.config.markers.size !== 0 && e2.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
        this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
        var s2 = e2.globals.series.length;
        (e2.globals.xyCharts || e2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(t3) {
      for (var e2 = this, i2 = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
        var o3 = document.createElement("div");
        o3.classList.add("apexcharts-tooltip-series-group"), o3.style.order = i2.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1, e2.tConfig.shared && e2.tConfig.enabledOnSeries && Array.isArray(e2.tConfig.enabledOnSeries) && e2.tConfig.enabledOnSeries.indexOf(r3) < 0 && o3.classList.add("apexcharts-tooltip-series-group-hidden");
        var n2 = document.createElement("span");
        n2.classList.add("apexcharts-tooltip-marker"), n2.style.backgroundColor = i2.globals.colors[r3], o3.appendChild(n2);
        var l2 = document.createElement("div");
        l2.classList.add("apexcharts-tooltip-text"), l2.style.fontFamily = e2.tConfig.style.fontFamily || i2.config.chart.fontFamily, l2.style.fontSize = e2.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t4) {
          var e3 = document.createElement("div");
          e3.classList.add("apexcharts-tooltip-".concat(t4, "-group"));
          var i3 = document.createElement("span");
          i3.classList.add("apexcharts-tooltip-text-".concat(t4, "-label")), e3.appendChild(i3);
          var a3 = document.createElement("span");
          a3.classList.add("apexcharts-tooltip-text-".concat(t4, "-value")), e3.appendChild(a3), l2.appendChild(e3);
        }), o3.appendChild(l2), s2.appendChild(o3), a2.push(o3);
      }, o2 = 0; o2 < t3; o2++)
        r2(o2);
      return a2;
    } }, { key: "addSVGEvents", value: function() {
      var t3 = this.w, e2 = t3.config.chart.type, i2 = this.getElTooltip(), a2 = !(e2 !== "bar" && e2 !== "candlestick" && e2 !== "boxPlot" && e2 !== "rangeBar"), s2 = e2 === "area" || e2 === "line" || e2 === "scatter" || e2 === "bubble" || e2 === "radar", r2 = t3.globals.dom.Paper.node, o2 = this.getElGrid();
      o2 && (this.seriesBound = o2.getBoundingClientRect());
      var n2, l2 = [], h3 = [], c2 = { hoverArea: r2, elGrid: o2, tooltipEl: i2, tooltipY: l2, tooltipX: h3, ttItems: this.ttItems };
      if (t3.globals.axisCharts && (s2 ? n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : e2 !== "heatmap" && e2 !== "treemap" || (n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n2 && n2.length))
        for (var d2 = 0; d2 < n2.length; d2++)
          l2.push(n2[d2].getAttribute("cy")), h3.push(n2[d2].getAttribute("cx"));
      if (t3.globals.xyCharts && !this.showOnIntersect || t3.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared)
        this.addPathsEventListeners([r2], c2);
      else if (a2 && !t3.globals.comboCharts || s2 && this.showOnIntersect)
        this.addDatapointEventsListeners(c2);
      else if (!t3.globals.axisCharts || e2 === "heatmap" || e2 === "treemap") {
        var g2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(g2, c2);
      }
      if (this.showOnIntersect) {
        var u2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        u2.length > 0 && this.addPathsEventListeners(u2, c2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c2);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var t3 = this.w, e2 = this.getElTooltip(), i2 = e2.getBoundingClientRect(), a2 = i2.width + 10, s2 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, o2 = this.tConfig.fixed.offsetY, n2 = this.tConfig.fixed.position.toLowerCase();
      return n2.indexOf("right") > -1 && (r2 = r2 + t3.globals.svgWidth - a2 + 10), n2.indexOf("bottom") > -1 && (o2 = o2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + "px", e2.style.top = o2 + "px", { x: r2, y: o2, ttWidth: a2, ttHeight: s2 };
    } }, { key: "addDatapointEventsListeners", value: function(t3) {
      var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(e2, t3);
    } }, { key: "addPathsEventListeners", value: function(t3, e2) {
      for (var i2 = this, a2 = function(a3) {
        var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e3) {
          return t3[a3].addEventListener(e3, i2.onSeriesHover.bind(i2, s3), { capture: false, passive: true });
        });
      }, s2 = 0; s2 < t3.length; s2++)
        a2(s2);
    } }, { key: "onSeriesHover", value: function(t3, e2) {
      var i2 = this, a2 = Date.now() - this.lastHoverTime;
      a2 >= 100 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        i2.seriesHover(t3, e2);
      }, 100 - a2));
    } }, { key: "seriesHover", value: function(t3, e2) {
      var i2 = this;
      this.lastHoverTime = Date.now();
      var a2 = [], s2 = this.w;
      s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || s2.globals.dataPoints === 0) || (a2.length ? a2.forEach(function(a3) {
        var s3 = i2.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
        a3.w.globals.minX === i2.w.globals.minX && a3.w.globals.maxX === i2.w.globals.maxX && a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
    } }, { key: "seriesHoverByContext", value: function(t3) {
      var e2 = t3.chartCtx, i2 = t3.ttCtx, a2 = t3.opt, s2 = t3.e, r2 = e2.w, o2 = this.getElTooltip();
      if (o2) {
        if (i2.tooltipRect = { x: 0, y: 0, ttWidth: o2.getBoundingClientRect().width, ttHeight: o2.getBoundingClientRect().height }, i2.e = s2, i2.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i2.isBarShared) {
          if (this.tConfig.onDatasetHover.highlightDataSeries)
            new E(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
        }
        i2.fixedTooltip && i2.drawFixedTooltipRect(), r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect });
      }
    } }, { key: "axisChartsTooltips", value: function(t3) {
      var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, o2 = s2.elGrid.getBoundingClientRect(), n2 = a2.type === "touchmove" ? a2.touches[0].clientX : a2.clientX, l2 = a2.type === "touchmove" ? a2.touches[0].clientY : a2.clientY;
      if (this.clientY = l2, this.clientX = n2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 < o2.top || l2 > o2.top + o2.height)
        this.handleMouseOut(s2);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
          var h3 = parseInt(s2.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(h3) < 0)
            return void this.handleMouseOut(s2);
        }
        var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), g2 = r2.globals.xyCharts || r2.config.chart.type === "bar" && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
        if (a2.type === "mousemove" || a2.type === "touchmove" || a2.type === "mouseup") {
          if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length)
            return;
          d2 !== null && d2.classList.add("apexcharts-active");
          var u2 = this.yaxisTooltips.filter(function(t4) {
            return t4 === true;
          });
          if (this.ycrosshairs !== null && u2.length && this.ycrosshairs.classList.add("apexcharts-active"), g2 && !this.showOnIntersect)
            this.handleStickyTooltip(a2, n2, l2, s2);
          else if (r2.config.chart.type === "heatmap" || r2.config.chart.type === "treemap") {
            var p3 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i2, type: r2.config.chart.type });
            e2 = p3.x, i2 = p3.y, c2.style.left = e2 + "px", c2.style.top = i2 + "px";
          } else
            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i2 });
          if (this.yaxisTooltips.length)
            for (var f2 = 0; f2 < r2.config.yaxis.length; f2++)
              this.axesTooltip.drawYaxisTooltipText(f2, l2, this.xyRatios);
          s2.tooltipEl.classList.add("apexcharts-active");
        } else
          a2.type !== "mouseout" && a2.type !== "touchend" || this.handleMouseOut(s2);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(t3) {
      var e2 = t3.e, i2 = t3.opt, a2 = t3.tooltipRect, s2 = this.w, r2 = i2.paths.getAttribute("rel"), o2 = this.getElTooltip(), n2 = s2.globals.dom.elWrap.getBoundingClientRect();
      if (e2.type === "mousemove" || e2.type === "touchmove") {
        o2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
        var l2 = s2.globals.clientX - n2.left - a2.ttWidth / 2, h3 = s2.globals.clientY - n2.top - a2.ttHeight - 10;
        if (o2.style.left = l2 + "px", o2.style.top = h3 + "px", s2.config.legend.tooltipHoverFormatter) {
          var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute("data:default-text"), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
          this.legendLabels[c2].innerHTML = d2;
        }
      } else
        e2.type !== "mouseout" && e2.type !== "touchend" || (o2.classList.remove("apexcharts-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
          var e3 = t4.getAttribute("data:default-text");
          t4.innerHTML = decodeURIComponent(e3);
        }));
    } }, { key: "handleStickyTooltip", value: function(t3, e2, i2, a2) {
      var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i2 }), o2 = r2.j, n2 = r2.capturedSeries, l2 = a2.elGrid.getBoundingClientRect();
      r2.hoverX < 0 || r2.hoverX > l2.width ? this.handleMouseOut(a2) : n2 !== null ? this.handleStickyCapturedSeries(t3, n2, a2, o2) : (this.tooltipUtil.isXoverlap(o2) || s2.globals.isBarHorizontal) && this.create(t3, this, 0, o2, a2.ttItems);
    } }, { key: "handleStickyCapturedSeries", value: function(t3, e2, i2, a2) {
      var s2 = this.w;
      if (!this.tConfig.shared && s2.globals.series[e2][a2] === null)
        return void this.handleMouseOut(i2);
      s2.globals.series[e2][a2] !== void 0 ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i2.ttItems) : this.create(t3, this, e2, a2, i2.ttItems, false) : this.tooltipUtil.isXoverlap(a2) && this.create(t3, this, 0, a2, i2.ttItems);
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var t3 = this.w, e2 = new m(this.ctx), i2 = t3.globals.dom.Paper.select(".apexcharts-bar-area"), a2 = 0; a2 < i2.length; a2++)
        e2.pathMouseLeave(i2[a2]);
    } }, { key: "handleMouseOut", value: function(t3) {
      var e2 = this.w, i2 = this.getElXCrosshairs();
      if (t3.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), e2.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i2 !== null && i2.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        this.yaxisTTEls === null && (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var a2 = 0; a2 < this.yaxisTTEls.length; a2++)
          this.yaxisTTEls[a2].classList.remove("apexcharts-active");
      }
      e2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
        var e3 = t4.getAttribute("data:default-text");
        t4.innerHTML = decodeURIComponent(e3);
      });
    } }, { key: "markerClick", value: function(t3, e2, i2) {
      var a2 = this.w;
      typeof a2.config.chart.events.markerClick == "function" && a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }), this.ctx.events.fireEvent("markerClick", [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }]);
    } }, { key: "create", value: function(t3, e2, i2, a2, s2) {
      var r2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, o2 = this.w, n2 = e2;
      t3.type === "mouseup" && this.markerClick(t3, i2, a2), r2 === null && (r2 = this.tConfig.shared);
      var l2 = this.tooltipUtil.hasMarkers(), h3 = this.tooltipUtil.getElBars();
      if (o2.config.legend.tooltipHoverFormatter) {
        var c2 = o2.config.legend.tooltipHoverFormatter, d2 = Array.from(this.legendLabels);
        d2.forEach(function(t4) {
          var e3 = t4.getAttribute("data:default-text");
          t4.innerHTML = decodeURIComponent(e3);
        });
        for (var g2 = 0; g2 < d2.length; g2++) {
          var u2 = d2[g2], p3 = parseInt(u2.getAttribute("i"), 10), f2 = decodeURIComponent(u2.getAttribute("data:default-text")), x2 = c2(f2, { seriesIndex: r2 ? p3 : i2, dataPointIndex: a2, w: o2 });
          if (r2)
            u2.innerHTML = o2.globals.collapsedSeriesIndices.indexOf(p3) < 0 ? x2 : f2;
          else if (u2.innerHTML = p3 === i2 ? x2 : f2, i2 === p3)
            break;
        }
      }
      if (r2) {
        if (n2.tooltipLabels.drawSeriesTexts({ ttItems: s2, i: i2, j: a2, shared: !this.showOnIntersect && this.tConfig.shared }), l2 && (o2.globals.markers.largestSize > 0 ? n2.marker.enlargePoints(a2) : n2.tooltipPosition.moveDynamicPointsOnHover(a2)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h3), this.barSeriesHeight > 0)) {
          var b2 = new m(this.ctx), v2 = o2.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a2, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a2);
          for (var y2 = 0; y2 < v2.length; y2++)
            b2.pathMouseEnter(v2[y2]);
        }
      } else
        n2.tooltipLabels.drawSeriesTexts({ shared: false, ttItems: s2, i: i2, j: a2 }), this.tooltipUtil.hasBars() && n2.tooltipPosition.moveStickyTooltipOverBars(a2), l2 && n2.tooltipPosition.moveMarkers(i2, a2);
    } }]), t2;
  }(), yt = function(t2) {
    n(s2, F);
    var i2 = d(s2);
    function s2() {
      return a(this, s2), i2.apply(this, arguments);
    }
    return r(s2, [{ key: "draw", value: function(t3, i3) {
      var a2 = this, s3 = this.w;
      this.graphics = new m(this.ctx), this.bar = new F(this.ctx, this.xyRatios);
      var r2 = new y(this.ctx, s3);
      t3 = r2.getLogSeries(t3), this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), s3.config.chart.stackType === "100%" && (t3 = s3.globals.seriesPercent.slice()), this.series = t3, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];
      for (var o2 = 0; o2 < t3.length; o2++)
        t3[o2].length > 0 && (this.totalItems += t3[o2].length);
      for (var n2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), l2 = 0, h3 = 0, c2 = function(r3, o3) {
        var c3 = void 0, d3 = void 0, g3 = void 0, u2 = void 0, p3 = [], f2 = [], b2 = s3.globals.comboCharts ? i3[r3] : r3;
        a2.yRatio.length > 1 && (a2.yaxisIndex = b2), a2.isReversed = s3.config.yaxis[a2.yaxisIndex] && s3.config.yaxis[a2.yaxisIndex].reversed;
        var v2 = a2.graphics.group({ class: "apexcharts-series", seriesName: x.escapeString(s3.globals.seriesNames[b2]), rel: r3 + 1, "data:realIndex": b2 });
        a2.ctx.series.addCollapsedClassToSeries(v2, b2);
        var m2 = a2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": b2 }), y2 = 0, w2 = 0, k2 = a2.initialPositions(l2, h3, c3, d3, g3, u2);
        h3 = k2.y, y2 = k2.barHeight, d3 = k2.yDivision, u2 = k2.zeroW, l2 = k2.x, w2 = k2.barWidth, c3 = k2.xDivision, g3 = k2.zeroH, a2.yArrj = [], a2.yArrjF = [], a2.yArrjVal = [], a2.xArrj = [], a2.xArrjF = [], a2.xArrjVal = [], a2.prevY.length === 1 && a2.prevY[0].every(function(t4) {
          return isNaN(t4);
        }) && (a2.prevY[0] = a2.prevY[0].map(function(t4) {
          return g3;
        }), a2.prevYF[0] = a2.prevYF[0].map(function(t4) {
          return 0;
        }));
        for (var A2 = 0; A2 < s3.globals.dataPoints; A2++) {
          var S2 = a2.barHelpers.getStrokeWidth(r3, A2, b2), C2 = { indexes: { i: r3, j: A2, realIndex: b2, bc: o3 }, strokeWidth: S2, x: l2, y: h3, elSeries: v2 }, L2 = null;
          a2.isHorizontal ? (L2 = a2.drawStackedBarPaths(e(e({}, C2), {}, { zeroW: u2, barHeight: y2, yDivision: d3 })), w2 = a2.series[r3][A2] / a2.invertedYRatio) : (L2 = a2.drawStackedColumnPaths(e(e({}, C2), {}, { xDivision: c3, barWidth: w2, zeroH: g3 })), y2 = a2.series[r3][A2] / a2.yRatio[a2.yaxisIndex]), h3 = L2.y, l2 = L2.x, p3.push(l2), f2.push(h3);
          var P2 = a2.barHelpers.getPathFillColor(t3, r3, A2, b2);
          v2 = a2.renderSeries({ realIndex: b2, pathFill: P2, j: A2, i: r3, pathFrom: L2.pathFrom, pathTo: L2.pathTo, strokeWidth: S2, elSeries: v2, x: l2, y: h3, series: t3, barHeight: y2, barWidth: w2, elDataLabelsWrap: m2, type: "bar", visibleSeries: 0 });
        }
        s3.globals.seriesXvalues[b2] = p3, s3.globals.seriesYvalues[b2] = f2, a2.prevY.push(a2.yArrj), a2.prevYF.push(a2.yArrjF), a2.prevYVal.push(a2.yArrjVal), a2.prevX.push(a2.xArrj), a2.prevXF.push(a2.xArrjF), a2.prevXVal.push(a2.xArrjVal), n2.add(v2);
      }, d2 = 0, g2 = 0; d2 < t3.length; d2++, g2++)
        c2(d2, g2);
      return n2;
    } }, { key: "initialPositions", value: function(t3, e2, i3, a2, s3, r2) {
      var o2, n2, l2 = this.w;
      return this.isHorizontal ? (o2 = (o2 = a2 = l2.globals.gridHeight / l2.globals.dataPoints) * parseInt(l2.config.plotOptions.bar.barHeight, 10) / 100, r2 = this.baseLineInvertedY + l2.globals.padHorizontal + (this.isReversed ? l2.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e2 = (a2 - o2) / 2) : (n2 = i3 = l2.globals.gridWidth / l2.globals.dataPoints, n2 = l2.globals.isXNumeric && l2.globals.dataPoints > 1 ? (i3 = l2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : n2 * parseInt(l2.config.plotOptions.bar.columnWidth, 10) / 100, s3 = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l2.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t3 = l2.globals.padHorizontal + (i3 - n2) / 2), { x: t3, y: e2, yDivision: a2, xDivision: i3, barHeight: o2, barWidth: n2, zeroH: s3, zeroW: r2 };
    } }, { key: "drawStackedBarPaths", value: function(t3) {
      for (var e2, i3 = t3.indexes, a2 = t3.barHeight, s3 = t3.strokeWidth, r2 = t3.zeroW, o2 = t3.x, n2 = t3.y, l2 = t3.yDivision, h3 = t3.elSeries, c2 = this.w, d2 = n2, g2 = i3.i, u2 = i3.j, p3 = 0, f2 = 0; f2 < this.prevXF.length; f2++)
        p3 += this.prevXF[f2][u2];
      if (g2 > 0) {
        var x2 = r2;
        this.prevXVal[g2 - 1][u2] < 0 ? x2 = this.series[g2][u2] >= 0 ? this.prevX[g2 - 1][u2] + p3 - 2 * (this.isReversed ? p3 : 0) : this.prevX[g2 - 1][u2] : this.prevXVal[g2 - 1][u2] >= 0 && (x2 = this.series[g2][u2] >= 0 ? this.prevX[g2 - 1][u2] : this.prevX[g2 - 1][u2] - p3 + 2 * (this.isReversed ? p3 : 0)), e2 = x2;
      } else
        e2 = r2;
      o2 = this.series[g2][u2] === null ? e2 : e2 + this.series[g2][u2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g2][u2] / this.invertedYRatio : 0);
      var b2 = this.barHelpers.getBarpaths({ barYPosition: d2, barHeight: a2, x1: e2, x2: o2, strokeWidth: s3, series: this.series, realIndex: i3.realIndex, i: g2, j: u2, w: c2 });
      return this.barHelpers.barBackground({ j: u2, i: g2, y1: d2, y2: a2, elSeries: h3 }), n2 += l2, { pathTo: b2.pathTo, pathFrom: b2.pathFrom, x: o2, y: n2 };
    } }, { key: "drawStackedColumnPaths", value: function(t3) {
      var e2 = t3.indexes, i3 = t3.x, a2 = t3.y, s3 = t3.xDivision, r2 = t3.barWidth, o2 = t3.zeroH;
      t3.strokeWidth;
      var n2 = t3.elSeries, l2 = this.w, h3 = e2.i, c2 = e2.j, d2 = e2.bc;
      if (l2.globals.isXNumeric) {
        var g2 = l2.globals.seriesX[h3][c2];
        g2 || (g2 = 0), i3 = (g2 - l2.globals.minX) / this.xRatio - r2 / 2;
      }
      for (var u2, p3 = i3, f2 = 0, x2 = 0; x2 < this.prevYF.length; x2++)
        f2 += isNaN(this.prevYF[x2][c2]) ? 0 : this.prevYF[x2][c2];
      if (h3 > 0 && !l2.globals.isXNumeric || h3 > 0 && l2.globals.isXNumeric && l2.globals.seriesX[h3 - 1][c2] === l2.globals.seriesX[h3][c2]) {
        var b2, v2, m2 = Math.min(this.yRatio.length + 1, h3 + 1);
        if (this.prevY[h3 - 1] !== void 0) {
          for (var y2 = 1; y2 < m2; y2++)
            if (!isNaN(this.prevY[h3 - y2][c2])) {
              v2 = this.prevY[h3 - y2][c2];
              break;
            }
        }
        for (var w2 = 1; w2 < m2; w2++) {
          if (this.prevYVal[h3 - w2][c2] < 0) {
            b2 = this.series[h3][c2] >= 0 ? v2 - f2 + 2 * (this.isReversed ? f2 : 0) : v2;
            break;
          }
          if (this.prevYVal[h3 - w2][c2] >= 0) {
            b2 = this.series[h3][c2] >= 0 ? v2 : v2 + f2 - 2 * (this.isReversed ? f2 : 0);
            break;
          }
        }
        b2 === void 0 && (b2 = l2.globals.gridHeight), u2 = this.prevYF[0].every(function(t4) {
          return t4 === 0;
        }) && this.prevYF.slice(1, h3).every(function(t4) {
          return t4.every(function(t5) {
            return isNaN(t5);
          });
        }) ? l2.globals.gridHeight - o2 : b2;
      } else
        u2 = l2.globals.gridHeight - o2;
      a2 = u2 - this.series[h3][c2] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[h3][c2] / this.yRatio[this.yaxisIndex] : 0);
      var k2 = this.barHelpers.getColumnPaths({ barXPosition: p3, barWidth: r2, y1: u2, y2: a2, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, realIndex: e2.realIndex, i: h3, j: c2, w: l2 });
      return this.barHelpers.barBackground({ bc: d2, j: c2, i: h3, x1: p3, x2: r2, elSeries: n2 }), i3 += s3, { pathTo: k2.pathTo, pathFrom: k2.pathFrom, x: l2.globals.isXNumeric ? i3 - s3 : i3, y: a2 };
    } }]), s2;
  }(), wt = function(t2) {
    n(s2, F);
    var i2 = d(s2);
    function s2() {
      return a(this, s2), i2.apply(this, arguments);
    }
    return r(s2, [{ key: "draw", value: function(t3, i3) {
      var a2 = this, s3 = this.w, r2 = new m(this.ctx), o2 = new T(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s3.config.plotOptions.bar.horizontal;
      var n2 = new y(this.ctx, s3);
      t3 = n2.getLogSeries(t3), this.series = t3, this.yRatio = n2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
      for (var l2 = r2.group({ class: "apexcharts-".concat(s3.config.chart.type, "-series apexcharts-plot-series") }), h3 = function(n3) {
        a2.isBoxPlot = s3.config.chart.type === "boxPlot" || s3.config.series[n3].type === "boxPlot";
        var h4, c3, d2, g2, u2 = void 0, p3 = void 0, f2 = [], b2 = [], v2 = s3.globals.comboCharts ? i3[n3] : n3, m2 = r2.group({ class: "apexcharts-series", seriesName: x.escapeString(s3.globals.seriesNames[v2]), rel: n3 + 1, "data:realIndex": v2 });
        a2.ctx.series.addCollapsedClassToSeries(m2, v2), t3[n3].length > 0 && (a2.visibleI = a2.visibleI + 1);
        var y2, w2;
        a2.yRatio.length > 1 && (a2.yaxisIndex = v2);
        var k2 = a2.barHelpers.initialPositions();
        p3 = k2.y, y2 = k2.barHeight, c3 = k2.yDivision, g2 = k2.zeroW, u2 = k2.x, w2 = k2.barWidth, h4 = k2.xDivision, d2 = k2.zeroH, b2.push(u2 + w2 / 2);
        for (var A2 = r2.group({ class: "apexcharts-datalabels", "data:realIndex": v2 }), S2 = function(i4) {
          var r3 = a2.barHelpers.getStrokeWidth(n3, i4, v2), l3 = null, x2 = { indexes: { i: n3, j: i4, realIndex: v2 }, x: u2, y: p3, strokeWidth: r3, elSeries: m2 };
          l3 = a2.isHorizontal ? a2.drawHorizontalBoxPaths(e(e({}, x2), {}, { yDivision: c3, barHeight: y2, zeroW: g2 })) : a2.drawVerticalBoxPaths(e(e({}, x2), {}, { xDivision: h4, barWidth: w2, zeroH: d2 })), p3 = l3.y, u2 = l3.x, i4 > 0 && b2.push(u2 + w2 / 2), f2.push(p3), l3.pathTo.forEach(function(e2, h5) {
            var c4 = !a2.isBoxPlot && a2.candlestickOptions.wick.useFillColor ? l3.color[h5] : s3.globals.stroke.colors[n3], d3 = o2.fillPath({ seriesNumber: v2, dataPointIndex: i4, color: l3.color[h5], value: t3[n3][i4] });
            a2.renderSeries({ realIndex: v2, pathFill: d3, lineFill: c4, j: i4, i: n3, pathFrom: l3.pathFrom, pathTo: e2, strokeWidth: r3, elSeries: m2, x: u2, y: p3, series: t3, barHeight: y2, barWidth: w2, elDataLabelsWrap: A2, visibleSeries: a2.visibleI, type: s3.config.chart.type });
          });
        }, C2 = 0; C2 < s3.globals.dataPoints; C2++)
          S2(C2);
        s3.globals.seriesXvalues[v2] = b2, s3.globals.seriesYvalues[v2] = f2, l2.add(m2);
      }, c2 = 0; c2 < t3.length; c2++)
        h3(c2);
      return l2;
    } }, { key: "drawVerticalBoxPaths", value: function(t3) {
      var e2 = t3.indexes, i3 = t3.x;
      t3.y;
      var a2 = t3.xDivision, s3 = t3.barWidth, r2 = t3.zeroH, o2 = t3.strokeWidth, n2 = this.w, l2 = new m(this.ctx), h3 = e2.i, c2 = e2.j, d2 = true, g2 = n2.config.plotOptions.candlestick.colors.upward, u2 = n2.config.plotOptions.candlestick.colors.downward, p3 = "";
      this.isBoxPlot && (p3 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var f2 = this.yRatio[this.yaxisIndex], x2 = e2.realIndex, b2 = this.getOHLCValue(x2, c2), v2 = r2, y2 = r2;
      b2.o > b2.c && (d2 = false);
      var w2 = Math.min(b2.o, b2.c), k2 = Math.max(b2.o, b2.c), A2 = b2.m;
      n2.globals.isXNumeric && (i3 = (n2.globals.seriesX[x2][c2] - n2.globals.minX) / this.xRatio - s3 / 2);
      var S2 = i3 + s3 * this.visibleI;
      this.series[h3][c2] === void 0 || this.series[h3][c2] === null ? (w2 = r2, k2 = r2) : (w2 = r2 - w2 / f2, k2 = r2 - k2 / f2, v2 = r2 - b2.h / f2, y2 = r2 - b2.l / f2, A2 = r2 - b2.m / f2);
      var C2 = l2.move(S2, r2), L2 = l2.move(S2 + s3 / 2, w2);
      return n2.globals.previousPaths.length > 0 && (L2 = this.getPreviousPath(x2, c2, true)), C2 = this.isBoxPlot ? [l2.move(S2, w2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 4, v2) + l2.line(S2 + s3 - s3 / 4, v2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3, w2) + l2.line(S2 + s3, A2) + l2.line(S2, A2) + l2.line(S2, w2 + o2 / 2), l2.move(S2, A2) + l2.line(S2 + s3, A2) + l2.line(S2 + s3, k2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 - s3 / 4, y2) + l2.line(S2 + s3 / 4, y2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2) + "z"] : [l2.move(S2, k2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3, k2) + l2.line(S2 + s3, w2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2, w2) + l2.line(S2, k2 - o2 / 2)], L2 += l2.move(S2, w2), n2.globals.isXNumeric || (i3 += a2), { pathTo: C2, pathFrom: L2, x: i3, y: k2, barXPosition: S2, color: this.isBoxPlot ? p3 : d2 ? [g2] : [u2] };
    } }, { key: "drawHorizontalBoxPaths", value: function(t3) {
      var e2 = t3.indexes;
      t3.x;
      var i3 = t3.y, a2 = t3.yDivision, s3 = t3.barHeight, r2 = t3.zeroW, o2 = t3.strokeWidth, n2 = this.w, l2 = new m(this.ctx), h3 = e2.i, c2 = e2.j, d2 = this.boxOptions.colors.lower;
      this.isBoxPlot && (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var g2 = this.invertedYRatio, u2 = e2.realIndex, p3 = this.getOHLCValue(u2, c2), f2 = r2, x2 = r2, b2 = Math.min(p3.o, p3.c), v2 = Math.max(p3.o, p3.c), y2 = p3.m;
      n2.globals.isXNumeric && (i3 = (n2.globals.seriesX[u2][c2] - n2.globals.minX) / this.invertedXRatio - s3 / 2);
      var w2 = i3 + s3 * this.visibleI;
      this.series[h3][c2] === void 0 || this.series[h3][c2] === null ? (b2 = r2, v2 = r2) : (b2 = r2 + b2 / g2, v2 = r2 + v2 / g2, f2 = r2 + p3.h / g2, x2 = r2 + p3.l / g2, y2 = r2 + p3.m / g2);
      var k2 = l2.move(r2, w2), A2 = l2.move(b2, w2 + s3 / 2);
      return n2.globals.previousPaths.length > 0 && (A2 = this.getPreviousPath(u2, c2, true)), k2 = [l2.move(b2, w2) + l2.line(b2, w2 + s3 / 2) + l2.line(f2, w2 + s3 / 2) + l2.line(f2, w2 + s3 / 2 - s3 / 4) + l2.line(f2, w2 + s3 / 2 + s3 / 4) + l2.line(f2, w2 + s3 / 2) + l2.line(b2, w2 + s3 / 2) + l2.line(b2, w2 + s3) + l2.line(y2, w2 + s3) + l2.line(y2, w2) + l2.line(b2 + o2 / 2, w2), l2.move(y2, w2) + l2.line(y2, w2 + s3) + l2.line(v2, w2 + s3) + l2.line(v2, w2 + s3 / 2) + l2.line(x2, w2 + s3 / 2) + l2.line(x2, w2 + s3 - s3 / 4) + l2.line(x2, w2 + s3 / 4) + l2.line(x2, w2 + s3 / 2) + l2.line(v2, w2 + s3 / 2) + l2.line(v2, w2) + l2.line(y2, w2) + "z"], A2 += l2.move(b2, w2), n2.globals.isXNumeric || (i3 += a2), { pathTo: k2, pathFrom: A2, x: v2, y: i3, barYPosition: w2, color: d2 };
    } }, { key: "getOHLCValue", value: function(t3, e2) {
      var i3 = this.w;
      return { o: this.isBoxPlot ? i3.globals.seriesCandleH[t3][e2] : i3.globals.seriesCandleO[t3][e2], h: this.isBoxPlot ? i3.globals.seriesCandleO[t3][e2] : i3.globals.seriesCandleH[t3][e2], m: i3.globals.seriesCandleM[t3][e2], l: this.isBoxPlot ? i3.globals.seriesCandleC[t3][e2] : i3.globals.seriesCandleL[t3][e2], c: this.isBoxPlot ? i3.globals.seriesCandleL[t3][e2] : i3.globals.seriesCandleC[t3][e2] };
    } }]), s2;
  }(), kt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "checkColorRange", value: function() {
      var t3 = this.w, e2 = false, i2 = t3.config.plotOptions[t3.config.chart.type];
      return i2.colorScale.ranges.length > 0 && i2.colorScale.ranges.map(function(t4, i3) {
        t4.from <= 0 && (e2 = true);
      }), e2;
    } }, { key: "getShadeColor", value: function(t3, e2, i2, a2) {
      var s2 = this.w, r2 = 1, o2 = s2.config.plotOptions[t3].shadeIntensity, n2 = this.determineColor(t3, e2, i2);
      s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? n2.percent < 0 ? n2.percent / 100 * (1.25 * o2) : (1 - n2.percent / 100) * (1.25 * o2) : n2.percent <= 0 ? 1 - (1 + n2.percent / 100) * o2 : (1 - n2.percent / 100) * o2 : (r2 = 1 - n2.percent / 100, t3 === "treemap" && (r2 = (1 - n2.percent / 100) * (1.25 * o2)));
      var l2 = n2.color, h3 = new x();
      return s2.config.plotOptions[t3].enableShades && (l2 = this.w.config.theme.mode === "dark" ? x.hexToRgba(h3.shadeColor(-1 * r2, n2.color), s2.config.fill.opacity) : x.hexToRgba(h3.shadeColor(r2, n2.color), s2.config.fill.opacity)), { color: l2, colorProps: n2 };
    } }, { key: "determineColor", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = a2.globals.series[e2][i2], r2 = a2.config.plotOptions[t3], o2 = r2.colorScale.inverse ? i2 : e2;
      r2.distributed && a2.config.chart.type === "treemap" && (o2 = i2);
      var n2 = a2.globals.colors[o2], l2 = null, h3 = Math.min.apply(Math, u(a2.globals.series[e2])), c2 = Math.max.apply(Math, u(a2.globals.series[e2]));
      r2.distributed || t3 !== "heatmap" || (h3 = a2.globals.minY, c2 = a2.globals.maxY), r2.colorScale.min !== void 0 && (h3 = r2.colorScale.min < a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max > a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
      var d2 = Math.abs(c2) + Math.abs(h3), g2 = 100 * s2 / (d2 === 0 ? d2 - 1e-6 : d2);
      r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map(function(t4, e3) {
        if (s2 >= t4.from && s2 <= t4.to) {
          n2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h3 = t4.from, c2 = t4.to;
          var i3 = Math.abs(c2) + Math.abs(h3);
          g2 = 100 * s2 / (i3 === 0 ? i3 - 1e-6 : i3);
        }
      });
      return { color: n2, foreColor: l2, percent: g2 };
    } }, { key: "calculateDataLabels", value: function(t3) {
      var e2 = t3.text, i2 = t3.x, a2 = t3.y, s2 = t3.i, r2 = t3.j, o2 = t3.colorProps, n2 = t3.fontSize, l2 = this.w.config.dataLabels, h3 = new m(this.ctx), c2 = new z(this.ctx), d2 = null;
      if (l2.enabled) {
        d2 = h3.group({ class: "apexcharts-data-labels" });
        var g2 = l2.offsetX, u2 = l2.offsetY, p3 = i2 + g2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + u2;
        c2.plotDataLabelsText({ x: p3, y: f2, text: e2, i: s2, j: r2, color: o2.foreColor, parent: d2, fontSize: n2, dataLabelsConfig: l2 });
      }
      return d2;
    } }, { key: "addListeners", value: function(t3) {
      var e2 = new m(this.ctx);
      t3.node.addEventListener("mouseenter", e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mousedown", e2.pathMouseDown.bind(this, t3));
    } }]), t2;
  }(), At = function() {
    function t2(e2, i2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = i2.xRatio, this.yRatio = i2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new kt(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return r(t2, [{ key: "draw", value: function(t3) {
      var e2 = this.w, i2 = new m(this.ctx), a2 = i2.group({ class: "apexcharts-heatmap" });
      a2.attr("clip-path", "url(#gridRectMask".concat(e2.globals.cuid, ")"));
      var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, o2 = 0, n2 = false;
      this.negRange = this.helpers.checkColorRange();
      var l2 = t3.slice();
      e2.config.yaxis[0].reversed && (n2 = true, l2.reverse());
      for (var h3 = n2 ? 0 : l2.length - 1; n2 ? h3 < l2.length : h3 >= 0; n2 ? h3++ : h3--) {
        var c2 = i2.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: x.escapeString(e2.globals.seriesNames[h3]), rel: h3 + 1, "data:realIndex": h3 });
        if (this.ctx.series.addCollapsedClassToSeries(c2, h3), e2.config.chart.dropShadow.enabled) {
          var d2 = e2.config.chart.dropShadow;
          new v(this.ctx).dropShadow(c2, d2, h3);
        }
        for (var g2 = 0, u2 = e2.config.plotOptions.heatmap.shadeIntensity, p3 = 0; p3 < l2[h3].length; p3++) {
          var f2 = this.helpers.getShadeColor(e2.config.chart.type, h3, p3, this.negRange), b2 = f2.color, y2 = f2.colorProps;
          if (e2.config.fill.type === "image")
            b2 = new T(this.ctx).fillPath({ seriesNumber: h3, dataPointIndex: p3, opacity: e2.globals.hasNegs ? y2.percent < 0 ? 1 - (1 + y2.percent / 100) : u2 + y2.percent / 100 : y2.percent / 100, patternID: x.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
          var w2 = this.rectRadius, k2 = i2.drawRect(g2, o2, s2, r2, w2);
          if (k2.attr({ cx: g2, cy: o2 }), k2.node.classList.add("apexcharts-heatmap-rect"), c2.add(k2), k2.attr({ fill: b2, i: h3, index: h3, j: p3, val: l2[h3][p3], "stroke-width": this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(k2), e2.config.chart.animations.enabled && !e2.globals.dataChanged) {
            var A2 = 1;
            e2.globals.resized || (A2 = e2.config.chart.animations.speed), this.animateHeatMap(k2, g2, o2, s2, r2, A2);
          }
          if (e2.globals.dataChanged) {
            var S2 = 1;
            if (this.dynamicAnim.enabled && e2.globals.shouldAnimate) {
              S2 = this.dynamicAnim.speed;
              var C2 = e2.globals.previousPaths[h3] && e2.globals.previousPaths[h3][p3] && e2.globals.previousPaths[h3][p3].color;
              C2 || (C2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k2, x.isColorHex(C2) ? C2 : x.rgb2hex(C2), x.isColorHex(b2) ? b2 : x.rgb2hex(b2), S2);
            }
          }
          var L2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h3][p3], { value: e2.globals.series[h3][p3], seriesIndex: h3, dataPointIndex: p3, w: e2 }), P2 = this.helpers.calculateDataLabels({ text: L2, x: g2 + s2 / 2, y: o2 + r2 / 2, i: h3, j: p3, colorProps: y2, series: l2 });
          P2 !== null && c2.add(P2), g2 += s2;
        }
        o2 += r2, a2.add(c2);
      }
      var M2 = e2.globals.yAxisScale[0].result.slice();
      e2.config.yaxis[0].reversed ? M2.unshift("") : M2.push(""), e2.globals.yAxisScale[0].result = M2;
      var I2 = e2.globals.gridHeight / e2.globals.series.length;
      return e2.config.yaxis[0].labels.offsetY = -I2 / 2, a2;
    } }, { key: "animateHeatMap", value: function(t3, e2, i2, a2, s2, r2) {
      var o2 = new b(this.ctx);
      o2.animateRect(t3, { x: e2 + a2 / 2, y: i2 + s2 / 2, width: 0, height: 0 }, { x: e2, y: i2, width: a2, height: s2 }, r2, function() {
        o2.animationCompleted(t3);
      });
    } }, { key: "animateHeatColor", value: function(t3, e2, i2, a2) {
      t3.attr({ fill: e2 }).animate(a2).attr({ fill: i2 });
    } }]), t2;
  }(), St = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "drawYAxisTexts", value: function(t3, e2, i2, a2) {
      var s2 = this.w, r2 = s2.config.yaxis[0], o2 = s2.globals.yLabelFormatters[0];
      return new m(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: o2(a2, i2), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
    } }]), t2;
  }(), Ct = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
      var i2 = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = i2.globals.stroke.colors !== void 0 ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = Math.min(i2.globals.gridWidth, i2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i2.globals.gridWidth / 2, i2.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(i2.config.plotOptions.pie.endAngle - i2.config.plotOptions.pie.startAngle), this.initialAngle = i2.config.plotOptions.pie.startAngle % this.fullAngle, i2.globals.radialSize = this.defaultSize / 2.05 - i2.config.stroke.width - (i2.config.chart.sparkline.enabled ? 0 : i2.config.chart.dropShadow.blur), this.donutSize = i2.globals.radialSize * parseInt(i2.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return r(t2, [{ key: "draw", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = new m(this.ctx);
      if (this.ret = a2.group({ class: "apexcharts-pie" }), i2.globals.noData)
        return this.ret;
      for (var s2 = 0, r2 = 0; r2 < t3.length; r2++)
        s2 += x.negToZero(t3[r2]);
      var o2 = [], n2 = a2.group();
      s2 === 0 && (s2 = 1e-5), t3.forEach(function(t4) {
        e2.maxY = Math.max(e2.maxY, t4);
      }), i2.config.yaxis[0].max && (this.maxY = i2.config.yaxis[0].max), i2.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
      for (var l2 = 0; l2 < t3.length; l2++) {
        var h3 = this.fullAngle * x.negToZero(t3[l2]) / s2;
        o2.push(h3), this.chartType === "polarArea" ? (o2[l2] = this.fullAngle / t3.length, this.sliceSizes.push(i2.globals.radialSize * t3[l2] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
      }
      if (i2.globals.dataChanged) {
        for (var c2, d2 = 0, g2 = 0; g2 < i2.globals.previousPaths.length; g2++)
          d2 += x.negToZero(i2.globals.previousPaths[g2]);
        for (var u2 = 0; u2 < i2.globals.previousPaths.length; u2++)
          c2 = this.fullAngle * x.negToZero(i2.globals.previousPaths[u2]) / d2, this.prevSectorAngleArr.push(c2);
      }
      this.donutSize < 0 && (this.donutSize = 0);
      var p3 = i2.config.plotOptions.pie.customScale, f2 = i2.globals.gridWidth / 2, b2 = i2.globals.gridHeight / 2, v2 = f2 - i2.globals.gridWidth / 2 * p3, y2 = b2 - i2.globals.gridHeight / 2 * p3;
      if (this.chartType === "donut") {
        var w2 = a2.drawCircle(this.donutSize);
        w2.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : "transparent" }), n2.add(w2);
      }
      var k2 = this.drawArcs(o2, t3);
      if (this.sliceLabels.forEach(function(t4) {
        k2.add(t4);
      }), n2.attr({ transform: "translate(".concat(v2, ", ").concat(y2, ") scale(").concat(p3, ")") }), n2.add(k2), this.ret.add(n2), this.donutDataLabels.show) {
        var A2 = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: v2, translateY: y2 });
        this.ret.add(A2);
      }
      return i2.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret;
    } }, { key: "drawArcs", value: function(t3, e2) {
      var i2 = this.w, a2 = new v(this.ctx), s2 = new m(this.ctx), r2 = new T(this.ctx), o2 = s2.group({ class: "apexcharts-slices" }), n2 = this.initialAngle, l2 = this.initialAngle, h3 = this.initialAngle, c2 = this.initialAngle;
      this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
      for (var d2 = 0; d2 < t3.length; d2++) {
        var g2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: x.escapeString(i2.globals.seriesNames[d2]), rel: d2 + 1, "data:realIndex": d2 });
        o2.add(g2), l2 = c2, h3 = (n2 = h3) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
        var u2 = h3 < n2 ? this.fullAngle + h3 - n2 : h3 - n2, p3 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), b2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p3, fillOpacity: i2.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d2) });
        if (b2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(b2, 0, d2), i2.config.chart.dropShadow.enabled) {
          var y2 = i2.config.chart.dropShadow;
          a2.dropShadow(b2, y2, d2);
        }
        this.addListeners(b2, this.donutDataLabels), m.setAttrs(b2.node, { "data:angle": u2, "data:startAngle": n2, "data:strokeWidth": this.strokeWidth, "data:value": e2[d2] });
        var w2 = { x: 0, y: 0 };
        this.chartType === "pie" || this.chartType === "polarArea" ? w2 = x.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (n2 + u2 / 2) % this.fullAngle) : this.chartType === "donut" && (w2 = x.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (n2 + u2 / 2) % this.fullAngle)), g2.add(b2);
        var k2 = 0;
        if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : ((k2 = u2 / this.fullAngle * i2.config.chart.animations.speed) === 0 && (k2 = 1), this.animDur = k2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i2.globals.dataChanged ? this.animatePaths(b2, { size: this.sliceSizes[d2], endAngle: h3, startAngle: n2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(b2, { size: this.sliceSizes[d2], endAngle: h3, startAngle: n2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: k2 }), i2.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && b2.click(this.pieClicked.bind(this, d2)), i2.globals.selectedDataPoints[0] !== void 0 && i2.globals.selectedDataPoints[0].indexOf(d2) > -1 && this.pieClicked(d2), i2.config.dataLabels.enabled) {
          var A2 = w2.x, S2 = w2.y, C2 = 100 * u2 / this.fullAngle + "%";
          if (u2 !== 0 && i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t3[d2]) {
            var L2 = i2.config.dataLabels.formatter;
            L2 !== void 0 && (C2 = L2(i2.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i2 }));
            var P2 = i2.globals.dataLabels.style.colors[d2], M2 = s2.group({ class: "apexcharts-datalabels" }), I2 = s2.drawText({ x: A2, y: S2, text: C2, textAnchor: "middle", fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: P2 });
            if (M2.add(I2), i2.config.dataLabels.dropShadow.enabled) {
              var z2 = i2.config.dataLabels.dropShadow;
              a2.dropShadow(I2, z2);
            }
            I2.node.classList.add("apexcharts-pie-label"), i2.config.chart.animations.animate && i2.globals.resized === false && (I2.node.classList.add("apexcharts-pie-label-delay"), I2.node.style.animationDelay = i2.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(M2);
          }
        }
      }
      return o2;
    } }, { key: "addListeners", value: function(t3, e2) {
      var i2 = new m(this.ctx);
      t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t3.node, e2)));
    } }, { key: "animatePaths", value: function(t3, e2) {
      var i2 = this.w, a2 = e2.endAngle < e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, o2 = e2.startAngle;
      e2.prevStartAngle !== void 0 && e2.prevEndAngle !== void 0 && (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle < e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i2.config.series.length - 1 && (a2 + o2 > this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + o2) : a2 + o2 < this.fullAngle && (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + o2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, o2, a2, s2, e2);
    } }, { key: "animateArc", value: function(t3, e2, i2, a2, s2, r2) {
      var o2, n2 = this, l2 = this.w, h3 = new b(this.ctx), c2 = r2.size;
      (isNaN(e2) || isNaN(s2)) && (e2 = i2, s2 = a2, r2.dur = 0);
      var d2 = a2, g2 = i2, u2 = e2 < i2 ? this.fullAngle + e2 - i2 : e2 - i2;
      l2.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (o2 = n2.getPiePath({ me: n2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: o2 })), r2.dur !== 0 ? t3.animate(r2.dur, l2.globals.easing, r2.animBeginArr[r2.i]).afterAll(function() {
        n2.chartType !== "pie" && n2.chartType !== "donut" && n2.chartType !== "polarArea" || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": n2.strokeWidth }), r2.i === l2.config.series.length - 1 && h3.animationCompleted(t3);
      }).during(function(l3) {
        d2 = u2 + (a2 - u2) * l3, r2.animateStartingPos && (d2 = s2 + (a2 - s2) * l3, g2 = e2 - s2 + (i2 - (e2 - s2)) * l3), o2 = n2.getPiePath({ me: n2, startAngle: g2, angle: d2, size: c2 }), t3.node.setAttribute("data:pathOrig", o2), t3.attr({ d: o2 });
      }) : (o2 = n2.getPiePath({ me: n2, startAngle: g2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute("data:pathOrig", o2), t3.attr({ d: o2, "stroke-width": n2.strokeWidth }));
    } }, { key: "pieClicked", value: function(t3) {
      var e2, i2 = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.select(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(t3)).members[0];
      if (r2.attr("data:pieClicked") !== "true") {
        var o2 = i2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(o2, function(t4) {
          t4.setAttribute("data:pieClicked", "false");
          var e3 = t4.getAttribute("data:pathOrig");
          t4.setAttribute("d", e3);
        }), r2.attr("data:pieClicked", "true");
        var n2 = parseInt(r2.attr("data:startAngle"), 10), l2 = parseInt(r2.attr("data:angle"), 10);
        e2 = a2.getPiePath({ me: a2, startAngle: n2, angle: l2, size: s2 }), l2 !== 360 && r2.plot(e2);
      } else {
        r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
        var h3 = r2.attr("data:pathOrig");
        r2.attr({ d: h3 });
      }
    } }, { key: "getChangedPath", value: function(t3, e2) {
      var i2 = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i2 = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i2;
    } }, { key: "getPiePath", value: function(t3) {
      var e2 = t3.me, i2 = t3.startAngle, a2 = t3.angle, s2 = t3.size, r2 = i2, o2 = Math.PI * (r2 - 90) / 180, n2 = a2 + i2;
      Math.ceil(n2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (n2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(n2) > this.fullAngle && (n2 -= this.fullAngle);
      var l2 = Math.PI * (n2 - 90) / 180, h3 = e2.centerX + s2 * Math.cos(o2), c2 = e2.centerY + s2 * Math.sin(o2), d2 = e2.centerX + s2 * Math.cos(l2), g2 = e2.centerY + s2 * Math.sin(l2), u2 = x.polarToCartesian(e2.centerX, e2.centerY, e2.donutSize, n2), p3 = x.polarToCartesian(e2.centerX, e2.centerY, e2.donutSize, r2), f2 = a2 > 180 ? 1 : 0, b2 = ["M", h3, c2, "A", s2, s2, 0, f2, 1, d2, g2];
      return e2.chartType === "donut" ? [].concat(b2, ["L", u2.x, u2.y, "A", e2.donutSize, e2.donutSize, 0, f2, 0, p3.x, p3.y, "L", h3, c2, "z"]).join(" ") : e2.chartType === "pie" || e2.chartType === "polarArea" ? [].concat(b2, ["L", e2.centerX, e2.centerY, "L", h3, c2]).join(" ") : [].concat(b2).join(" ");
    } }, { key: "drawPolarElements", value: function(t3) {
      var e2 = this.w, i2 = new q(this.ctx), a2 = new m(this.ctx), s2 = new St(this.ctx), r2 = a2.group(), o2 = a2.group(), n2 = i2.niceScale(0, Math.ceil(this.maxY), e2.config.yaxis[0].tickAmount, 0, true), l2 = n2.result.reverse(), h3 = n2.result.length;
      this.maxY = n2.niceMax;
      for (var c2 = e2.globals.radialSize, d2 = c2 / (h3 - 1), g2 = 0; g2 < h3 - 1; g2++) {
        var u2 = a2.drawCircle(c2);
        if (u2.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
          var p3 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, g2, l2[g2]);
          o2.add(p3);
        }
        r2.add(u2), c2 -= d2;
      }
      this.drawSpokes(t3), t3.add(r2), t3.add(o2);
    } }, { key: "renderInnerDataLabels", value: function(t3, e2) {
      var i2 = this.w, a2 = new m(this.ctx), s2 = a2.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(e2.translateX ? e2.translateX : 0, ", ").concat(e2.translateY ? e2.translateY : 0, ") scale(").concat(i2.config.plotOptions.pie.customScale, ")") }), r2 = t3.total.show;
      s2.node.style.opacity = e2.opacity;
      var o2, n2, l2 = e2.centerX, h3 = e2.centerY;
      o2 = t3.name.color === void 0 ? i2.globals.colors[0] : t3.name.color;
      var c2 = t3.name.fontSize, d2 = t3.name.fontFamily, g2 = t3.name.fontWeight;
      n2 = t3.value.color === void 0 ? i2.config.chart.foreColor : t3.value.color;
      var u2 = t3.value.formatter, p3 = "", f2 = "";
      if (r2 ? (o2 = t3.total.color, c2 = t3.total.fontSize, d2 = t3.total.fontFamily, g2 = t3.total.fontWeight, f2 = t3.total.label, p3 = t3.total.formatter(i2)) : i2.globals.series.length === 1 && (p3 = u2(i2.globals.series[0], i2), f2 = i2.globals.seriesNames[0]), f2 && (f2 = t3.name.formatter(f2, t3.total.show, i2)), t3.name.show) {
        var x2 = a2.drawText({ x: l2, y: h3 + parseFloat(t3.name.offsetY), text: f2, textAnchor: "middle", foreColor: o2, fontSize: c2, fontWeight: g2, fontFamily: d2 });
        x2.node.classList.add("apexcharts-datalabel-label"), s2.add(x2);
      }
      if (t3.value.show) {
        var b2 = t3.name.show ? parseFloat(t3.value.offsetY) + 16 : t3.value.offsetY, v2 = a2.drawText({ x: l2, y: h3 + b2, text: p3, textAnchor: "middle", foreColor: n2, fontWeight: t3.value.fontWeight, fontSize: t3.value.fontSize, fontFamily: t3.value.fontFamily });
        v2.node.classList.add("apexcharts-datalabel-value"), s2.add(v2);
      }
      return s2;
    } }, { key: "printInnerLabels", value: function(t3, e2, i2, a2) {
      var s2, r2 = this.w;
      a2 ? s2 = t3.name.color === void 0 ? r2.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : t3.name.color : r2.globals.series.length > 1 && t3.total.show && (s2 = t3.total.color);
      var o2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i2 = (0, t3.value.formatter)(i2, r2), a2 || typeof t3.total.formatter != "function" || (i2 = t3.total.formatter(r2));
      var l2 = e2 === t3.total.label;
      e2 = t3.name.formatter(e2, l2, r2), o2 !== null && (o2.textContent = e2), n2 !== null && (n2.textContent = i2), o2 !== null && (o2.style.fill = s2);
    } }, { key: "printDataLabelsInner", value: function(t3, e2) {
      var i2 = this.w, a2 = t3.getAttribute("data:value"), s2 = i2.globals.seriesNames[parseInt(t3.parentNode.getAttribute("rel"), 10) - 1];
      i2.globals.series.length > 1 && this.printInnerLabels(e2, s2, a2, t3);
      var r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      r2 !== null && (r2.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = i2.config.plotOptions.polarArea.spokes;
      if (s2.strokeWidth !== 0) {
        for (var r2 = [], o2 = 360 / i2.globals.series.length, n2 = 0; n2 < i2.globals.series.length; n2++)
          r2.push(x.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + o2 * n2));
        r2.forEach(function(i3, r3) {
          var o3 = a2.drawLine(i3.x, i3.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
          t3.add(o3);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function(t3, e2, i2) {
      var a2 = this, s2 = this.w, r2 = s2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), o2 = false, n2 = s2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), l2 = function(t4) {
        var i3 = t4.makeSliceOut, s3 = t4.printLabel;
        Array.prototype.forEach.call(n2, function(t5) {
          t5.getAttribute("data:pieClicked") === "true" && (i3 && (o2 = true), s3 && a2.printDataLabelsInner(t5, e2));
        });
      };
      if (l2({ makeSliceOut: true, printLabel: false }), e2.total.show && s2.globals.series.length > 1)
        o2 && !e2.total.showAlways ? l2({ makeSliceOut: false, printLabel: true }) : this.printInnerLabels(e2, e2.total.label, e2.total.formatter(s2));
      else if (l2({ makeSliceOut: false, printLabel: true }), !o2)
        if (s2.globals.selectedDataPoints.length && s2.globals.series.length > 1)
          if (s2.globals.selectedDataPoints[0].length > 0) {
            var h3 = s2.globals.selectedDataPoints[0], c2 = s2.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(h3));
            this.printDataLabelsInner(c2, e2);
          } else
            r2 && s2.globals.selectedDataPoints.length && s2.globals.selectedDataPoints[0].length === 0 && (r2.style.opacity = 0);
        else
          r2 && s2.globals.series.length > 1 && (r2.style.opacity = 0);
    } }]), t2;
  }(), Lt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var i2 = this.w;
      this.graphics = new m(this.ctx), this.lineColorArr = i2.globals.stroke.colors !== void 0 ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = i2.globals.svgHeight < i2.globals.svgWidth ? i2.globals.gridHeight + 1.5 * i2.globals.goldenPadding : i2.globals.gridWidth, this.isLog = i2.config.yaxis[0].logarithmic, this.coreUtils = new y(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(i2.globals.maxY, 0) : i2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i2.globals.minY, this.polygons = i2.config.plotOptions.radar.polygons, this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i2.config.chart.dropShadow.blur, i2.config.xaxis.labels.show && (this.size = this.size - i2.globals.xAxisLabelsWidth / 1.75), i2.config.plotOptions.radar.size !== void 0 && (this.size = i2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return r(t2, [{ key: "draw", value: function(t3) {
      var i2 = this, a2 = this.w, s2 = new T(this.ctx), r2 = [], o2 = new z(this.ctx);
      t3.length && (this.dataPointsLen = t3[a2.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var n2 = a2.globals.gridWidth / 2, l2 = a2.globals.gridHeight / 2, h3 = n2 + a2.config.plotOptions.radar.offsetX, c2 = l2 + a2.config.plotOptions.radar.offsetY, d2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(h3 || 0, ", ").concat(c2 || 0, ")") }), g2 = [], u2 = null, p3 = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t3.forEach(function(t4, n3) {
        var l3 = t4.length === a2.globals.dataPoints, h4 = i2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": l3, seriesName: x.escapeString(a2.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
        i2.dataRadiusOfPercent[n3] = [], i2.dataRadius[n3] = [], i2.angleArr[n3] = [], t4.forEach(function(t5, e2) {
          var a3 = Math.abs(i2.maxValue - i2.minValue);
          t5 += Math.abs(i2.minValue), i2.isLog && (t5 = i2.coreUtils.getLogVal(t5, 0)), i2.dataRadiusOfPercent[n3][e2] = t5 / a3, i2.dataRadius[n3][e2] = i2.dataRadiusOfPercent[n3][e2] * i2.size, i2.angleArr[n3][e2] = e2 * i2.disAngle;
        }), g2 = i2.getDataPointsPos(i2.dataRadius[n3], i2.angleArr[n3]);
        var c3 = i2.createPaths(g2, { x: 0, y: 0 });
        u2 = i2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p3 = i2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n3 }), a2.globals.delayedElements.push({ el: u2.node, index: n3 });
        var d3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: a2.config.chart.animations.speed, dataChangeSpeed: a2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: a2.globals.stroke.colors[n3], strokeLineCap: a2.config.stroke.lineCap }, f3 = null;
        a2.globals.previousPaths.length > 0 && (f3 = i2.getPreviousPath(n3));
        for (var b2 = 0; b2 < c3.linePathsTo.length; b2++) {
          var m2 = i2.graphics.renderPaths(e(e({}, d3), {}, { pathFrom: f3 === null ? c3.linePathsFrom[b2] : f3, pathTo: c3.linePathsTo[b2], strokeWidth: Array.isArray(i2.strokeWidth) ? i2.strokeWidth[n3] : i2.strokeWidth, fill: "none", drawShadow: false }));
          h4.add(m2);
          var y2 = s2.fillPath({ seriesNumber: n3 }), w2 = i2.graphics.renderPaths(e(e({}, d3), {}, { pathFrom: f3 === null ? c3.areaPathsFrom[b2] : f3, pathTo: c3.areaPathsTo[b2], strokeWidth: 0, fill: y2, drawShadow: false }));
          if (a2.config.chart.dropShadow.enabled) {
            var k2 = new v(i2.ctx), A2 = a2.config.chart.dropShadow;
            k2.dropShadow(w2, Object.assign({}, A2, { noUserSpaceOnUse: true }), n3);
          }
          h4.add(w2);
        }
        t4.forEach(function(t5, s3) {
          var r3 = new M(i2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: s3 }), l4 = i2.graphics.drawMarker(g2[s3].x, g2[s3].y, r3);
          l4.attr("rel", s3), l4.attr("j", s3), l4.attr("index", n3), l4.node.setAttribute("default-marker-size", r3.pSize);
          var c4 = i2.graphics.group({ class: "apexcharts-series-markers" });
          c4 && c4.add(l4), u2.add(c4), h4.add(u2);
          var d4 = a2.config.dataLabels;
          if (d4.enabled) {
            var f4 = d4.formatter(a2.globals.series[n3][s3], { seriesIndex: n3, dataPointIndex: s3, w: a2 });
            o2.plotDataLabelsText({ x: g2[s3].x, y: g2[s3].y, text: f4, textAnchor: "middle", i: n3, j: n3, parent: p3, offsetCorrection: false, dataLabelsConfig: e({}, d4) });
          }
          h4.add(p3);
        }), r2.push(h4);
      }), this.drawPolygons({ parent: d2 }), a2.config.xaxis.labels.show) {
        var f2 = this.drawXAxisTexts();
        d2.add(f2);
      }
      return r2.forEach(function(t4) {
        d2.add(t4);
      }), d2.add(this.yaxisLabels), d2;
    } }, { key: "drawPolygons", value: function(t3) {
      for (var e2 = this, i2 = this.w, a2 = t3.parent, s2 = new St(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), o2 = r2.length, n2 = [], l2 = this.size / (o2 - 1), h3 = 0; h3 < o2; h3++)
        n2[h3] = l2 * h3;
      n2.reverse();
      var c2 = [], d2 = [];
      n2.forEach(function(t4, i3) {
        var a3 = x.getPolygonPos(t4, e2.dataPointsLen), s3 = "";
        a3.forEach(function(t5, a4) {
          if (i3 === 0) {
            var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
            d2.push(r3);
          }
          a4 === 0 && e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + "," + t5.y + " ";
        }), c2.push(s3);
      }), c2.forEach(function(t4, s3) {
        var r3 = e2.polygons.strokeColors, o3 = e2.polygons.strokeWidth, n3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(o3) ? o3[s3] : o3, i2.globals.radarPolygons.fill.colors[s3]);
        a2.add(n3);
      }), d2.forEach(function(t4) {
        a2.add(t4);
      }), i2.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t4, i3) {
        var a3 = s2.drawYAxisTexts(t4.x, t4.y, i3, r2[i3]);
        e2.yaxisLabels.add(a3);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var t3 = this, i2 = this.w, a2 = i2.config.xaxis.labels, s2 = this.graphics.group({ class: "apexcharts-xaxis" }), r2 = x.getPolygonPos(this.size, this.dataPointsLen);
      return i2.globals.labels.forEach(function(o2, n2) {
        var l2 = i2.config.xaxis.labels.formatter, h3 = new z(t3.ctx);
        if (r2[n2]) {
          var c2 = t3.getTextPos(r2[n2], t3.size), d2 = l2(o2, { seriesIndex: -1, dataPointIndex: n2, w: i2 });
          h3.plotDataLabelsText({ x: c2.newX, y: c2.newY, text: d2, textAnchor: c2.textAnchor, i: n2, j: n2, parent: s2, color: Array.isArray(a2.style.colors) && a2.style.colors[n2] ? a2.style.colors[n2] : "#a8a8a8", dataLabelsConfig: e({ textAnchor: c2.textAnchor, dropShadow: { enabled: false } }, a2), offsetCorrection: false });
        }
      }), s2;
    } }, { key: "createPaths", value: function(t3, e2) {
      var i2 = this, a2 = [], s2 = [], r2 = [], o2 = [];
      if (t3.length) {
        s2 = [this.graphics.move(e2.x, e2.y)], o2 = [this.graphics.move(e2.x, e2.y)];
        var n2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
        t3.forEach(function(e3, a3) {
          n2 += i2.graphics.line(e3.x, e3.y), l2 += i2.graphics.line(e3.x, e3.y), a3 === t3.length - 1 && (n2 += "Z", l2 += "Z");
        }), a2.push(n2), r2.push(l2);
      }
      return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: o2, areaPathsTo: r2 };
    } }, { key: "getTextPos", value: function(t3, e2) {
      var i2 = "middle", a2 = t3.x, s2 = t3.y;
      return Math.abs(t3.x) >= 10 ? t3.x > 0 ? (i2 = "start", a2 += 10) : t3.x < 0 && (i2 = "end", a2 -= 10) : i2 = "middle", Math.abs(t3.y) >= e2 - 10 && (t3.y < 0 ? s2 -= 10 : t3.y > 0 && (s2 += 10)), { textAnchor: i2, newX: a2, newY: s2 };
    } }, { key: "getPreviousPath", value: function(t3) {
      for (var e2 = this.w, i2 = null, a2 = 0; a2 < e2.globals.previousPaths.length; a2++) {
        var s2 = e2.globals.previousPaths[a2];
        s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(t3, 10) && e2.globals.previousPaths[a2].paths[0] !== void 0 && (i2 = e2.globals.previousPaths[a2].paths[0].d);
      }
      return i2;
    } }, { key: "getDataPointsPos", value: function(t3, e2) {
      var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
      t3 = t3 || [], e2 = e2 || [];
      for (var a2 = [], s2 = 0; s2 < i2; s2++) {
        var r2 = {};
        r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
      }
      return a2;
    } }]), t2;
  }(), Pt = function(t2) {
    n(i2, Ct);
    var e2 = d(i2);
    function i2(t3) {
      var s2;
      a(this, i2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
      var r2 = s2.w;
      return s2.startAngle = r2.config.plotOptions.radialBar.startAngle, s2.endAngle = r2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(r2.config.plotOptions.radialBar.endAngle - r2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = r2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = r2.config.plotOptions.radialBar.track.endAngle, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), s2.endAngle === 360 && (s2.endAngle = 359.99), s2.margin = parseInt(r2.config.plotOptions.radialBar.track.margin, 10), s2;
    }
    return r(i2, [{ key: "draw", value: function(t3) {
      var e3 = this.w, i3 = new m(this.ctx), a2 = i3.group({ class: "apexcharts-radialbar" });
      if (e3.globals.noData)
        return a2;
      var s2 = i3.group(), r2 = this.defaultSize / 2, o2 = e3.globals.gridWidth / 2, n2 = this.defaultSize / 2.05;
      e3.config.chart.sparkline.enabled || (n2 = n2 - e3.config.stroke.width - e3.config.chart.dropShadow.blur);
      var l2 = e3.globals.fill.colors;
      if (e3.config.plotOptions.radialBar.track.show) {
        var h3 = this.drawTracks({ size: n2, centerX: o2, centerY: r2, colorArr: l2, series: t3 });
        s2.add(h3);
      }
      var c2 = this.drawArcs({ size: n2, centerX: o2, centerY: r2, colorArr: l2, series: t3 }), d2 = 360;
      e3.config.plotOptions.radialBar.startAngle < 0 && (d2 = this.totalAngle);
      var g2 = (360 - d2) / 360;
      if (e3.globals.radialSize = n2 - n2 * g2, this.radialDataLabels.value.show) {
        var u2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        e3.globals.radialSize += u2 * g2;
      }
      return s2.add(c2.g), e3.config.plotOptions.radialBar.hollow.position === "front" && (c2.g.add(c2.elHollow), c2.dataLabels && c2.g.add(c2.dataLabels)), a2.add(s2), a2;
    } }, { key: "drawTracks", value: function(t3) {
      var e3 = this.w, i3 = new m(this.ctx), a2 = i3.group({ class: "apexcharts-tracks" }), s2 = new v(this.ctx), r2 = new T(this.ctx), o2 = this.getStrokeWidth(t3);
      t3.size = t3.size - o2 / 2;
      for (var n2 = 0; n2 < t3.series.length; n2++) {
        var l2 = i3.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        a2.add(l2), l2.attr({ rel: n2 + 1 }), t3.size = t3.size - o2 - this.margin;
        var h3 = e3.config.plotOptions.radialBar.track, c2 = r2.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h3.background) ? h3.background[n2] : h3.background, solid: true }), d2 = this.trackStartAngle, g2 = this.trackEndAngle;
        Math.abs(g2) + Math.abs(d2) >= 360 && (g2 = 360 - Math.abs(this.startAngle) - 0.1);
        var u2 = i3.drawPath({ d: "", stroke: c2, strokeWidth: o2 * parseInt(h3.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h3.opacity, classes: "apexcharts-radialbar-area" });
        if (h3.dropShadow.enabled) {
          var p3 = h3.dropShadow;
          s2.dropShadow(u2, p3);
        }
        l2.add(u2), u2.attr("id", "apexcharts-radialbarTrack-" + n2), this.animatePaths(u2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: g2, startAngle: d2, size: t3.size, i: n2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e3.globals.easing });
      }
      return a2;
    } }, { key: "drawArcs", value: function(t3) {
      var e3 = this.w, i3 = new m(this.ctx), a2 = new T(this.ctx), s2 = new v(this.ctx), r2 = i3.group(), o2 = this.getStrokeWidth(t3);
      t3.size = t3.size - o2 / 2;
      var n2 = e3.config.plotOptions.radialBar.hollow.background, l2 = t3.size - o2 * t3.series.length - this.margin * t3.series.length - o2 * parseInt(e3.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h3 = l2 - e3.config.plotOptions.radialBar.hollow.margin;
      e3.config.plotOptions.radialBar.hollow.image !== void 0 && (n2 = this.drawHollowImage(t3, r2, l2, n2));
      var c2 = this.drawHollow({ size: h3, centerX: t3.centerX, centerY: t3.centerY, fill: n2 || "transparent" });
      if (e3.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var d2 = e3.config.plotOptions.radialBar.hollow.dropShadow;
        s2.dropShadow(c2, d2);
      }
      var g2 = 1;
      !this.radialDataLabels.total.show && e3.globals.series.length > 1 && (g2 = 0);
      var u2 = null;
      this.radialDataLabels.show && (u2 = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: g2 })), e3.config.plotOptions.radialBar.hollow.position === "back" && (r2.add(c2), u2 && r2.add(u2));
      var p3 = false;
      e3.config.plotOptions.radialBar.inverseOrder && (p3 = true);
      for (var f2 = p3 ? t3.series.length - 1 : 0; p3 ? f2 >= 0 : f2 < t3.series.length; p3 ? f2-- : f2++) {
        var b2 = i3.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: x.escapeString(e3.globals.seriesNames[f2]) });
        r2.add(b2), b2.attr({ rel: f2 + 1, "data:realIndex": f2 }), this.ctx.series.addCollapsedClassToSeries(b2, f2), t3.size = t3.size - o2 - this.margin;
        var y2 = a2.fillPath({ seriesNumber: f2, size: t3.size, value: t3.series[f2] }), w2 = this.startAngle, k2 = void 0, A2 = x.negToZero(t3.series[f2] > 100 ? 100 : t3.series[f2]) / 100, S2 = Math.round(this.totalAngle * A2) + this.startAngle, C2 = void 0;
        e3.globals.dataChanged && (k2 = this.startAngle, C2 = Math.round(this.totalAngle * x.negToZero(e3.globals.previousPaths[f2]) / 100) + k2), Math.abs(S2) + Math.abs(w2) >= 360 && (S2 -= 0.01), Math.abs(C2) + Math.abs(k2) >= 360 && (C2 -= 0.01);
        var L2 = S2 - w2, P2 = Array.isArray(e3.config.stroke.dashArray) ? e3.config.stroke.dashArray[f2] : e3.config.stroke.dashArray, M2 = i3.drawPath({ d: "", stroke: y2, strokeWidth: o2, fill: "none", fillOpacity: e3.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f2, strokeDashArray: P2 });
        if (m.setAttrs(M2.node, { "data:angle": L2, "data:value": t3.series[f2] }), e3.config.chart.dropShadow.enabled) {
          var I2 = e3.config.chart.dropShadow;
          s2.dropShadow(M2, I2, f2);
        }
        s2.setSelectionFilter(M2, 0, f2), this.addListeners(M2, this.radialDataLabels), b2.add(M2), M2.attr({ index: 0, j: f2 });
        var z2 = 0;
        !this.initialAnim || e3.globals.resized || e3.globals.dataChanged || (z2 = e3.config.chart.animations.speed), e3.globals.dataChanged && (z2 = e3.config.chart.animations.dynamicAnimation.speed), this.animDur = z2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: S2, startAngle: w2, prevEndAngle: C2, prevStartAngle: k2, size: t3.size, i: f2, totalItems: 2, animBeginArr: this.animBeginArr, dur: z2, shouldSetPrevPaths: true, easing: e3.globals.easing });
      }
      return { g: r2, elHollow: c2, dataLabels: u2 };
    } }, { key: "drawHollow", value: function(t3) {
      var e3 = new m(this.ctx).drawCircle(2 * t3.size);
      return e3.attr({ class: "apexcharts-radialbar-hollow", cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e3;
    } }, { key: "drawHollowImage", value: function(t3, e3, i3, a2) {
      var s2 = this.w, r2 = new T(this.ctx), o2 = x.randomId(), n2 = s2.config.plotOptions.radialBar.hollow.image;
      if (s2.config.plotOptions.radialBar.hollow.imageClipped)
        r2.clippedImgArea({ width: i3, height: i3, image: n2, patternID: "pattern".concat(s2.globals.cuid).concat(o2) }), a2 = "url(#pattern".concat(s2.globals.cuid).concat(o2, ")");
      else {
        var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h3 = s2.config.plotOptions.radialBar.hollow.imageHeight;
        if (l2 === void 0 && h3 === void 0) {
          var c2 = s2.globals.dom.Paper.image(n2).loaded(function(e4) {
            this.move(t3.centerX - e4.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e4.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          e3.add(c2);
        } else {
          var d2 = s2.globals.dom.Paper.image(n2).loaded(function(e4) {
            this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h3 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h3);
          });
          e3.add(d2);
        }
      }
      return a2;
    } }, { key: "getStrokeWidth", value: function(t3) {
      var e3 = this.w;
      return t3.size * (100 - parseInt(e3.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
    } }]), i2;
  }(), Tt = function() {
    function t2(e2) {
      a(this, t2), this.w = e2.w, this.lineCtx = e2;
    }
    return r(t2, [{ key: "sameValueSeriesFix", value: function(t3, e2) {
      var i2 = this.w;
      if (i2.config.chart.type === "line" && (i2.config.fill.type === "gradient" || i2.config.fill.type[t3] === "gradient") && new y(this.lineCtx.ctx, i2).seriesHaveSameValues(t3)) {
        var a2 = e2[t3].slice();
        a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, e2[t3] = a2;
      }
      return e2;
    } }, { key: "calculatePoints", value: function(t3) {
      var e2 = t3.series, i2 = t3.realIndex, a2 = t3.x, s2 = t3.y, r2 = t3.i, o2 = t3.j, n2 = t3.prevY, l2 = this.w, h3 = [], c2 = [];
      if (o2 === 0) {
        var d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
        l2.globals.isXNumeric && (d2 = (l2.globals.seriesX[i2][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), h3.push(d2), c2.push(x.isNumber(e2[r2][0]) ? n2 + l2.config.markers.offsetY : null), h3.push(a2 + l2.config.markers.offsetX), c2.push(x.isNumber(e2[r2][o2 + 1]) ? s2 + l2.config.markers.offsetY : null);
      } else
        h3.push(a2 + l2.config.markers.offsetX), c2.push(x.isNumber(e2[r2][o2 + 1]) ? s2 + l2.config.markers.offsetY : null);
      return { x: h3, y: c2 };
    } }, { key: "checkPreviousPaths", value: function(t3) {
      for (var e2 = t3.pathFromLine, i2 = t3.pathFromArea, a2 = t3.realIndex, s2 = this.w, r2 = 0; r2 < s2.globals.previousPaths.length; r2++) {
        var o2 = s2.globals.previousPaths[r2];
        (o2.type === "line" || o2.type === "area") && o2.paths.length > 0 && parseInt(o2.realIndex, 10) === parseInt(a2, 10) && (o2.type === "line" ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : o2.type === "area" && (this.lineCtx.appendPathFrom = false, i2 = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r2].paths[1] && (e2 = s2.globals.previousPaths[r2].paths[1].d)));
      }
      return { pathFromLine: e2, pathFromArea: i2 };
    } }, { key: "determineFirstPrevY", value: function(t3) {
      var e2 = t3.i, i2 = t3.series, a2 = t3.prevY, s2 = t3.lineYPosition, r2 = this.w;
      if (i2[e2][0] !== void 0)
        a2 = (s2 = r2.config.chart.stacked && e2 > 0 ? this.lineCtx.prevSeriesY[e2 - 1][0] : this.lineCtx.zeroY) - i2[e2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i2[e2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
      else if (r2.config.chart.stacked && e2 > 0 && i2[e2][0] === void 0) {
        for (var o2 = e2 - 1; o2 >= 0; o2--)
          if (i2[o2][0] !== null && i2[o2][0] !== void 0) {
            a2 = s2 = this.lineCtx.prevSeriesY[o2][0];
            break;
          }
      }
      return { prevY: a2, lineYPosition: s2 };
    } }]), t2;
  }(), Mt = function() {
    function t2(e2, i2, s2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = i2, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || s2, this.scatter = new I(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Tt(this), this.markers = new M(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return r(t2, [{ key: "draw", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = new m(this.ctx), r2 = a2.globals.comboCharts ? e2 : a2.config.chart.type, o2 = s2.group({ class: "apexcharts-".concat(r2, "-series apexcharts-plot-series") }), n2 = new y(this.ctx, a2);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = n2.getLogSeries(t3), this.yRatio = n2.getLogYRatios(this.yRatio);
      for (var l2 = [], h3 = 0; h3 < t3.length; h3++) {
        t3 = this.lineHelpers.sameValueSeriesFix(h3, t3);
        var c2 = a2.globals.comboCharts ? i2[h3] : h3;
        this._initSerieVariables(t3, h3, c2);
        var d2 = [], g2 = [], u2 = a2.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, c2), a2.globals.isXNumeric && a2.globals.seriesX.length > 0 && (u2 = (a2.globals.seriesX[c2][0] - a2.globals.minX) / this.xRatio), g2.push(u2);
        var p3, f2 = u2, x2 = f2, b2 = this.zeroY;
        b2 = this.lineHelpers.determineFirstPrevY({ i: h3, series: t3, prevY: b2, lineYPosition: 0 }).prevY, d2.push(b2), p3 = b2;
        var v2 = this._calculatePathsFrom({ series: t3, i: h3, realIndex: c2, prevX: x2, prevY: b2 }), w2 = this._iterateOverDataPoints({ series: t3, realIndex: c2, i: h3, x: u2, y: 1, pX: f2, pY: p3, pathsFrom: v2, linePaths: [], areaPaths: [], seriesIndex: i2, lineYPosition: 0, xArrj: g2, yArrj: d2 });
        this._handlePaths({ type: r2, realIndex: c2, i: h3, paths: w2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l2.push(this.elSeries);
      }
      if (a2.config.chart.stacked)
        for (var k2 = l2.length; k2 > 0; k2--)
          o2.add(l2[k2 - 1]);
      else
        for (var A2 = 0; A2 < l2.length; A2++)
          o2.add(l2[A2]);
      return o2;
    } }, { key: "_initSerieVariables", value: function(t3, e2, i2) {
      var a2 = this.w, s2 = new m(this.ctx);
      this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - (a2.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i2] : a2.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || a2.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", seriesName: x.escapeString(a2.globals.seriesNames[i2]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i2 }), this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i2 });
      var r2 = t3[e2].length === a2.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": r2, rel: e2 + 1, "data:realIndex": i2 }), this.appendPathFrom = true;
    } }, { key: "_calculatePathsFrom", value: function(t3) {
      var e2, i2, a2, s2, r2 = t3.series, o2 = t3.i, n2 = t3.realIndex, l2 = t3.prevX, h3 = t3.prevY, c2 = this.w, d2 = new m(this.ctx);
      if (r2[o2][0] === null) {
        for (var g2 = 0; g2 < r2[o2].length; g2++)
          if (r2[o2][g2] !== null) {
            l2 = this.xDivision * g2, h3 = this.zeroY - r2[o2][g2] / this.yRatio[this.yaxisIndex], e2 = d2.move(l2, h3), i2 = d2.move(l2, this.areaBottomY);
            break;
          }
      } else
        e2 = d2.move(l2, h3), i2 = d2.move(l2, this.areaBottomY) + d2.line(l2, h3);
      if (a2 = d2.move(-1, this.zeroY) + d2.line(-1, this.zeroY), s2 = d2.move(-1, this.zeroY) + d2.line(-1, this.zeroY), c2.globals.previousPaths.length > 0) {
        var u2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: n2 });
        a2 = u2.pathFromLine, s2 = u2.pathFromArea;
      }
      return { prevX: l2, prevY: h3, linePath: e2, areaPath: i2, pathFromLine: a2, pathFromArea: s2 };
    } }, { key: "_handlePaths", value: function(t3) {
      var i2 = t3.type, a2 = t3.realIndex, s2 = t3.i, r2 = t3.paths, o2 = this.w, n2 = new m(this.ctx), l2 = new T(this.ctx);
      this.prevSeriesY.push(r2.yArrj), o2.globals.seriesXvalues[a2] = r2.xArrj, o2.globals.seriesYvalues[a2] = r2.yArrj;
      var h3 = o2.config.forecastDataPoints;
      if (h3.count > 0) {
        var c2 = o2.globals.seriesXvalues[a2][o2.globals.seriesXvalues[a2].length - h3.count - 1], d2 = n2.drawRect(c2, 0, o2.globals.gridWidth, o2.globals.gridHeight, 0);
        o2.globals.dom.elForecastMask.appendChild(d2.node);
        var g2 = n2.drawRect(0, 0, c2, o2.globals.gridHeight, 0);
        o2.globals.dom.elNonForecastMask.appendChild(g2.node);
      }
      this.pointsChart || o2.globals.delayedElements.push({ el: this.elPointsMain.node, index: a2 });
      var u2 = { i: s2, realIndex: a2, animationDelay: s2, initialSpeed: o2.config.chart.animations.speed, dataChangeSpeed: o2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(i2) };
      if (i2 === "area")
        for (var p3 = l2.fillPath({ seriesNumber: a2 }), f2 = 0; f2 < r2.areaPaths.length; f2++) {
          var x2 = n2.renderPaths(e(e({}, u2), {}, { pathFrom: r2.pathFromArea, pathTo: r2.areaPaths[f2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p3 }));
          this.elSeries.add(x2);
        }
      if (o2.config.stroke.show && !this.pointsChart) {
        var b2 = null;
        b2 = i2 === "line" ? l2.fillPath({ seriesNumber: a2, i: s2 }) : o2.globals.stroke.colors[a2];
        for (var v2 = 0; v2 < r2.linePaths.length; v2++) {
          var y2 = e(e({}, u2), {}, { pathFrom: r2.pathFromLine, pathTo: r2.linePaths[v2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: o2.config.stroke.lineCap, fill: "none" }), w2 = n2.renderPaths(y2);
          if (this.elSeries.add(w2), h3.count > 0) {
            var k2 = n2.renderPaths(y2);
            k2.node.setAttribute("stroke-dasharray", h3.dashArray), h3.strokeWidth && k2.node.setAttribute("stroke-width", h3.strokeWidth), this.elSeries.add(k2), k2.attr("clip-path", "url(#forecastMask".concat(o2.globals.cuid, ")")), w2.attr("clip-path", "url(#nonForecastMask".concat(o2.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(t3) {
      for (var e2 = t3.series, i2 = t3.realIndex, a2 = t3.i, s2 = t3.x, r2 = t3.y, o2 = t3.pX, n2 = t3.pY, l2 = t3.pathsFrom, h3 = t3.linePaths, c2 = t3.areaPaths, d2 = t3.seriesIndex, g2 = t3.lineYPosition, u2 = t3.xArrj, p3 = t3.yArrj, f2 = this.w, b2 = new m(this.ctx), v2 = this.yRatio, y2 = l2.prevY, w2 = l2.linePath, k2 = l2.areaPath, A2 = l2.pathFromLine, S2 = l2.pathFromArea, C2 = x.isNumber(f2.globals.minYArr[i2]) ? f2.globals.minYArr[i2] : f2.globals.minY, L2 = f2.globals.dataPoints > 1 ? f2.globals.dataPoints - 1 : f2.globals.dataPoints, P2 = 0; P2 < L2; P2++) {
        var T2 = e2[a2][P2 + 1] === void 0 || e2[a2][P2 + 1] === null;
        if (f2.globals.isXNumeric) {
          var M2 = f2.globals.seriesX[i2][P2 + 1];
          f2.globals.seriesX[i2][P2 + 1] === void 0 && (M2 = f2.globals.seriesX[i2][L2 - 1]), s2 = (M2 - f2.globals.minX) / this.xRatio;
        } else
          s2 += this.xDivision;
        if (f2.config.chart.stacked)
          if (a2 > 0 && f2.globals.collapsedSeries.length < f2.config.series.length - 1) {
            g2 = this.prevSeriesY[function(t4) {
              for (var e3 = t4, i3 = 0; i3 < f2.globals.series.length; i3++)
                if (f2.globals.collapsedSeriesIndices.indexOf(t4) > -1) {
                  e3--;
                  break;
                }
              return e3 >= 0 ? e3 : 0;
            }(a2 - 1)][P2 + 1];
          } else
            g2 = this.zeroY;
        else
          g2 = this.zeroY;
        r2 = T2 ? g2 - C2 / v2[this.yaxisIndex] + 2 * (this.isReversed ? C2 / v2[this.yaxisIndex] : 0) : g2 - e2[a2][P2 + 1] / v2[this.yaxisIndex] + 2 * (this.isReversed ? e2[a2][P2 + 1] / v2[this.yaxisIndex] : 0), u2.push(s2), p3.push(r2);
        var I2 = this.lineHelpers.calculatePoints({ series: e2, x: s2, y: r2, realIndex: i2, i: a2, j: P2, prevY: y2 }), z2 = this._createPaths({ series: e2, i: a2, realIndex: i2, j: P2, x: s2, y: r2, pX: o2, pY: n2, linePath: w2, areaPath: k2, linePaths: h3, areaPaths: c2, seriesIndex: d2 });
        c2 = z2.areaPaths, h3 = z2.linePaths, o2 = z2.pX, n2 = z2.pY, k2 = z2.areaPath, w2 = z2.linePath, this.appendPathFrom && (A2 += b2.line(s2, this.zeroY), S2 += b2.line(s2, this.zeroY)), this.handleNullDataPoints(e2, I2, a2, P2, i2), this._handleMarkersAndLabels({ pointsPos: I2, series: e2, x: s2, y: r2, prevY: y2, i: a2, j: P2, realIndex: i2 });
      }
      return { yArrj: p3, xArrj: u2, pathFromArea: S2, areaPaths: c2, pathFromLine: A2, linePaths: h3 };
    } }, { key: "_handleMarkersAndLabels", value: function(t3) {
      var e2 = t3.pointsPos;
      t3.series, t3.x, t3.y, t3.prevY;
      var i2 = t3.i, a2 = t3.j, s2 = t3.realIndex, r2 = this.w, o2 = new z(this.ctx);
      if (this.pointsChart)
        this.scatter.draw(this.elSeries, a2, { realIndex: s2, pointsPos: e2, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        r2.globals.series[i2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var n2 = this.markers.plotChartMarkers(e2, s2, a2 + 1);
        n2 !== null && this.elPointsMain.add(n2);
      }
      var l2 = o2.drawDataLabel(e2, s2, a2 + 1, null);
      l2 !== null && this.elDataLabelsWrap.add(l2);
    } }, { key: "_createPaths", value: function(t3) {
      var e2 = t3.series, i2 = t3.i, a2 = t3.realIndex, s2 = t3.j, r2 = t3.x, o2 = t3.y, n2 = t3.pX, l2 = t3.pY, h3 = t3.linePath, c2 = t3.areaPath, d2 = t3.linePaths, g2 = t3.areaPaths, u2 = t3.seriesIndex, p3 = this.w, f2 = new m(this.ctx), x2 = p3.config.stroke.curve, b2 = this.areaBottomY;
      if (Array.isArray(p3.config.stroke.curve) && (x2 = Array.isArray(u2) ? p3.config.stroke.curve[u2[i2]] : p3.config.stroke.curve[i2]), x2 === "smooth") {
        var v2 = 0.35 * (r2 - n2);
        p3.globals.hasNullValues ? (e2[i2][s2] !== null && (e2[i2][s2 + 1] !== null ? (h3 = f2.move(n2, l2) + f2.curve(n2 + v2, l2, r2 - v2, o2, r2 + 1, o2), c2 = f2.move(n2 + 1, l2) + f2.curve(n2 + v2, l2, r2 - v2, o2, r2 + 1, o2) + f2.line(r2, b2) + f2.line(n2, b2) + "z") : (h3 = f2.move(n2, l2), c2 = f2.move(n2, l2) + "z")), d2.push(h3), g2.push(c2)) : (h3 += f2.curve(n2 + v2, l2, r2 - v2, o2, r2, o2), c2 += f2.curve(n2 + v2, l2, r2 - v2, o2, r2, o2)), n2 = r2, l2 = o2, s2 === e2[i2].length - 2 && (c2 = c2 + f2.curve(n2, l2, r2, o2, r2, b2) + f2.move(r2, o2) + "z", p3.globals.hasNullValues || (d2.push(h3), g2.push(c2)));
      } else {
        if (e2[i2][s2 + 1] === null) {
          h3 += f2.move(r2, o2);
          var y2 = p3.globals.isXNumeric ? (p3.globals.seriesX[a2][s2] - p3.globals.minX) / this.xRatio : r2 - this.xDivision;
          c2 = c2 + f2.line(y2, b2) + f2.move(r2, o2) + "z";
        }
        e2[i2][s2] === null && (h3 += f2.move(r2, o2), c2 += f2.move(r2, b2)), x2 === "stepline" ? (h3 = h3 + f2.line(r2, null, "H") + f2.line(null, o2, "V"), c2 = c2 + f2.line(r2, null, "H") + f2.line(null, o2, "V")) : x2 === "straight" && (h3 += f2.line(r2, o2), c2 += f2.line(r2, o2)), s2 === e2[i2].length - 2 && (c2 = c2 + f2.line(r2, b2) + f2.move(r2, o2) + "z", d2.push(h3), g2.push(c2));
      }
      return { linePaths: d2, areaPaths: g2, pX: n2, pY: l2, linePath: h3, areaPath: c2 };
    } }, { key: "handleNullDataPoints", value: function(t3, e2, i2, a2, s2) {
      var r2 = this.w;
      if (t3[i2][a2] === null && r2.config.markers.showNullDataPoints || t3[i2].length === 1) {
        var o2 = this.markers.plotChartMarkers(e2, s2, a2 + 1, this.strokeWidth - r2.config.markers.strokeWidth / 2, true);
        o2 !== null && this.elPointsMain.add(o2);
      }
    } }]), t2;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
    function t2(e3, i3, a3, s3) {
      this.xoffset = e3, this.yoffset = i3, this.height = s3, this.width = a3, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(t3) {
        var e4, i4 = [], a4 = this.xoffset, s4 = this.yoffset, o3 = r2(t3) / this.height, n2 = r2(t3) / this.width;
        if (this.width >= this.height)
          for (e4 = 0; e4 < t3.length; e4++)
            i4.push([a4, s4, a4 + o3, s4 + t3[e4] / o3]), s4 += t3[e4] / o3;
        else
          for (e4 = 0; e4 < t3.length; e4++)
            i4.push([a4, s4, a4 + t3[e4] / n2, s4 + n2]), a4 += t3[e4] / n2;
        return i4;
      }, this.cutArea = function(e4) {
        var i4;
        if (this.width >= this.height) {
          var a4 = e4 / this.height, s4 = this.width - a4;
          i4 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
        } else {
          var r3 = e4 / this.width, o3 = this.height - r3;
          i4 = new t2(this.xoffset, this.yoffset + r3, this.width, o3);
        }
        return i4;
      };
    }
    function e2(e3, a3, s3, o3, n2) {
      return o3 = o3 === void 0 ? 0 : o3, n2 = n2 === void 0 ? 0 : n2, function(t3) {
        var e4, i3, a4 = [];
        for (e4 = 0; e4 < t3.length; e4++)
          for (i3 = 0; i3 < t3[e4].length; i3++)
            a4.push(t3[e4][i3]);
        return a4;
      }(i2(function(t3, e4) {
        var i3, a4 = [], s4 = e4 / r2(t3);
        for (i3 = 0; i3 < t3.length; i3++)
          a4[i3] = t3[i3] * s4;
        return a4;
      }(e3, a3 * s3), [], new t2(o3, n2, a3, s3), []));
    }
    function i2(t3, e3, s3, o3) {
      var n2, l2, h3;
      if (t3.length !== 0)
        return n2 = s3.shortestEdge(), function(t4, e4, i3) {
          var s4;
          if (t4.length === 0)
            return true;
          (s4 = t4.slice()).push(e4);
          var r3 = a2(t4, i3), o4 = a2(s4, i3);
          return r3 >= o4;
        }(e3, l2 = t3[0], n2) ? (e3.push(l2), i2(t3.slice(1), e3, s3, o3)) : (h3 = s3.cutArea(r2(e3), o3), o3.push(s3.getCoordinates(e3)), i2(t3, [], h3, o3)), o3;
      o3.push(s3.getCoordinates(e3));
    }
    function a2(t3, e3) {
      var i3 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
      return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i3));
    }
    function s2(t3) {
      return t3 && t3.constructor === Array;
    }
    function r2(t3) {
      var e3, i3 = 0;
      for (e3 = 0; e3 < t3.length; e3++)
        i3 += t3[e3];
      return i3;
    }
    function o2(t3) {
      var e3, i3 = 0;
      if (s2(t3[0]))
        for (e3 = 0; e3 < t3.length; e3++)
          i3 += o2(t3[e3]);
      else
        i3 = r2(t3);
      return i3;
    }
    return function t3(i3, a3, r3, n2, l2) {
      n2 = n2 === void 0 ? 0 : n2, l2 = l2 === void 0 ? 0 : l2;
      var h3, c2, d2 = [], g2 = [];
      if (s2(i3[0])) {
        for (c2 = 0; c2 < i3.length; c2++)
          d2[c2] = o2(i3[c2]);
        for (h3 = e2(d2, a3, r3, n2, l2), c2 = 0; c2 < i3.length; c2++)
          g2.push(t3(i3[c2], h3[c2][2] - h3[c2][0], h3[c2][3] - h3[c2][1], h3[c2][0], h3[c2][1]));
      } else
        g2 = e2(i3, a3, r3, n2, l2);
      return g2;
    };
  }();
  var It, zt, Xt = function() {
    function t2(e2, i2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new kt(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return r(t2, [{ key: "draw", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = new T(this.ctx), r2 = a2.group({ class: "apexcharts-treemap" });
      if (i2.globals.noData)
        return r2;
      var o2 = [];
      return t3.forEach(function(t4) {
        var e3 = t4.map(function(t5) {
          return Math.abs(t5);
        });
        o2.push(e3);
      }), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach(function(t4, i3) {
        t4.data.forEach(function(t5) {
          Array.isArray(e2.labels[i3]) || (e2.labels[i3] = []), e2.labels[i3].push(t5.x);
        });
      }), window.TreemapSquared.generate(o2, i2.globals.gridWidth, i2.globals.gridHeight).forEach(function(o3, n2) {
        var l2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: x.escapeString(i2.globals.seriesNames[n2]), rel: n2 + 1, "data:realIndex": n2 });
        if (i2.config.chart.dropShadow.enabled) {
          var h3 = i2.config.chart.dropShadow;
          new v(e2.ctx).dropShadow(r2, h3, n2);
        }
        var c2 = a2.group({ class: "apexcharts-data-labels" });
        o3.forEach(function(r3, o4) {
          var h4 = r3[0], c3 = r3[1], d2 = r3[2], g2 = r3[3], u2 = a2.drawRect(h4, c3, d2 - h4, g2 - c3, 0, "#fff", 1, e2.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f2 : i2.globals.stroke.colors[n2]);
          u2.attr({ cx: h4, cy: c3, index: n2, i: n2, j: o4, width: d2 - h4, height: g2 - c3 });
          var p3 = e2.helpers.getShadeColor(i2.config.chart.type, n2, o4, e2.negRange), f2 = p3.color;
          i2.config.series[n2].data[o4] !== void 0 && i2.config.series[n2].data[o4].fillColor && (f2 = i2.config.series[n2].data[o4].fillColor);
          var x2 = s2.fillPath({ color: f2, seriesNumber: n2, dataPointIndex: o4 });
          u2.node.classList.add("apexcharts-treemap-rect"), u2.attr({ fill: x2 }), e2.helpers.addListeners(u2);
          var b2 = { x: h4 + (d2 - h4) / 2, y: c3 + (g2 - c3) / 2, width: 0, height: 0 }, v2 = { x: h4, y: c3, width: d2 - h4, height: g2 - c3 };
          if (i2.config.chart.animations.enabled && !i2.globals.dataChanged) {
            var m2 = 1;
            i2.globals.resized || (m2 = i2.config.chart.animations.speed), e2.animateTreemap(u2, b2, v2, m2);
          }
          if (i2.globals.dataChanged) {
            var y2 = 1;
            e2.dynamicAnim.enabled && i2.globals.shouldAnimate && (y2 = e2.dynamicAnim.speed, i2.globals.previousPaths[n2] && i2.globals.previousPaths[n2][o4] && i2.globals.previousPaths[n2][o4].rect && (b2 = i2.globals.previousPaths[n2][o4].rect), e2.animateTreemap(u2, b2, v2, y2));
          }
          var w2 = e2.getFontSize(r3), k2 = i2.config.dataLabels.formatter(e2.labels[n2][o4], { value: i2.globals.series[n2][o4], seriesIndex: n2, dataPointIndex: o4, w: i2 }), A2 = e2.helpers.calculateDataLabels({ text: k2, x: (h4 + d2) / 2, y: (c3 + g2) / 2 + e2.strokeWidth / 2 + w2 / 3, i: n2, j: o4, colorProps: p3, fontSize: w2, series: t3 });
          i2.config.dataLabels.enabled && A2 && e2.rotateToFitLabel(A2, k2, h4, c3, d2, g2), l2.add(u2), A2 !== null && l2.add(A2);
        }), l2.add(c2), r2.add(l2);
      }), r2;
    } }, { key: "getFontSize", value: function(t3) {
      var e2 = this.w;
      var i2, a2, s2, r2, o2 = function t4(e3) {
        var i3, a3 = 0;
        if (Array.isArray(e3[0]))
          for (i3 = 0; i3 < e3.length; i3++)
            a3 += t4(e3[i3]);
        else
          for (i3 = 0; i3 < e3.length; i3++)
            a3 += e3[i3].length;
        return a3;
      }(this.labels) / function t4(e3) {
        var i3, a3 = 0;
        if (Array.isArray(e3[0]))
          for (i3 = 0; i3 < e3.length; i3++)
            a3 += t4(e3[i3]);
        else
          for (i3 = 0; i3 < e3.length; i3++)
            a3 += 1;
        return a3;
      }(this.labels);
      return i2 = t3[2] - t3[0], a2 = t3[3] - t3[1], s2 = i2 * a2, r2 = Math.pow(s2, 0.5), Math.min(r2 / o2, parseInt(e2.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(t3, e2, i2, a2, s2, r2) {
      var o2 = new m(this.ctx), n2 = o2.getTextRects(e2);
      if (n2.width + 5 > s2 - i2 && n2.width <= r2 - a2) {
        var l2 = o2.rotateAroundCenter(t3.node);
        t3.node.setAttribute("transform", "rotate(-90 ".concat(l2.x, " ").concat(l2.y, ")"));
      }
    } }, { key: "animateTreemap", value: function(t3, e2, i2, a2) {
      var s2 = new b(this.ctx);
      s2.animateRect(t3, { x: e2.x, y: e2.y, width: e2.width, height: e2.height }, { x: i2.x, y: i2.y, width: i2.width, height: i2.height }, a2, function() {
        s2.animationCompleted(t3);
      });
    } }]), t2;
  }(), Et = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return r(t2, [{ key: "calculateTimeScaleTicks", value: function(t3, i2) {
      var a2 = this, s2 = this.w;
      if (s2.globals.allSeriesCollapsed)
        return s2.globals.labels = [], s2.globals.timescaleLabels = [], [];
      var r2 = new R(this.ctx), o2 = (i2 - t3) / 864e5;
      this.determineInterval(o2), s2.globals.disableZoomIn = false, s2.globals.disableZoomOut = false, o2 < 11574074074074075e-20 ? s2.globals.disableZoomIn = true : o2 > 5e4 && (s2.globals.disableZoomOut = true);
      var n2 = r2.getTimeUnitsfromTimestamp(t3, i2, this.utc), l2 = s2.globals.gridWidth / o2, h3 = l2 / 24, c2 = h3 / 60, d2 = c2 / 60, g2 = Math.floor(24 * o2), u2 = Math.floor(1440 * o2), p3 = Math.floor(86400 * o2), f2 = Math.floor(o2), x2 = Math.floor(o2 / 30), b2 = Math.floor(o2 / 365), v2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, m2 = { firstVal: v2, currentMillisecond: v2.minMillisecond, currentSecond: v2.minSecond, currentMinute: v2.minMinute, currentHour: v2.minHour, currentMonthDate: v2.minDate, currentDate: v2.minDate, currentMonth: v2.minMonth, currentYear: v2.minYear, daysWidthOnXAxis: l2, hoursWidthOnXAxis: h3, minutesWidthOnXAxis: c2, secondsWidthOnXAxis: d2, numberOfSeconds: p3, numberOfMinutes: u2, numberOfHours: g2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(m2);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(m2);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(m2);
          break;
        case "hours":
          this.generateHourScale(m2);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(m2);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(m2);
      }
      var y2 = this.timeScaleArray.map(function(t4) {
        var i3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
        return t4.unit === "month" ? e(e({}, i3), {}, { day: 1, value: t4.value + 1 }) : t4.unit === "day" || t4.unit === "hour" ? e(e({}, i3), {}, { value: t4.value }) : t4.unit === "minute" ? e(e({}, i3), {}, { value: t4.value, minute: t4.value }) : t4.unit === "second" ? e(e({}, i3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
      });
      return y2.filter(function(t4) {
        var e2 = 1, i3 = Math.ceil(s2.globals.gridWidth / 120), r3 = t4.value;
        s2.config.xaxis.tickAmount !== void 0 && (i3 = s2.config.xaxis.tickAmount), y2.length > i3 && (e2 = Math.floor(y2.length / i3));
        var o3 = false, n3 = false;
        switch (a2.tickInterval) {
          case "years":
            t4.unit === "year" && (o3 = true);
            break;
          case "half_year":
            e2 = 7, t4.unit === "year" && (o3 = true);
            break;
          case "months":
            e2 = 1, t4.unit === "year" && (o3 = true);
            break;
          case "months_fortnight":
            e2 = 15, t4.unit !== "year" && t4.unit !== "month" || (o3 = true), r3 === 30 && (n3 = true);
            break;
          case "months_days":
            e2 = 10, t4.unit === "month" && (o3 = true), r3 === 30 && (n3 = true);
            break;
          case "week_days":
            e2 = 8, t4.unit === "month" && (o3 = true);
            break;
          case "days":
            e2 = 1, t4.unit === "month" && (o3 = true);
            break;
          case "hours":
            t4.unit === "day" && (o3 = true);
            break;
          case "minutes_fives":
            r3 % 5 != 0 && (n3 = true);
            break;
          case "seconds_tens":
            r3 % 10 != 0 && (n3 = true);
            break;
          case "seconds_fives":
            r3 % 5 != 0 && (n3 = true);
        }
        if (a2.tickInterval === "hours" || a2.tickInterval === "minutes_fives" || a2.tickInterval === "seconds_tens" || a2.tickInterval === "seconds_fives") {
          if (!n3)
            return true;
        } else if ((r3 % e2 == 0 || o3) && !n3)
          return true;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(t3, e2) {
      var i2 = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
      i2.globals.timescaleLabels = s2.slice(), new lt(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(t3) {
      var e2 = 24 * t3, i2 = 60 * e2;
      switch (true) {
        case t3 / 365 > 5:
          this.tickInterval = "years";
          break;
        case t3 > 800:
          this.tickInterval = "half_year";
          break;
        case t3 > 180:
          this.tickInterval = "months";
          break;
        case t3 > 90:
          this.tickInterval = "months_fortnight";
          break;
        case t3 > 60:
          this.tickInterval = "months_days";
          break;
        case t3 > 30:
          this.tickInterval = "week_days";
          break;
        case t3 > 2:
          this.tickInterval = "days";
          break;
        case e2 > 2.4:
          this.tickInterval = "hours";
          break;
        case i2 > 15:
          this.tickInterval = "minutes_fives";
          break;
        case i2 > 5:
          this.tickInterval = "minutes";
          break;
        case i2 > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * i2 > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(t3) {
      var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.daysWidthOnXAxis, r2 = t3.numberOfYears, o2 = e2.minYear, n2 = 0, l2 = new R(this.ctx), h3 = "year";
      if (e2.minDate > 1 || e2.minMonth > 0) {
        var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
        n2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, o2 = e2.minYear + 1, this.timeScaleArray.push({ position: n2, value: o2, unit: h3, year: o2, month: x.monthMod(i2 + 1) });
      } else
        e2.minDate === 1 && e2.minMonth === 0 && this.timeScaleArray.push({ position: n2, value: o2, unit: h3, year: a2, month: x.monthMod(i2 + 1) });
      for (var d2 = o2, g2 = n2, u2 = 0; u2 < r2; u2++)
        d2++, g2 = l2.determineDaysOfYear(d2 - 1) * s2 + g2, this.timeScaleArray.push({ position: g2, value: d2, unit: h3, year: d2, month: 1 });
    } }, { key: "generateMonthScale", value: function(t3) {
      var e2 = t3.firstVal, i2 = t3.currentMonthDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.daysWidthOnXAxis, o2 = t3.numberOfMonths, n2 = a2, l2 = 0, h3 = new R(this.ctx), c2 = "month", d2 = 0;
      if (e2.minDate > 1) {
        l2 = (h3.determineDaysOfMonths(a2 + 1, e2.minYear) - i2 + 1) * r2, n2 = x.monthMod(a2 + 1);
        var g2 = s2 + d2, u2 = x.monthMod(n2), p3 = n2;
        n2 === 0 && (c2 = "year", p3 = g2, u2 = 1, g2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p3, unit: c2, year: g2, month: u2 });
      } else
        this.timeScaleArray.push({ position: l2, value: n2, unit: c2, year: s2, month: x.monthMod(a2) });
      for (var f2 = n2 + 1, b2 = l2, v2 = 0, m2 = 1; v2 < o2; v2++, m2++) {
        (f2 = x.monthMod(f2)) === 0 ? (c2 = "year", d2 += 1) : c2 = "month";
        var y2 = this._getYear(s2, f2, d2);
        b2 = h3.determineDaysOfMonths(f2, y2) * r2 + b2;
        var w2 = f2 === 0 ? y2 : f2;
        this.timeScaleArray.push({ position: b2, value: w2, unit: c2, year: y2, month: f2 === 0 ? 1 : f2 }), f2++;
      }
    } }, { key: "generateDayScale", value: function(t3) {
      var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.hoursWidthOnXAxis, r2 = t3.numberOfDays, o2 = new R(this.ctx), n2 = "day", l2 = e2.minDate + 1, h3 = l2, c2 = function(t4, e3, i3) {
        return t4 > o2.determineDaysOfMonths(e3 + 1, i3) ? (h3 = 1, n2 = "month", g2 = e3 += 1, e3) : e3;
      }, d2 = (24 - e2.minHour) * s2, g2 = l2, u2 = c2(h3, i2, a2);
      e2.minHour === 0 && e2.minDate === 1 ? (d2 = 0, g2 = x.monthMod(e2.minMonth), n2 = "month", h3 = e2.minDate, r2++) : e2.minDate !== 1 && e2.minHour === 0 && e2.minMinute === 0 && (d2 = 0, l2 = e2.minDate, g2 = l2, u2 = c2(h3 = l2, i2, a2)), this.timeScaleArray.push({ position: d2, value: g2, unit: n2, year: this._getYear(a2, u2, 0), month: x.monthMod(u2), day: h3 });
      for (var p3 = d2, f2 = 0; f2 < r2; f2++) {
        n2 = "day", u2 = c2(h3 += 1, u2, this._getYear(a2, u2, 0));
        var b2 = this._getYear(a2, u2, 0);
        p3 = 24 * s2 + p3;
        var v2 = h3 === 1 ? x.monthMod(u2) : h3;
        this.timeScaleArray.push({ position: p3, value: v2, unit: n2, year: b2, month: x.monthMod(u2), day: v2 });
      }
    } }, { key: "generateHourScale", value: function(t3) {
      var e2 = t3.firstVal, i2 = t3.currentDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.minutesWidthOnXAxis, o2 = t3.numberOfHours, n2 = new R(this.ctx), l2 = "hour", h3 = function(t4, e3) {
        return t4 > n2.determineDaysOfMonths(e3 + 1, s2) && (f2 = 1, e3 += 1), { month: e3, date: f2 };
      }, c2 = function(t4, e3) {
        return t4 > n2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
      }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), g2 = d2 * r2, u2 = e2.minHour + 1, p3 = u2 + 1;
      d2 === 60 && (g2 = 0, p3 = (u2 = e2.minHour) + 1);
      var f2 = i2, b2 = c2(f2, a2);
      this.timeScaleArray.push({ position: g2, value: u2, unit: l2, day: f2, hour: p3, year: s2, month: x.monthMod(b2) });
      for (var v2 = g2, m2 = 0; m2 < o2; m2++) {
        if (l2 = "hour", p3 >= 24)
          p3 = 0, l2 = "day", b2 = h3(f2 += 1, b2).month, b2 = c2(f2, b2);
        var y2 = this._getYear(s2, b2, 0);
        v2 = p3 === 0 && m2 === 0 ? d2 * r2 : 60 * r2 + v2;
        var w2 = p3 === 0 ? f2 : p3;
        this.timeScaleArray.push({ position: v2, value: w2, unit: l2, hour: p3, day: f2, year: y2, month: x.monthMod(b2) }), p3++;
      }
    } }, { key: "generateMinuteScale", value: function(t3) {
      for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, o2 = t3.currentMonth, n2 = t3.currentYear, l2 = t3.minutesWidthOnXAxis, h3 = t3.secondsWidthOnXAxis, c2 = t3.numberOfMinutes, d2 = a2 + 1, g2 = r2, u2 = o2, p3 = n2, f2 = s2, b2 = (60 - i2 - e2 / 1e3) * h3, v2 = 0; v2 < c2; v2++)
        d2 >= 60 && (d2 = 0, (f2 += 1) === 24 && (f2 = 0)), this.timeScaleArray.push({ position: b2, value: d2, unit: "minute", hour: f2, minute: d2, day: g2, year: this._getYear(p3, u2, 0), month: x.monthMod(u2) }), b2 += l2, d2++;
    } }, { key: "generateSecondScale", value: function(t3) {
      for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, o2 = t3.currentMonth, n2 = t3.currentYear, l2 = t3.secondsWidthOnXAxis, h3 = t3.numberOfSeconds, c2 = i2 + 1, d2 = a2, g2 = r2, u2 = o2, p3 = n2, f2 = s2, b2 = (1e3 - e2) / 1e3 * l2, v2 = 0; v2 < h3; v2++)
        c2 >= 60 && (c2 = 0, ++d2 >= 60 && (d2 = 0, ++f2 === 24 && (f2 = 0))), this.timeScaleArray.push({ position: b2, value: c2, unit: "second", hour: f2, minute: d2, second: c2, day: g2, year: this._getYear(p3, u2, 0), month: x.monthMod(u2) }), b2 += l2, c2++;
    } }, { key: "createRawDateString", value: function(t3, e2) {
      var i2 = t3.year;
      return t3.month === 0 && (t3.month = 1), i2 += "-" + ("0" + t3.month.toString()).slice(-2), t3.unit === "day" ? i2 += t3.unit === "day" ? "-" + ("0" + e2).slice(-2) : "-01" : i2 += "-" + ("0" + (t3.day ? t3.day : "1")).slice(-2), t3.unit === "hour" ? i2 += t3.unit === "hour" ? "T" + ("0" + e2).slice(-2) : "T00" : i2 += "T" + ("0" + (t3.hour ? t3.hour : "0")).slice(-2), t3.unit === "minute" ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":" + (t3.minute ? ("0" + t3.minute).slice(-2) : "00"), t3.unit === "second" ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":00", this.utc && (i2 += ".000Z"), i2;
    } }, { key: "formatDates", value: function(t3) {
      var e2 = this, i2 = this.w;
      return t3.map(function(t4) {
        var a2 = t4.value.toString(), s2 = new R(e2.ctx), r2 = e2.createRawDateString(t4, a2), o2 = s2.getDate(s2.parseDate(r2));
        if (e2.utc || (o2 = s2.getDate(s2.parseDateWithTimezone(r2))), i2.config.xaxis.labels.format === void 0) {
          var n2 = "dd MMM", l2 = i2.config.xaxis.labels.datetimeFormatter;
          t4.unit === "year" && (n2 = l2.year), t4.unit === "month" && (n2 = l2.month), t4.unit === "day" && (n2 = l2.day), t4.unit === "hour" && (n2 = l2.hour), t4.unit === "minute" && (n2 = l2.minute), t4.unit === "second" && (n2 = l2.second), a2 = s2.formatDate(o2, n2);
        } else
          a2 = s2.formatDate(o2, i2.config.xaxis.labels.format);
        return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
      });
    } }, { key: "removeOverlappingTS", value: function(t3) {
      var e2, i2 = this, a2 = new m(this.ctx), s2 = false;
      t3.length > 0 && t3[0].value && t3.every(function(e3) {
        return e3.value.length === t3[0].value.length;
      }) && (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
      var r2 = 0, o2 = t3.map(function(o3, n2) {
        if (n2 > 0 && i2.w.config.xaxis.labels.hideOverlappingLabels) {
          var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h3 = t3[r2].position;
          return o3.position > h3 + l2 + 10 ? (r2 = n2, o3) : null;
        }
        return o3;
      });
      return o2 = o2.filter(function(t4) {
        return t4 !== null;
      });
    } }, { key: "_getYear", value: function(t3, e2, i2) {
      return t3 + Math.floor(e2 / 12) + i2;
    } }]), t2;
  }(), Yt = function() {
    function t2(e2, i2) {
      a(this, t2), this.ctx = i2, this.w = i2.w, this.el = e2;
    }
    return r(t2, [{ key: "setupElements", value: function() {
      var t3 = this.w.globals, e2 = this.w.config, i2 = e2.chart.type;
      t3.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i2) > -1, t3.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i2) > -1, t3.isBarHorizontal = (e2.chart.type === "bar" || e2.chart.type === "rangeBar" || e2.chart.type === "boxPlot") && e2.plotOptions.bar.horizontal, t3.chartClass = ".apexcharts" + t3.chartID, t3.dom.baseEl = this.el, t3.dom.elWrap = document.createElement("div"), m.setAttrs(t3.dom.elWrap, { id: t3.chartClass.substring(1), class: "apexcharts-canvas " + t3.chartClass.substring(1) }), this.el.appendChild(t3.dom.elWrap), t3.dom.Paper = new window.SVG.Doc(t3.dom.elWrap), t3.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(e2.chart.offsetX, ", ").concat(e2.chart.offsetY, ")") }), t3.dom.Paper.node.style.background = e2.chart.background, this.setSVGDimensions(), t3.dom.elGraphical = t3.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t3.dom.elAnnotations = t3.dom.Paper.group().attr({ class: "apexcharts-annotations" }), t3.dom.elDefs = t3.dom.Paper.defs(), t3.dom.elLegendWrap = document.createElement("div"), t3.dom.elLegendWrap.classList.add("apexcharts-legend"), t3.dom.elWrap.appendChild(t3.dom.elLegendWrap), t3.dom.Paper.add(t3.dom.elGraphical), t3.dom.elGraphical.add(t3.dom.elDefs);
    } }, { key: "plotChartType", value: function(t3, e2) {
      var i2 = this.w, a2 = i2.config, s2 = i2.globals, r2 = { series: [], i: [] }, o2 = { series: [], i: [] }, n2 = { series: [], i: [] }, l2 = { series: [], i: [] }, h3 = { series: [], i: [] }, c2 = { series: [], i: [] }, d2 = { series: [], i: [] };
      s2.series.map(function(e3, g3) {
        var u3 = 0;
        t3[g3].type !== void 0 ? (t3[g3].type === "column" || t3[g3].type === "bar" ? (s2.series.length > 1 && a2.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), h3.series.push(e3), h3.i.push(g3), u3++, i2.globals.columnSeries = h3.series) : t3[g3].type === "area" ? (o2.series.push(e3), o2.i.push(g3), u3++) : t3[g3].type === "line" ? (r2.series.push(e3), r2.i.push(g3), u3++) : t3[g3].type === "scatter" ? (n2.series.push(e3), n2.i.push(g3)) : t3[g3].type === "bubble" ? (l2.series.push(e3), l2.i.push(g3), u3++) : t3[g3].type === "candlestick" ? (c2.series.push(e3), c2.i.push(g3), u3++) : t3[g3].type === "boxPlot" ? (d2.series.push(e3), d2.i.push(g3), u3++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"), u3 > 1 && (s2.comboCharts = true)) : (r2.series.push(e3), r2.i.push(g3));
      });
      var g2 = new Mt(this.ctx, e2), u2 = new wt(this.ctx, e2);
      this.ctx.pie = new Ct(this.ctx);
      var p3 = new Pt(this.ctx);
      this.ctx.rangeBar = new H(this.ctx, e2);
      var f2 = new Lt(this.ctx), x2 = [];
      if (s2.comboCharts) {
        if (o2.series.length > 0 && x2.push(g2.draw(o2.series, "area", o2.i)), h3.series.length > 0)
          if (i2.config.chart.stacked) {
            var b2 = new yt(this.ctx, e2);
            x2.push(b2.draw(h3.series, h3.i));
          } else
            this.ctx.bar = new F(this.ctx, e2), x2.push(this.ctx.bar.draw(h3.series, h3.i));
        if (r2.series.length > 0 && x2.push(g2.draw(r2.series, "line", r2.i)), c2.series.length > 0 && x2.push(u2.draw(c2.series, c2.i)), d2.series.length > 0 && x2.push(u2.draw(d2.series, d2.i)), n2.series.length > 0) {
          var v2 = new Mt(this.ctx, e2, true);
          x2.push(v2.draw(n2.series, "scatter", n2.i));
        }
        if (l2.series.length > 0) {
          var m2 = new Mt(this.ctx, e2, true);
          x2.push(m2.draw(l2.series, "bubble", l2.i));
        }
      } else
        switch (a2.chart.type) {
          case "line":
            x2 = g2.draw(s2.series, "line");
            break;
          case "area":
            x2 = g2.draw(s2.series, "area");
            break;
          case "bar":
            if (a2.chart.stacked)
              x2 = new yt(this.ctx, e2).draw(s2.series);
            else
              this.ctx.bar = new F(this.ctx, e2), x2 = this.ctx.bar.draw(s2.series);
            break;
          case "candlestick":
            x2 = new wt(this.ctx, e2).draw(s2.series);
            break;
          case "boxPlot":
            x2 = new wt(this.ctx, e2).draw(s2.series);
            break;
          case "rangeBar":
            x2 = this.ctx.rangeBar.draw(s2.series);
            break;
          case "heatmap":
            x2 = new At(this.ctx, e2).draw(s2.series);
            break;
          case "treemap":
            x2 = new Xt(this.ctx, e2).draw(s2.series);
            break;
          case "pie":
          case "donut":
          case "polarArea":
            x2 = this.ctx.pie.draw(s2.series);
            break;
          case "radialBar":
            x2 = p3.draw(s2.series);
            break;
          case "radar":
            x2 = f2.draw(s2.series);
            break;
          default:
            x2 = g2.draw(s2.series);
        }
      return x2;
    } }, { key: "setSVGDimensions", value: function() {
      var t3 = this.w.globals, e2 = this.w.config;
      t3.svgWidth = e2.chart.width, t3.svgHeight = e2.chart.height;
      var i2 = x.getDimensions(this.el), a2 = e2.chart.width.toString().split(/[0-9]+/g).pop();
      a2 === "%" ? x.isNumber(i2[0]) && (i2[0].width === 0 && (i2 = x.getDimensions(this.el.parentNode)), t3.svgWidth = i2[0] * parseInt(e2.chart.width, 10) / 100) : a2 !== "px" && a2 !== "" || (t3.svgWidth = parseInt(e2.chart.width, 10));
      var s2 = e2.chart.height.toString().split(/[0-9]+/g).pop();
      if (t3.svgHeight !== "auto" && t3.svgHeight !== "")
        if (s2 === "%") {
          var r2 = x.getDimensions(this.el.parentNode);
          t3.svgHeight = r2[1] * parseInt(e2.chart.height, 10) / 100;
        } else
          t3.svgHeight = parseInt(e2.chart.height, 10);
      else
        t3.axisCharts ? t3.svgHeight = t3.svgWidth / 1.61 : t3.svgHeight = t3.svgWidth / 1.2;
      if (t3.svgWidth < 0 && (t3.svgWidth = 0), t3.svgHeight < 0 && (t3.svgHeight = 0), m.setAttrs(t3.dom.Paper.node, { width: t3.svgWidth, height: t3.svgHeight }), s2 !== "%") {
        var o2 = e2.chart.sparkline.enabled ? 0 : t3.axisCharts ? e2.chart.parentHeightOffset : 0;
        t3.dom.Paper.node.parentNode.parentNode.style.minHeight = t3.svgHeight + o2 + "px";
      }
      t3.dom.elWrap.style.width = t3.svgWidth + "px", t3.dom.elWrap.style.height = t3.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var t3 = this.w.globals, e2 = t3.translateY, i2 = { transform: "translate(" + t3.translateX + ", " + e2 + ")" };
      m.setAttrs(t3.dom.elGraphical.node, i2);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var t3 = this.w, e2 = t3.globals, i2 = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
      a2 += t3.config.grid.padding.bottom, t3.config.legend.position !== "top" && t3.config.legend.position !== "bottom" || !t3.config.legend.show || t3.config.legend.floating || (i2 = new ct(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t3.globals.radialSize;
      if (s2 && !t3.config.chart.sparkline.enabled && t3.config.plotOptions.radialBar.startAngle !== 0) {
        var o2 = x.getBoundingClientRect(s2);
        r2 = o2.bottom;
        var n2 = o2.bottom - o2.top;
        r2 = Math.max(2.05 * t3.globals.radialSize, n2);
      }
      var l2 = r2 + e2.translateY + i2 + a2;
      e2.dom.elLegendForeign && e2.dom.elLegendForeign.setAttribute("height", l2), e2.dom.elWrap.style.height = l2 + "px", m.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = l2 + "px";
    } }, { key: "coreCalculations", value: function() {
      new Z(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var t3 = this, e2 = function() {
        return t3.w.config.series.map(function(t4) {
          return [];
        });
      }, i2 = new O(), a2 = this.w.globals;
      i2.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
        return this.w.globals.isMultipleYAxis = true, true;
    } }, { key: "xySettings", value: function() {
      var t3 = null, e2 = this.w;
      if (e2.globals.axisCharts) {
        if (e2.config.xaxis.crosshairs.position === "back")
          new tt(this.ctx).drawXCrosshairs();
        if (e2.config.yaxis[0].crosshairs.position === "back")
          new tt(this.ctx).drawYCrosshairs();
        if (e2.config.xaxis.type === "datetime" && e2.config.xaxis.labels.formatter === void 0) {
          this.ctx.timeScale = new Et(this.ctx);
          var i2 = [];
          isFinite(e2.globals.minX) && isFinite(e2.globals.maxX) && !e2.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(e2.globals.minX, e2.globals.maxX) : e2.globals.isBarHorizontal && (i2 = this.ctx.timeScale.calculateTimeScaleTicks(e2.globals.minY, e2.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
        }
        t3 = new y(this.ctx).getCalculatedRatios();
      }
      return t3;
    } }, { key: "updateSourceChart", value: function(t3) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
    } }, { key: "setupBrushHandler", value: function() {
      var t3 = this, i2 = this.w;
      if (i2.config.chart.brush.enabled && typeof i2.config.chart.events.selection != "function") {
        var a2 = i2.config.chart.brush.targets || [i2.config.chart.brush.target];
        a2.forEach(function(e2) {
          var i3 = ApexCharts.getChartByID(e2);
          i3.w.globals.brushSource = t3.ctx, typeof i3.w.config.chart.events.zoomed != "function" && (i3.w.config.chart.events.zoomed = function() {
            t3.updateSourceChart(i3);
          }), typeof i3.w.config.chart.events.scrolled != "function" && (i3.w.config.chart.events.scrolled = function() {
            t3.updateSourceChart(i3);
          });
        }), i2.config.chart.events.selection = function(t4, s2) {
          a2.forEach(function(t5) {
            var a3 = ApexCharts.getChartByID(t5), r2 = x.clone(i2.config.yaxis);
            if (i2.config.chart.brush.autoScaleYaxis && a3.w.globals.series.length === 1) {
              var o2 = new q(a3);
              r2 = o2.autoScaleY(a3, r2, s2);
            }
            var n2 = a3.w.config.yaxis.reduce(function(t6, i3, s3) {
              return [].concat(u(t6), [e(e({}, a3.w.config.yaxis[s3]), {}, { min: r2[0].min, max: r2[0].max })]);
            }, []);
            a3.ctx.updateHelpers._updateOptions({ xaxis: { min: s2.xaxis.min, max: s2.xaxis.max }, yaxis: n2 }, false, false, false, false);
          });
        };
      }
    } }]), t2;
  }(), Ft = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "_updateOptions", value: function(t3) {
      var e2 = this, a2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], s2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], r2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], o2 = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
      return new Promise(function(n2) {
        var l2 = [e2.ctx];
        r2 && (l2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled && (l2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), l2.forEach(function(r3, h3) {
          var c2 = r3.w;
          if (c2.globals.shouldAnimate = s2, a2 || (c2.globals.resized = true, c2.globals.dataChanged = true, s2 && r3.series.getPreviousPaths()), t3 && i(t3) === "object" && (r3.config = new N(t3), t3 = y.extendArrayProps(r3.config, t3, c2), r3.w.globals.chartID !== e2.ctx.w.globals.chartID && delete t3.series, c2.config = x.extend(c2.config, t3), o2 && (c2.globals.lastXAxis = t3.xaxis ? x.clone(t3.xaxis) : [], c2.globals.lastYAxis = t3.yaxis ? x.clone(t3.yaxis) : [], c2.globals.initialConfig = x.extend({}, c2.config), c2.globals.initialSeries = x.clone(c2.config.series), t3.series))) {
            for (var d2 = 0; d2 < c2.globals.collapsedSeriesIndices.length; d2++) {
              var g2 = c2.config.series[c2.globals.collapsedSeriesIndices[d2]];
              c2.globals.collapsedSeries[d2].data = c2.globals.axisCharts ? g2.data.slice() : g2;
            }
            for (var u2 = 0; u2 < c2.globals.ancillaryCollapsedSeriesIndices.length; u2++) {
              var p3 = c2.config.series[c2.globals.ancillaryCollapsedSeriesIndices[u2]];
              c2.globals.ancillaryCollapsedSeries[u2].data = c2.globals.axisCharts ? p3.data.slice() : p3;
            }
            r3.series.emptyCollapsedSeries(c2.config.series);
          }
          return r3.update(t3).then(function() {
            h3 === l2.length - 1 && n2(r3);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(t3, e2) {
      var i2 = this, a2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
      return new Promise(function(s2) {
        var r2, o2 = i2.w;
        return o2.globals.shouldAnimate = e2, o2.globals.dataChanged = true, e2 && i2.ctx.series.getPreviousPaths(), o2.globals.axisCharts ? ((r2 = t3.map(function(t4, e3) {
          return i2._extendSeries(t4, e3);
        })).length === 0 && (r2 = [{ data: [] }]), o2.config.series = r2) : o2.config.series = t3.slice(), a2 && (o2.globals.initialSeries = x.clone(o2.config.series)), i2.ctx.update().then(function() {
          s2(i2.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(t3, i2) {
      var a2 = this.w, s2 = a2.config.series[i2];
      return e(e({}, a2.config.series[i2]), {}, { name: t3.name ? t3.name : s2 && s2.name, color: t3.color ? t3.color : s2 && s2.color, type: t3.type ? t3.type : s2 && s2.type, data: t3.data ? t3.data : s2 && s2.data });
    } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
      var i2 = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(t3, "']");
      return i2.globals.axisCharts ? a2 = i2.globals.dom.Paper.select("".concat(s2, " path[j='").concat(e2, "'], ").concat(s2, " circle[j='").concat(e2, "'], ").concat(s2, " rect[j='").concat(e2, "']")).members[0] : e2 === void 0 && (a2 = i2.globals.dom.Paper.select("".concat(s2, " path[j='").concat(t3, "']")).members[0], i2.config.chart.type !== "pie" && i2.config.chart.type !== "polarArea" && i2.config.chart.type !== "donut" || this.ctx.pie.pieClicked(t3)), a2 ? (new m(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(t3) {
      var e2 = this.w;
      if (["min", "max"].forEach(function(i3) {
        t3.xaxis[i3] !== void 0 && (e2.config.xaxis[i3] = t3.xaxis[i3], e2.globals.lastXAxis[i3] = t3.xaxis[i3]);
      }), t3.xaxis.categories && t3.xaxis.categories.length && (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
        var i2 = new D(t3);
        t3 = i2.convertCatToNumericXaxis(t3, this.ctx);
      }
      return t3;
    } }, { key: "forceYAxisUpdate", value: function(t3) {
      var e2 = this.w;
      return e2.config.chart.stacked && e2.config.chart.stackType === "100%" && (Array.isArray(t3.yaxis) ? t3.yaxis.forEach(function(e3, i2) {
        t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
      }) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
    } }, { key: "revertDefaultAxisMinMax", value: function(t3) {
      var e2 = this, i2 = this.w, a2 = i2.globals.lastXAxis, s2 = i2.globals.lastYAxis;
      t3 && t3.xaxis && (a2 = t3.xaxis), t3 && t3.yaxis && (s2 = t3.yaxis), i2.config.xaxis.min = a2.min, i2.config.xaxis.max = a2.max;
      var r2 = function(t4) {
        s2[t4] !== void 0 && (i2.config.yaxis[t4].min = s2[t4].min, i2.config.yaxis[t4].max = s2[t4].max);
      };
      i2.config.yaxis.map(function(t4, a3) {
        i2.globals.zoomed || s2[a3] !== void 0 ? r2(a3) : e2.ctx.opts.yaxis[a3] !== void 0 && (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
      });
    } }]), t2;
  }();
  It = typeof window != "undefined" ? window : void 0, zt = function(t2, e2) {
    var a2 = (this !== void 0 ? this : t2).SVG = function(t3) {
      if (a2.supported)
        return t3 = new a2.Doc(t3), a2.parser.draw || a2.prepare(), t3;
    };
    if (a2.ns = "http://www.w3.org/2000/svg", a2.xmlns = "http://www.w3.org/2000/xmlns/", a2.xlink = "http://www.w3.org/1999/xlink", a2.svgjs = "http://svgjs.dev", a2.supported = true, !a2.supported)
      return false;
    a2.did = 1e3, a2.eid = function(t3) {
      return "Svgjs" + d2(t3) + a2.did++;
    }, a2.create = function(t3) {
      var i2 = e2.createElementNS(this.ns, t3);
      return i2.setAttribute("id", this.eid(t3)), i2;
    }, a2.extend = function() {
      var t3, e3;
      e3 = (t3 = [].slice.call(arguments)).pop();
      for (var i2 = t3.length - 1; i2 >= 0; i2--)
        if (t3[i2])
          for (var s3 in e3)
            t3[i2].prototype[s3] = e3[s3];
      a2.Set && a2.Set.inherit && a2.Set.inherit();
    }, a2.invent = function(t3) {
      var e3 = typeof t3.create == "function" ? t3.create : function() {
        this.constructor.call(this, a2.create(t3.create));
      };
      return t3.inherit && (e3.prototype = new t3.inherit()), t3.extend && a2.extend(e3, t3.extend), t3.construct && a2.extend(t3.parent || a2.Container, t3.construct), e3;
    }, a2.adopt = function(e3) {
      return e3 ? e3.instance ? e3.instance : ((i2 = e3.nodeName == "svg" ? e3.parentNode instanceof t2.SVGElement ? new a2.Nested() : new a2.Doc() : e3.nodeName == "linearGradient" ? new a2.Gradient("linear") : e3.nodeName == "radialGradient" ? new a2.Gradient("radial") : a2[d2(e3.nodeName)] ? new a2[d2(e3.nodeName)]() : new a2.Element(e3)).type = e3.nodeName, i2.node = e3, e3.instance = i2, i2 instanceof a2.Doc && i2.namespace().defs(), i2.setData(JSON.parse(e3.getAttribute("svgjs:data")) || {}), i2) : null;
      var i2;
    }, a2.prepare = function() {
      var t3 = e2.getElementsByTagName("body")[0], i2 = (t3 ? new a2.Doc(t3) : a2.adopt(e2.documentElement).nested()).size(2, 0);
      a2.parser = { body: t3 || e2.documentElement, draw: i2.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: i2.polyline().node, path: i2.path().node, native: a2.create("svg") };
    }, a2.parser = { native: a2.create("svg") }, e2.addEventListener("DOMContentLoaded", function() {
      a2.parser.draw || a2.prepare();
    }, false), a2.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, a2.utils = { map: function(t3, e3) {
      for (var i2 = t3.length, a3 = [], s3 = 0; s3 < i2; s3++)
        a3.push(e3(t3[s3]));
      return a3;
    }, filter: function(t3, e3) {
      for (var i2 = t3.length, a3 = [], s3 = 0; s3 < i2; s3++)
        e3(t3[s3]) && a3.push(t3[s3]);
      return a3;
    }, filterSVGElements: function(e3) {
      return this.filter(e3, function(e4) {
        return e4 instanceof t2.SVGElement;
      });
    } }, a2.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, a2.Color = function(t3) {
      var e3, s3;
      this.r = 0, this.g = 0, this.b = 0, t3 && (typeof t3 == "string" ? a2.regex.isRgb.test(t3) ? (e3 = a2.regex.rgb.exec(t3.replace(a2.regex.whitespace, "")), this.r = parseInt(e3[1]), this.g = parseInt(e3[2]), this.b = parseInt(e3[3])) : a2.regex.isHex.test(t3) && (e3 = a2.regex.hex.exec((s3 = t3).length == 4 ? ["#", s3.substring(1, 2), s3.substring(1, 2), s3.substring(2, 3), s3.substring(2, 3), s3.substring(3, 4), s3.substring(3, 4)].join("") : s3), this.r = parseInt(e3[1], 16), this.g = parseInt(e3[2], 16), this.b = parseInt(e3[3], 16)) : i(t3) === "object" && (this.r = t3.r, this.g = t3.g, this.b = t3.b));
    }, a2.extend(a2.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + g2(this.r) + g2(this.g) + g2(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(t3) {
      return this.destination = new a2.Color(t3), this;
    }, at: function(t3) {
      return this.destination ? (t3 = t3 < 0 ? 0 : t3 > 1 ? 1 : t3, new a2.Color({ r: ~~(this.r + (this.destination.r - this.r) * t3), g: ~~(this.g + (this.destination.g - this.g) * t3), b: ~~(this.b + (this.destination.b - this.b) * t3) })) : this;
    } }), a2.Color.test = function(t3) {
      return t3 += "", a2.regex.isHex.test(t3) || a2.regex.isRgb.test(t3);
    }, a2.Color.isRgb = function(t3) {
      return t3 && typeof t3.r == "number" && typeof t3.g == "number" && typeof t3.b == "number";
    }, a2.Color.isColor = function(t3) {
      return a2.Color.isRgb(t3) || a2.Color.test(t3);
    }, a2.Array = function(t3, e3) {
      (t3 = (t3 || []).valueOf()).length == 0 && e3 && (t3 = e3.valueOf()), this.value = this.parse(t3);
    }, a2.extend(a2.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(t3) {
      return t3 = t3.valueOf(), Array.isArray(t3) ? t3 : this.split(t3);
    } }), a2.PointArray = function(t3, e3) {
      a2.Array.call(this, t3, e3 || [[0, 0]]);
    }, a2.PointArray.prototype = new a2.Array(), a2.PointArray.prototype.constructor = a2.PointArray;
    for (var s2 = { M: function(t3, e3, i2) {
      return e3.x = i2.x = t3[0], e3.y = i2.y = t3[1], ["M", e3.x, e3.y];
    }, L: function(t3, e3) {
      return e3.x = t3[0], e3.y = t3[1], ["L", t3[0], t3[1]];
    }, H: function(t3, e3) {
      return e3.x = t3[0], ["H", t3[0]];
    }, V: function(t3, e3) {
      return e3.y = t3[0], ["V", t3[0]];
    }, C: function(t3, e3) {
      return e3.x = t3[4], e3.y = t3[5], ["C", t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]];
    }, Q: function(t3, e3) {
      return e3.x = t3[2], e3.y = t3[3], ["Q", t3[0], t3[1], t3[2], t3[3]];
    }, Z: function(t3, e3, i2) {
      return e3.x = i2.x, e3.y = i2.y, ["Z"];
    } }, r2 = "mlhvqtcsaz".split(""), o2 = 0, n2 = r2.length; o2 < n2; ++o2)
      s2[r2[o2]] = function(t3) {
        return function(e3, i2, a3) {
          if (t3 == "H")
            e3[0] = e3[0] + i2.x;
          else if (t3 == "V")
            e3[0] = e3[0] + i2.y;
          else if (t3 == "A")
            e3[5] = e3[5] + i2.x, e3[6] = e3[6] + i2.y;
          else
            for (var r3 = 0, o3 = e3.length; r3 < o3; ++r3)
              e3[r3] = e3[r3] + (r3 % 2 ? i2.y : i2.x);
          if (s2 && typeof s2[t3] == "function")
            return s2[t3](e3, i2, a3);
        };
      }(r2[o2].toUpperCase());
    a2.PathArray = function(t3, e3) {
      a2.Array.call(this, t3, e3 || [["M", 0, 0]]);
    }, a2.PathArray.prototype = new a2.Array(), a2.PathArray.prototype.constructor = a2.PathArray, a2.extend(a2.PathArray, { toString: function() {
      return function(t3) {
        for (var e3 = 0, i2 = t3.length, a3 = ""; e3 < i2; e3++)
          a3 += t3[e3][0], t3[e3][1] != null && (a3 += t3[e3][1], t3[e3][2] != null && (a3 += " ", a3 += t3[e3][2], t3[e3][3] != null && (a3 += " ", a3 += t3[e3][3], a3 += " ", a3 += t3[e3][4], t3[e3][5] != null && (a3 += " ", a3 += t3[e3][5], a3 += " ", a3 += t3[e3][6], t3[e3][7] != null && (a3 += " ", a3 += t3[e3][7])))));
        return a3 + " ";
      }(this.value);
    }, move: function(t3, e3) {
      var i2 = this.bbox();
      return i2.x, i2.y, this;
    }, at: function(t3) {
      if (!this.destination)
        return this;
      for (var e3 = this.value, i2 = this.destination.value, s3 = [], r3 = new a2.PathArray(), o3 = 0, n3 = e3.length; o3 < n3; o3++) {
        s3[o3] = [e3[o3][0]];
        for (var l3 = 1, h4 = e3[o3].length; l3 < h4; l3++)
          s3[o3][l3] = e3[o3][l3] + (i2[o3][l3] - e3[o3][l3]) * t3;
        s3[o3][0] === "A" && (s3[o3][4] = +(s3[o3][4] != 0), s3[o3][5] = +(s3[o3][5] != 0));
      }
      return r3.value = s3, r3;
    }, parse: function(t3) {
      if (t3 instanceof a2.PathArray)
        return t3.valueOf();
      var e3, i2 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      t3 = typeof t3 == "string" ? t3.replace(a2.regex.numbersWithDots, h3).replace(a2.regex.pathLetters, " $& ").replace(a2.regex.hyphen, "$1 -").trim().split(a2.regex.delimiter) : t3.reduce(function(t4, e4) {
        return [].concat.call(t4, e4);
      }, []);
      var r3 = [], o3 = new a2.Point(), n3 = new a2.Point(), l3 = 0, c3 = t3.length;
      do {
        a2.regex.isPathLetter.test(t3[l3]) ? (e3 = t3[l3], ++l3) : e3 == "M" ? e3 = "L" : e3 == "m" && (e3 = "l"), r3.push(s2[e3].call(null, t3.slice(l3, l3 += i2[e3.toUpperCase()]).map(parseFloat), o3, n3));
      } while (c3 > l3);
      return r3;
    }, bbox: function() {
      return a2.parser.draw || a2.prepare(), a2.parser.path.setAttribute("d", this.toString()), a2.parser.path.getBBox();
    } }), a2.Number = a2.invent({ create: function(t3, e3) {
      this.value = 0, this.unit = e3 || "", typeof t3 == "number" ? this.value = isNaN(t3) ? 0 : isFinite(t3) ? t3 : t3 < 0 ? -34e37 : 34e37 : typeof t3 == "string" ? (e3 = t3.match(a2.regex.numberAndUnit)) && (this.value = parseFloat(e3[1]), e3[5] == "%" ? this.value /= 100 : e3[5] == "s" && (this.value *= 1e3), this.unit = e3[5]) : t3 instanceof a2.Number && (this.value = t3.valueOf(), this.unit = t3.unit);
    }, extend: { toString: function() {
      return (this.unit == "%" ? ~~(1e8 * this.value) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(t3) {
      return t3 = new a2.Number(t3), new a2.Number(this + t3, this.unit || t3.unit);
    }, minus: function(t3) {
      return t3 = new a2.Number(t3), new a2.Number(this - t3, this.unit || t3.unit);
    }, times: function(t3) {
      return t3 = new a2.Number(t3), new a2.Number(this * t3, this.unit || t3.unit);
    }, divide: function(t3) {
      return t3 = new a2.Number(t3), new a2.Number(this / t3, this.unit || t3.unit);
    }, to: function(t3) {
      var e3 = new a2.Number(this);
      return typeof t3 == "string" && (e3.unit = t3), e3;
    }, morph: function(t3) {
      return this.destination = new a2.Number(t3), t3.relative && (this.destination.value += this.value), this;
    }, at: function(t3) {
      return this.destination ? new a2.Number(this.destination).minus(this).times(t3).plus(this) : this;
    } } }), a2.Element = a2.invent({ create: function(t3) {
      this._stroke = a2.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t3) && (this.type = t3.nodeName, this.node.instance = this, this._stroke = t3.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(t3) {
      return this.attr("x", t3);
    }, y: function(t3) {
      return this.attr("y", t3);
    }, cx: function(t3) {
      return t3 == null ? this.x() + this.width() / 2 : this.x(t3 - this.width() / 2);
    }, cy: function(t3) {
      return t3 == null ? this.y() + this.height() / 2 : this.y(t3 - this.height() / 2);
    }, move: function(t3, e3) {
      return this.x(t3).y(e3);
    }, center: function(t3, e3) {
      return this.cx(t3).cy(e3);
    }, width: function(t3) {
      return this.attr("width", t3);
    }, height: function(t3) {
      return this.attr("height", t3);
    }, size: function(t3, e3) {
      var i2 = u2(this, t3, e3);
      return this.width(new a2.Number(i2.width)).height(new a2.Number(i2.height));
    }, clone: function(t3) {
      this.writeDataToDom();
      var e3 = x2(this.node.cloneNode(true));
      return t3 ? t3.add(e3) : this.after(e3), e3;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(t3) {
      return this.after(t3).remove(), t3;
    }, addTo: function(t3) {
      return t3.put(this);
    }, putIn: function(t3) {
      return t3.add(this);
    }, id: function(t3) {
      return this.attr("id", t3);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return this.style("display") != "none";
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var t3 = this.attr("class");
      return t3 == null ? [] : t3.trim().split(a2.regex.delimiter);
    }, hasClass: function(t3) {
      return this.classes().indexOf(t3) != -1;
    }, addClass: function(t3) {
      if (!this.hasClass(t3)) {
        var e3 = this.classes();
        e3.push(t3), this.attr("class", e3.join(" "));
      }
      return this;
    }, removeClass: function(t3) {
      return this.hasClass(t3) && this.attr("class", this.classes().filter(function(e3) {
        return e3 != t3;
      }).join(" ")), this;
    }, toggleClass: function(t3) {
      return this.hasClass(t3) ? this.removeClass(t3) : this.addClass(t3);
    }, reference: function(t3) {
      return a2.get(this.attr(t3));
    }, parent: function(e3) {
      var i2 = this;
      if (!i2.node.parentNode)
        return null;
      if (i2 = a2.adopt(i2.node.parentNode), !e3)
        return i2;
      for (; i2 && i2.node instanceof t2.SVGElement; ) {
        if (typeof e3 == "string" ? i2.matches(e3) : i2 instanceof e3)
          return i2;
        if (!i2.node.parentNode || i2.node.parentNode.nodeName == "#document")
          return null;
        i2 = a2.adopt(i2.node.parentNode);
      }
    }, doc: function() {
      return this instanceof a2.Doc ? this : this.parent(a2.Doc);
    }, parents: function(t3) {
      var e3 = [], i2 = this;
      do {
        if (!(i2 = i2.parent(t3)) || !i2.node)
          break;
        e3.push(i2);
      } while (i2.parent);
      return e3;
    }, matches: function(t3) {
      return function(t4, e3) {
        return (t4.matches || t4.matchesSelector || t4.msMatchesSelector || t4.mozMatchesSelector || t4.webkitMatchesSelector || t4.oMatchesSelector).call(t4, e3);
      }(this.node, t3);
    }, native: function() {
      return this.node;
    }, svg: function(t3) {
      var i2 = e2.createElement("svg");
      if (!(t3 && this instanceof a2.Parent))
        return i2.appendChild(t3 = e2.createElement("svg")), this.writeDataToDom(), t3.appendChild(this.node.cloneNode(true)), i2.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      i2.innerHTML = "<svg>" + t3.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var s3 = 0, r3 = i2.firstChild.childNodes.length; s3 < r3; s3++)
        this.node.appendChild(i2.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(t3) {
      return this.dom = t3, this;
    }, is: function(t3) {
      return function(t4, e3) {
        return t4 instanceof e3;
      }(this, t3);
    } } }), a2.easing = { "-": function(t3) {
      return t3;
    }, "<>": function(t3) {
      return -Math.cos(t3 * Math.PI) / 2 + 0.5;
    }, ">": function(t3) {
      return Math.sin(t3 * Math.PI / 2);
    }, "<": function(t3) {
      return 1 - Math.cos(t3 * Math.PI / 2);
    } }, a2.morph = function(t3) {
      return function(e3, i2) {
        return new a2.MorphObj(e3, i2).at(t3);
      };
    }, a2.Situation = a2.invent({ create: function(t3) {
      this.init = false, this.reversed = false, this.reversing = false, this.duration = new a2.Number(t3.duration).valueOf(), this.delay = new a2.Number(t3.delay).valueOf(), this.start = +new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t3.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), a2.FX = a2.invent({ create: function(t3) {
      this._target = t3, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(t3, e3, s3) {
      i(t3) === "object" && (e3 = t3.ease, s3 = t3.delay, t3 = t3.duration);
      var r3 = new a2.Situation({ duration: t3 || 1e3, delay: s3 || 0, ease: a2.easing[e3 || "-"] || e3 });
      return this.queue(r3), this;
    }, target: function(t3) {
      return t3 && t3 instanceof a2.Element ? (this._target = t3, this) : this._target;
    }, timeToAbsPos: function(t3) {
      return (t3 - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(t3) {
      return this.situation.duration / this._speed * t3 + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = t2.requestAnimationFrame(function() {
        this.step();
      }.bind(this));
    }, stopAnimFrame: function() {
      t2.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(t3) {
      return (typeof t3 == "function" || t3 instanceof a2.Situation) && this.situations.push(t3), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a2.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var t3, e3 = this.situation;
      if (e3.init)
        return this;
      for (var i2 in e3.animations) {
        t3 = this.target()[i2](), Array.isArray(t3) || (t3 = [t3]), Array.isArray(e3.animations[i2]) || (e3.animations[i2] = [e3.animations[i2]]);
        for (var s3 = t3.length; s3--; )
          e3.animations[i2][s3] instanceof a2.Number && (t3[s3] = new a2.Number(t3[s3])), e3.animations[i2][s3] = t3[s3].morph(e3.animations[i2][s3]);
      }
      for (var i2 in e3.attrs)
        e3.attrs[i2] = new a2.MorphObj(this.target().attr(i2), e3.attrs[i2]);
      for (var i2 in e3.styles)
        e3.styles[i2] = new a2.MorphObj(this.target().style(i2), e3.styles[i2]);
      return e3.initialTransformation = this.target().matrixify(), e3.init = true, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(t3, e3) {
      var i2 = this.active;
      return this.active = false, e3 && this.clearQueue(), t3 && this.situation && (!i2 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(t3) {
      var e3 = this.last();
      return this.target().on("finished.fx", function i2(a3) {
        a3.detail.situation == e3 && (t3.call(this, e3), this.off("finished.fx", i2));
      }), this._callStart();
    }, during: function(t3) {
      var e3 = this.last(), i2 = function(i3) {
        i3.detail.situation == e3 && t3.call(this, i3.detail.pos, a2.morph(i3.detail.pos), i3.detail.eased, e3);
      };
      return this.target().off("during.fx", i2).on("during.fx", i2), this.after(function() {
        this.off("during.fx", i2);
      }), this._callStart();
    }, afterAll: function(t3) {
      var e3 = function e4(i2) {
        t3.call(this), this.off("allfinished.fx", e4);
      };
      return this.target().off("allfinished.fx", e3).on("allfinished.fx", e3), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(t3, e3, i2) {
      return this.last()[i2 || "animations"][t3] = e3, this._callStart();
    }, step: function(t3) {
      var e3, i2, a3;
      t3 || (this.absPos = this.timeToAbsPos(+new Date())), this.situation.loops !== false ? (e3 = Math.max(this.absPos, 0), i2 = Math.floor(e3), this.situation.loops === true || i2 < this.situation.loops ? (this.pos = e3 - i2, a3 = this.situation.loop, this.situation.loop = i2) : (this.absPos = this.situation.loops, this.pos = 1, a3 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a3) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var s3 = this.situation.ease(this.pos);
      for (var r3 in this.situation.once)
        r3 > this.lastPos && r3 <= s3 && (this.situation.once[r3].call(this.target(), this.pos, s3), delete this.situation.once[r3]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: s3, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s3, this) : this;
    }, eachAt: function() {
      var t3, e3 = this, i2 = this.target(), s3 = this.situation;
      for (var r3 in s3.animations)
        t3 = [].concat(s3.animations[r3]).map(function(t4) {
          return typeof t4 != "string" && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
        }), i2[r3].apply(i2, t3);
      for (var r3 in s3.attrs)
        t3 = [r3].concat(s3.attrs[r3]).map(function(t4) {
          return typeof t4 != "string" && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
        }), i2.attr.apply(i2, t3);
      for (var r3 in s3.styles)
        t3 = [r3].concat(s3.styles[r3]).map(function(t4) {
          return typeof t4 != "string" && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
        }), i2.style.apply(i2, t3);
      if (s3.transforms.length) {
        t3 = s3.initialTransformation, r3 = 0;
        for (var o3 = s3.transforms.length; r3 < o3; r3++) {
          var n3 = s3.transforms[r3];
          n3 instanceof a2.Matrix ? t3 = n3.relative ? t3.multiply(new a2.Matrix().morph(n3).at(s3.ease(this.pos))) : t3.morph(n3).at(s3.ease(this.pos)) : (n3.relative || n3.undo(t3.extract()), t3 = t3.multiply(n3.at(s3.ease(this.pos))));
        }
        i2.matrix(t3);
      }
      return this;
    }, once: function(t3, e3, i2) {
      var a3 = this.last();
      return i2 || (t3 = a3.ease(t3)), a3.once[t3] = e3, this;
    }, _callStart: function() {
      return setTimeout(function() {
        this.start();
      }.bind(this), 0), this;
    } }, parent: a2.Element, construct: { animate: function(t3, e3, i2) {
      return (this.fx || (this.fx = new a2.FX(this))).animate(t3, e3, i2);
    }, delay: function(t3) {
      return (this.fx || (this.fx = new a2.FX(this))).delay(t3);
    }, stop: function(t3, e3) {
      return this.fx && this.fx.stop(t3, e3), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), a2.MorphObj = a2.invent({ create: function(t3, e3) {
      return a2.Color.isColor(e3) ? new a2.Color(t3).morph(e3) : a2.regex.delimiter.test(t3) ? a2.regex.pathLetters.test(t3) ? new a2.PathArray(t3).morph(e3) : new a2.Array(t3).morph(e3) : a2.regex.numberAndUnit.test(e3) ? new a2.Number(t3).morph(e3) : (this.value = t3, void (this.destination = e3));
    }, extend: { at: function(t3, e3) {
      return e3 < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), a2.extend(a2.FX, { attr: function(t3, e3, a3) {
      if (i(t3) === "object")
        for (var s3 in t3)
          this.attr(s3, t3[s3]);
      else
        this.add(t3, e3, "attrs");
      return this;
    }, plot: function(t3, e3, i2, a3) {
      return arguments.length == 4 ? this.plot([t3, e3, i2, a3]) : this.add("plot", new (this.target()).morphArray(t3));
    } }), a2.Box = a2.invent({ create: function(t3, e3, s3, r3) {
      if (!(i(t3) !== "object" || t3 instanceof a2.Element))
        return a2.Box.call(this, t3.left != null ? t3.left : t3.x, t3.top != null ? t3.top : t3.y, t3.width, t3.height);
      arguments.length == 4 && (this.x = t3, this.y = e3, this.width = s3, this.height = r3), b2(this);
    } }), a2.BBox = a2.invent({ create: function(t3) {
      if (a2.Box.apply(this, [].slice.call(arguments)), t3 instanceof a2.Element) {
        var i2;
        try {
          if (!e2.documentElement.contains) {
            for (var s3 = t3.node; s3.parentNode; )
              s3 = s3.parentNode;
            if (s3 != e2)
              throw new Error("Element not in the dom");
          }
          i2 = t3.node.getBBox();
        } catch (e3) {
          if (t3 instanceof a2.Shape) {
            a2.parser.draw || a2.prepare();
            var r3 = t3.clone(a2.parser.draw.instance).show();
            r3 && r3.node && typeof r3.node.getBBox == "function" && (i2 = r3.node.getBBox()), r3 && typeof r3.remove == "function" && r3.remove();
          } else
            i2 = { x: t3.node.clientLeft, y: t3.node.clientTop, width: t3.node.clientWidth, height: t3.node.clientHeight };
        }
        a2.Box.call(this, i2);
      }
    }, inherit: a2.Box, parent: a2.Element, construct: { bbox: function() {
      return new a2.BBox(this);
    } } }), a2.BBox.prototype.constructor = a2.BBox, a2.Matrix = a2.invent({ create: function(t3) {
      var e3 = f2([1, 0, 0, 1, 0, 0]);
      t3 = t3 === null ? e3 : t3 instanceof a2.Element ? t3.matrixify() : typeof t3 == "string" ? f2(t3.split(a2.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? f2([].slice.call(arguments)) : Array.isArray(t3) ? f2(t3) : t3 && i(t3) === "object" ? t3 : e3;
      for (var s3 = m2.length - 1; s3 >= 0; --s3)
        this[m2[s3]] = t3[m2[s3]] != null ? t3[m2[s3]] : e3[m2[s3]];
    }, extend: { extract: function() {
      var t3 = p3(this, 0, 1);
      p3(this, 1, 0);
      var e3 = 180 / Math.PI * Math.atan2(t3.y, t3.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(e3 * Math.PI / 180) + this.f * Math.sin(e3 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e3 * Math.PI / 180) + this.e * Math.sin(-e3 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e3, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new a2.Matrix(this) };
    }, clone: function() {
      return new a2.Matrix(this);
    }, morph: function(t3) {
      return this.destination = new a2.Matrix(t3), this;
    }, multiply: function(t3) {
      return new a2.Matrix(this.native().multiply(function(t4) {
        return t4 instanceof a2.Matrix || (t4 = new a2.Matrix(t4)), t4;
      }(t3).native()));
    }, inverse: function() {
      return new a2.Matrix(this.native().inverse());
    }, translate: function(t3, e3) {
      return new a2.Matrix(this.native().translate(t3 || 0, e3 || 0));
    }, native: function() {
      for (var t3 = a2.parser.native.createSVGMatrix(), e3 = m2.length - 1; e3 >= 0; e3--)
        t3[m2[e3]] = this[m2[e3]];
      return t3;
    }, toString: function() {
      return "matrix(" + v2(this.a) + "," + v2(this.b) + "," + v2(this.c) + "," + v2(this.d) + "," + v2(this.e) + "," + v2(this.f) + ")";
    } }, parent: a2.Element, construct: { ctm: function() {
      return new a2.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof a2.Nested) {
        var t3 = this.rect(1, 1), e3 = t3.node.getScreenCTM();
        return t3.remove(), new a2.Matrix(e3);
      }
      return new a2.Matrix(this.node.getScreenCTM());
    } } }), a2.Point = a2.invent({ create: function(t3, e3) {
      var a3;
      a3 = Array.isArray(t3) ? { x: t3[0], y: t3[1] } : i(t3) === "object" ? { x: t3.x, y: t3.y } : t3 != null ? { x: t3, y: e3 != null ? e3 : t3 } : { x: 0, y: 0 }, this.x = a3.x, this.y = a3.y;
    }, extend: { clone: function() {
      return new a2.Point(this);
    }, morph: function(t3, e3) {
      return this.destination = new a2.Point(t3, e3), this;
    } } }), a2.extend(a2.Element, { point: function(t3, e3) {
      return new a2.Point(t3, e3).transform(this.screenCTM().inverse());
    } }), a2.extend(a2.Element, { attr: function(t3, e3, s3) {
      if (t3 == null) {
        for (t3 = {}, s3 = (e3 = this.node.attributes).length - 1; s3 >= 0; s3--)
          t3[e3[s3].nodeName] = a2.regex.isNumber.test(e3[s3].nodeValue) ? parseFloat(e3[s3].nodeValue) : e3[s3].nodeValue;
        return t3;
      }
      if (i(t3) === "object")
        for (var r3 in t3)
          this.attr(r3, t3[r3]);
      else if (e3 === null)
        this.node.removeAttribute(t3);
      else {
        if (e3 == null)
          return (e3 = this.node.getAttribute(t3)) == null ? a2.defaults.attrs[t3] : a2.regex.isNumber.test(e3) ? parseFloat(e3) : e3;
        t3 == "stroke-width" ? this.attr("stroke", parseFloat(e3) > 0 ? this._stroke : null) : t3 == "stroke" && (this._stroke = e3), t3 != "fill" && t3 != "stroke" || (a2.regex.isImage.test(e3) && (e3 = this.doc().defs().image(e3, 0, 0)), e3 instanceof a2.Image && (e3 = this.doc().defs().pattern(0, 0, function() {
          this.add(e3);
        }))), typeof e3 == "number" ? e3 = new a2.Number(e3) : a2.Color.isColor(e3) ? e3 = new a2.Color(e3) : Array.isArray(e3) && (e3 = new a2.Array(e3)), t3 == "leading" ? this.leading && this.leading(e3) : typeof s3 == "string" ? this.node.setAttributeNS(s3, t3, e3.toString()) : this.node.setAttribute(t3, e3.toString()), !this.rebuild || t3 != "font-size" && t3 != "x" || this.rebuild(t3, e3);
      }
      return this;
    } }), a2.extend(a2.Element, { transform: function(t3, e3) {
      var s3;
      return i(t3) !== "object" ? (s3 = new a2.Matrix(this).extract(), typeof t3 == "string" ? s3[t3] : s3) : (s3 = new a2.Matrix(this), e3 = !!e3 || !!t3.relative, t3.a != null && (s3 = e3 ? s3.multiply(new a2.Matrix(t3)) : new a2.Matrix(t3)), this.attr("transform", s3));
    } }), a2.extend(a2.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(a2.regex.transforms).slice(0, -1).map(function(t3) {
        var e3 = t3.trim().split("(");
        return [e3[0], e3[1].split(a2.regex.delimiter).map(function(t4) {
          return parseFloat(t4);
        })];
      }).reduce(function(t3, e3) {
        return e3[0] == "matrix" ? t3.multiply(f2(e3[1])) : t3[e3[0]].apply(t3, e3[1]);
      }, new a2.Matrix());
    }, toParent: function(t3) {
      if (this == t3)
        return this;
      var e3 = this.screenCTM(), i2 = t3.screenCTM().inverse();
      return this.addTo(t3).untransform().transform(i2.multiply(e3)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), a2.Transformation = a2.invent({ create: function(t3, e3) {
      if (arguments.length > 1 && typeof e3 != "boolean")
        return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(t3))
        for (var a3 = 0, s3 = this.arguments.length; a3 < s3; ++a3)
          this[this.arguments[a3]] = t3[a3];
      else if (t3 && i(t3) === "object")
        for (a3 = 0, s3 = this.arguments.length; a3 < s3; ++a3)
          this[this.arguments[a3]] = t3[this.arguments[a3]];
      this.inversed = false, e3 === true && (this.inversed = true);
    } }), a2.Translate = a2.invent({ parent: a2.Matrix, inherit: a2.Transformation, create: function(t3, e3) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), a2.extend(a2.Element, { style: function(t3, e3) {
      if (arguments.length == 0)
        return this.node.style.cssText || "";
      if (arguments.length < 2)
        if (i(t3) === "object")
          for (var s3 in t3)
            this.style(s3, t3[s3]);
        else {
          if (!a2.regex.isCss.test(t3))
            return this.node.style[c2(t3)];
          for (t3 = t3.split(/\s*;\s*/).filter(function(t4) {
            return !!t4;
          }).map(function(t4) {
            return t4.split(/\s*:\s*/);
          }); e3 = t3.pop(); )
            this.style(e3[0], e3[1]);
        }
      else
        this.node.style[c2(t3)] = e3 === null || a2.regex.isBlank.test(e3) ? "" : e3;
      return this;
    } }), a2.Parent = a2.invent({ create: function(t3) {
      this.constructor.call(this, t3);
    }, inherit: a2.Element, extend: { children: function() {
      return a2.utils.map(a2.utils.filterSVGElements(this.node.childNodes), function(t3) {
        return a2.adopt(t3);
      });
    }, add: function(t3, e3) {
      return e3 == null ? this.node.appendChild(t3.node) : t3.node != this.node.childNodes[e3] && this.node.insertBefore(t3.node, this.node.childNodes[e3]), this;
    }, put: function(t3, e3) {
      return this.add(t3, e3), t3;
    }, has: function(t3) {
      return this.index(t3) >= 0;
    }, index: function(t3) {
      return [].slice.call(this.node.childNodes).indexOf(t3.node);
    }, get: function(t3) {
      return a2.adopt(this.node.childNodes[t3]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(t3, e3) {
      for (var i2 = this.children(), s3 = 0, r3 = i2.length; s3 < r3; s3++)
        i2[s3] instanceof a2.Element && t3.apply(i2[s3], [s3, i2]), e3 && i2[s3] instanceof a2.Container && i2[s3].each(t3, e3);
      return this;
    }, removeElement: function(t3) {
      return this.node.removeChild(t3.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), a2.extend(a2.Parent, { ungroup: function(t3, e3) {
      return e3 === 0 || this instanceof a2.Defs || this.node == a2.parser.draw || (t3 = t3 || (this instanceof a2.Doc ? this : this.parent(a2.Parent)), e3 = e3 || 1 / 0, this.each(function() {
        return this instanceof a2.Defs ? this : this instanceof a2.Parent ? this.ungroup(t3, e3 - 1) : this.toParent(t3);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(t3, e3) {
      return this.ungroup(t3, e3);
    } }), a2.Container = a2.invent({ create: function(t3) {
      this.constructor.call(this, t3);
    }, inherit: a2.Parent }), a2.ViewBox = a2.invent({ parent: a2.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t3) {
      a2.Element.prototype[t3] = function(e3) {
        return a2.on(this.node, t3, e3), this;
      };
    }), a2.listeners = [], a2.handlerMap = [], a2.listenerId = 0, a2.on = function(t3, e3, i2, s3, r3) {
      var o3 = i2.bind(s3 || t3.instance || t3), n3 = (a2.handlerMap.indexOf(t3) + 1 || a2.handlerMap.push(t3)) - 1, l3 = e3.split(".")[0], h4 = e3.split(".")[1] || "*";
      a2.listeners[n3] = a2.listeners[n3] || {}, a2.listeners[n3][l3] = a2.listeners[n3][l3] || {}, a2.listeners[n3][l3][h4] = a2.listeners[n3][l3][h4] || {}, i2._svgjsListenerId || (i2._svgjsListenerId = ++a2.listenerId), a2.listeners[n3][l3][h4][i2._svgjsListenerId] = o3, t3.addEventListener(l3, o3, r3 || { passive: true });
    }, a2.off = function(t3, e3, i2) {
      var s3 = a2.handlerMap.indexOf(t3), r3 = e3 && e3.split(".")[0], o3 = e3 && e3.split(".")[1], n3 = "";
      if (s3 != -1)
        if (i2) {
          if (typeof i2 == "function" && (i2 = i2._svgjsListenerId), !i2)
            return;
          a2.listeners[s3][r3] && a2.listeners[s3][r3][o3 || "*"] && (t3.removeEventListener(r3, a2.listeners[s3][r3][o3 || "*"][i2], false), delete a2.listeners[s3][r3][o3 || "*"][i2]);
        } else if (o3 && r3) {
          if (a2.listeners[s3][r3] && a2.listeners[s3][r3][o3]) {
            for (var l3 in a2.listeners[s3][r3][o3])
              a2.off(t3, [r3, o3].join("."), l3);
            delete a2.listeners[s3][r3][o3];
          }
        } else if (o3)
          for (var h4 in a2.listeners[s3])
            for (var n3 in a2.listeners[s3][h4])
              o3 === n3 && a2.off(t3, [h4, o3].join("."));
        else if (r3) {
          if (a2.listeners[s3][r3]) {
            for (var n3 in a2.listeners[s3][r3])
              a2.off(t3, [r3, n3].join("."));
            delete a2.listeners[s3][r3];
          }
        } else {
          for (var h4 in a2.listeners[s3])
            a2.off(t3, h4);
          delete a2.listeners[s3], delete a2.handlerMap[s3];
        }
    }, a2.extend(a2.Element, { on: function(t3, e3, i2, s3) {
      return a2.on(this.node, t3, e3, i2, s3), this;
    }, off: function(t3, e3) {
      return a2.off(this.node, t3, e3), this;
    }, fire: function(e3, i2) {
      return e3 instanceof t2.Event ? this.node.dispatchEvent(e3) : this.node.dispatchEvent(e3 = new a2.CustomEvent(e3, { detail: i2, cancelable: true })), this._event = e3, this;
    }, event: function() {
      return this._event;
    } }), a2.Defs = a2.invent({ create: "defs", inherit: a2.Container }), a2.G = a2.invent({ create: "g", inherit: a2.Container, extend: { x: function(t3) {
      return t3 == null ? this.transform("x") : this.transform({ x: t3 - this.x() }, true);
    } }, construct: { group: function() {
      return this.put(new a2.G());
    } } }), a2.Doc = a2.invent({ create: function(t3) {
      t3 && ((t3 = typeof t3 == "string" ? e2.getElementById(t3) : t3).nodeName == "svg" ? this.constructor.call(this, t3) : (this.constructor.call(this, a2.create("svg")), t3.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: a2.Container, extend: { namespace: function() {
      return this.attr({ xmlns: a2.ns, version: "1.1" }).attr("xmlns:xlink", a2.xlink, a2.xmlns).attr("xmlns:svgjs", a2.svgjs, a2.xmlns);
    }, defs: function() {
      var t3;
      return this._defs || ((t3 = this.node.getElementsByTagName("defs")[0]) ? this._defs = a2.adopt(t3) : this._defs = new a2.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && this.node.parentNode.nodeName != "#document" ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, a2.parser.draw && !a2.parser.draw.parentNode && this.node.appendChild(a2.parser.draw), this;
    }, clone: function(t3) {
      this.writeDataToDom();
      var e3 = this.node, i2 = x2(e3.cloneNode(true));
      return t3 ? (t3.node || t3).appendChild(i2.node) : e3.parentNode.insertBefore(i2.node, e3.nextSibling), i2;
    } } }), a2.extend(a2.Element, {}), a2.Gradient = a2.invent({ create: function(t3) {
      this.constructor.call(this, a2.create(t3 + "Gradient")), this.type = t3;
    }, inherit: a2.Container, extend: { at: function(t3, e3, i2) {
      return this.put(new a2.Stop()).update(t3, e3, i2);
    }, update: function(t3) {
      return this.clear(), typeof t3 == "function" && t3.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(t3, e3, i2) {
      return t3 == "transform" && (t3 = "gradientTransform"), a2.Container.prototype.attr.call(this, t3, e3, i2);
    } }, construct: { gradient: function(t3, e3) {
      return this.defs().gradient(t3, e3);
    } } }), a2.extend(a2.Gradient, a2.FX, { from: function(t3, e3) {
      return (this._target || this).type == "radial" ? this.attr({ fx: new a2.Number(t3), fy: new a2.Number(e3) }) : this.attr({ x1: new a2.Number(t3), y1: new a2.Number(e3) });
    }, to: function(t3, e3) {
      return (this._target || this).type == "radial" ? this.attr({ cx: new a2.Number(t3), cy: new a2.Number(e3) }) : this.attr({ x2: new a2.Number(t3), y2: new a2.Number(e3) });
    } }), a2.extend(a2.Defs, { gradient: function(t3, e3) {
      return this.put(new a2.Gradient(t3)).update(e3);
    } }), a2.Stop = a2.invent({ create: "stop", inherit: a2.Element, extend: { update: function(t3) {
      return (typeof t3 == "number" || t3 instanceof a2.Number) && (t3 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), t3.opacity != null && this.attr("stop-opacity", t3.opacity), t3.color != null && this.attr("stop-color", t3.color), t3.offset != null && this.attr("offset", new a2.Number(t3.offset)), this;
    } } }), a2.Pattern = a2.invent({ create: "pattern", inherit: a2.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(t3) {
      return this.clear(), typeof t3 == "function" && t3.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(t3, e3, i2) {
      return t3 == "transform" && (t3 = "patternTransform"), a2.Container.prototype.attr.call(this, t3, e3, i2);
    } }, construct: { pattern: function(t3, e3, i2) {
      return this.defs().pattern(t3, e3, i2);
    } } }), a2.extend(a2.Defs, { pattern: function(t3, e3, i2) {
      return this.put(new a2.Pattern()).update(i2).attr({ x: 0, y: 0, width: t3, height: e3, patternUnits: "userSpaceOnUse" });
    } }), a2.Shape = a2.invent({ create: function(t3) {
      this.constructor.call(this, t3);
    }, inherit: a2.Element }), a2.Symbol = a2.invent({ create: "symbol", inherit: a2.Container, construct: { symbol: function() {
      return this.put(new a2.Symbol());
    } } }), a2.Use = a2.invent({ create: "use", inherit: a2.Shape, extend: { element: function(t3, e3) {
      return this.attr("href", (e3 || "") + "#" + t3, a2.xlink);
    } }, construct: { use: function(t3, e3) {
      return this.put(new a2.Use()).element(t3, e3);
    } } }), a2.Rect = a2.invent({ create: "rect", inherit: a2.Shape, construct: { rect: function(t3, e3) {
      return this.put(new a2.Rect()).size(t3, e3);
    } } }), a2.Circle = a2.invent({ create: "circle", inherit: a2.Shape, construct: { circle: function(t3) {
      return this.put(new a2.Circle()).rx(new a2.Number(t3).divide(2)).move(0, 0);
    } } }), a2.extend(a2.Circle, a2.FX, { rx: function(t3) {
      return this.attr("r", t3);
    }, ry: function(t3) {
      return this.rx(t3);
    } }), a2.Ellipse = a2.invent({ create: "ellipse", inherit: a2.Shape, construct: { ellipse: function(t3, e3) {
      return this.put(new a2.Ellipse()).size(t3, e3).move(0, 0);
    } } }), a2.extend(a2.Ellipse, a2.Rect, a2.FX, { rx: function(t3) {
      return this.attr("rx", t3);
    }, ry: function(t3) {
      return this.attr("ry", t3);
    } }), a2.extend(a2.Circle, a2.Ellipse, { x: function(t3) {
      return t3 == null ? this.cx() - this.rx() : this.cx(t3 + this.rx());
    }, y: function(t3) {
      return t3 == null ? this.cy() - this.ry() : this.cy(t3 + this.ry());
    }, cx: function(t3) {
      return t3 == null ? this.attr("cx") : this.attr("cx", t3);
    }, cy: function(t3) {
      return t3 == null ? this.attr("cy") : this.attr("cy", t3);
    }, width: function(t3) {
      return t3 == null ? 2 * this.rx() : this.rx(new a2.Number(t3).divide(2));
    }, height: function(t3) {
      return t3 == null ? 2 * this.ry() : this.ry(new a2.Number(t3).divide(2));
    }, size: function(t3, e3) {
      var i2 = u2(this, t3, e3);
      return this.rx(new a2.Number(i2.width).divide(2)).ry(new a2.Number(i2.height).divide(2));
    } }), a2.Line = a2.invent({ create: "line", inherit: a2.Shape, extend: { array: function() {
      return new a2.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(t3, e3, i2, s3) {
      return t3 == null ? this.array() : (t3 = e3 !== void 0 ? { x1: t3, y1: e3, x2: i2, y2: s3 } : new a2.PointArray(t3).toLine(), this.attr(t3));
    }, move: function(t3, e3) {
      return this.attr(this.array().move(t3, e3).toLine());
    }, size: function(t3, e3) {
      var i2 = u2(this, t3, e3);
      return this.attr(this.array().size(i2.width, i2.height).toLine());
    } }, construct: { line: function(t3, e3, i2, s3) {
      return a2.Line.prototype.plot.apply(this.put(new a2.Line()), t3 != null ? [t3, e3, i2, s3] : [0, 0, 0, 0]);
    } } }), a2.Polyline = a2.invent({ create: "polyline", inherit: a2.Shape, construct: { polyline: function(t3) {
      return this.put(new a2.Polyline()).plot(t3 || new a2.PointArray());
    } } }), a2.Polygon = a2.invent({ create: "polygon", inherit: a2.Shape, construct: { polygon: function(t3) {
      return this.put(new a2.Polygon()).plot(t3 || new a2.PointArray());
    } } }), a2.extend(a2.Polyline, a2.Polygon, { array: function() {
      return this._array || (this._array = new a2.PointArray(this.attr("points")));
    }, plot: function(t3) {
      return t3 == null ? this.array() : this.clear().attr("points", typeof t3 == "string" ? t3 : this._array = new a2.PointArray(t3));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(t3, e3) {
      return this.attr("points", this.array().move(t3, e3));
    }, size: function(t3, e3) {
      var i2 = u2(this, t3, e3);
      return this.attr("points", this.array().size(i2.width, i2.height));
    } }), a2.extend(a2.Line, a2.Polyline, a2.Polygon, { morphArray: a2.PointArray, x: function(t3) {
      return t3 == null ? this.bbox().x : this.move(t3, this.bbox().y);
    }, y: function(t3) {
      return t3 == null ? this.bbox().y : this.move(this.bbox().x, t3);
    }, width: function(t3) {
      var e3 = this.bbox();
      return t3 == null ? e3.width : this.size(t3, e3.height);
    }, height: function(t3) {
      var e3 = this.bbox();
      return t3 == null ? e3.height : this.size(e3.width, t3);
    } }), a2.Path = a2.invent({ create: "path", inherit: a2.Shape, extend: { morphArray: a2.PathArray, array: function() {
      return this._array || (this._array = new a2.PathArray(this.attr("d")));
    }, plot: function(t3) {
      return t3 == null ? this.array() : this.clear().attr("d", typeof t3 == "string" ? t3 : this._array = new a2.PathArray(t3));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(t3) {
      return this.put(new a2.Path()).plot(t3 || new a2.PathArray());
    } } }), a2.Image = a2.invent({ create: "image", inherit: a2.Shape, extend: { load: function(e3) {
      if (!e3)
        return this;
      var i2 = this, s3 = new t2.Image();
      return a2.on(s3, "load", function() {
        a2.off(s3);
        var t3 = i2.parent(a2.Pattern);
        t3 !== null && (i2.width() == 0 && i2.height() == 0 && i2.size(s3.width, s3.height), t3 && t3.width() == 0 && t3.height() == 0 && t3.size(i2.width(), i2.height()), typeof i2._loaded == "function" && i2._loaded.call(i2, { width: s3.width, height: s3.height, ratio: s3.width / s3.height, url: e3 }));
      }), a2.on(s3, "error", function(t3) {
        a2.off(s3), typeof i2._error == "function" && i2._error.call(i2, t3);
      }), this.attr("href", s3.src = this.src = e3, a2.xlink);
    }, loaded: function(t3) {
      return this._loaded = t3, this;
    }, error: function(t3) {
      return this._error = t3, this;
    } }, construct: { image: function(t3, e3, i2) {
      return this.put(new a2.Image()).load(t3).size(e3 || 0, i2 || e3 || 0);
    } } }), a2.Text = a2.invent({ create: function() {
      this.constructor.call(this, a2.create("text")), this.dom.leading = new a2.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", a2.defaults.attrs["font-family"]);
    }, inherit: a2.Shape, extend: { x: function(t3) {
      return t3 == null ? this.attr("x") : this.attr("x", t3);
    }, text: function(t3) {
      if (t3 === void 0) {
        t3 = "";
        for (var e3 = this.node.childNodes, i2 = 0, s3 = e3.length; i2 < s3; ++i2)
          i2 != 0 && e3[i2].nodeType != 3 && a2.adopt(e3[i2]).dom.newLined == 1 && (t3 += "\n"), t3 += e3[i2].textContent;
        return t3;
      }
      if (this.clear().build(true), typeof t3 == "function")
        t3.call(this, this);
      else {
        i2 = 0;
        for (var r3 = (t3 = t3.split("\n")).length; i2 < r3; i2++)
          this.tspan(t3[i2]).newLine();
      }
      return this.build(false).rebuild();
    }, size: function(t3) {
      return this.attr("font-size", t3).rebuild();
    }, leading: function(t3) {
      return t3 == null ? this.dom.leading : (this.dom.leading = new a2.Number(t3), this.rebuild());
    }, lines: function() {
      var t3 = (this.textPath && this.textPath() || this).node, e3 = a2.utils.map(a2.utils.filterSVGElements(t3.childNodes), function(t4) {
        return a2.adopt(t4);
      });
      return new a2.Set(e3);
    }, rebuild: function(t3) {
      if (typeof t3 == "boolean" && (this._rebuild = t3), this._rebuild) {
        var e3 = this, i2 = 0, s3 = this.dom.leading * new a2.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (e3.textPath() || this.attr("x", e3.attr("x")), this.text() == "\n" ? i2 += s3 : (this.attr("dy", s3 + i2), i2 = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(t3) {
      return this._build = !!t3, this;
    }, setData: function(t3) {
      return this.dom = t3, this.dom.leading = new a2.Number(t3.leading || 1.3), this;
    } }, construct: { text: function(t3) {
      return this.put(new a2.Text()).text(t3);
    }, plain: function(t3) {
      return this.put(new a2.Text()).plain(t3);
    } } }), a2.Tspan = a2.invent({ create: "tspan", inherit: a2.Shape, extend: { text: function(t3) {
      return t3 == null ? this.node.textContent + (this.dom.newLined ? "\n" : "") : (typeof t3 == "function" ? t3.call(this, this) : this.plain(t3), this);
    }, dx: function(t3) {
      return this.attr("dx", t3);
    }, dy: function(t3) {
      return this.attr("dy", t3);
    }, newLine: function() {
      var t3 = this.parent(a2.Text);
      return this.dom.newLined = true, this.dy(t3.dom.leading * t3.attr("font-size")).attr("x", t3.x());
    } } }), a2.extend(a2.Text, a2.Tspan, { plain: function(t3) {
      return this._build === false && this.clear(), this.node.appendChild(e2.createTextNode(t3)), this;
    }, tspan: function(t3) {
      var e3 = (this.textPath && this.textPath() || this).node, i2 = new a2.Tspan();
      return this._build === false && this.clear(), e3.appendChild(i2.node), i2.text(t3);
    }, clear: function() {
      for (var t3 = (this.textPath && this.textPath() || this).node; t3.hasChildNodes(); )
        t3.removeChild(t3.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), a2.TextPath = a2.invent({ create: "textPath", inherit: a2.Parent, parent: a2.Text, construct: { morphArray: a2.PathArray, array: function() {
      var t3 = this.track();
      return t3 ? t3.array() : null;
    }, plot: function(t3) {
      var e3 = this.track(), i2 = null;
      return e3 && (i2 = e3.plot(t3)), t3 == null ? i2 : this;
    }, track: function() {
      var t3 = this.textPath();
      if (t3)
        return t3.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == "textPath")
        return a2.adopt(this.node.firstChild);
    } } }), a2.Nested = a2.invent({ create: function() {
      this.constructor.call(this, a2.create("svg")), this.style("overflow", "visible");
    }, inherit: a2.Container, construct: { nested: function() {
      return this.put(new a2.Nested());
    } } });
    var l2 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t3, e3) {
      return e3 == "color" ? t3 : t3 + "-" + e3;
    } };
    function h3(t3, e3, i2, s3) {
      return i2 + s3.replace(a2.regex.dots, " .");
    }
    function c2(t3) {
      return t3.toLowerCase().replace(/-(.)/g, function(t4, e3) {
        return e3.toUpperCase();
      });
    }
    function d2(t3) {
      return t3.charAt(0).toUpperCase() + t3.slice(1);
    }
    function g2(t3) {
      var e3 = t3.toString(16);
      return e3.length == 1 ? "0" + e3 : e3;
    }
    function u2(t3, e3, i2) {
      if (e3 == null || i2 == null) {
        var a3 = t3.bbox();
        e3 == null ? e3 = a3.width / a3.height * i2 : i2 == null && (i2 = a3.height / a3.width * e3);
      }
      return { width: e3, height: i2 };
    }
    function p3(t3, e3, i2) {
      return { x: e3 * t3.a + i2 * t3.c + 0, y: e3 * t3.b + i2 * t3.d + 0 };
    }
    function f2(t3) {
      return { a: t3[0], b: t3[1], c: t3[2], d: t3[3], e: t3[4], f: t3[5] };
    }
    function x2(e3) {
      for (var i2 = e3.childNodes.length - 1; i2 >= 0; i2--)
        e3.childNodes[i2] instanceof t2.SVGElement && x2(e3.childNodes[i2]);
      return a2.adopt(e3).id(a2.eid(e3.nodeName));
    }
    function b2(t3) {
      return t3.x == null && (t3.x = 0, t3.y = 0, t3.width = 0, t3.height = 0), t3.w = t3.width, t3.h = t3.height, t3.x2 = t3.x + t3.width, t3.y2 = t3.y + t3.height, t3.cx = t3.x + t3.width / 2, t3.cy = t3.y + t3.height / 2, t3;
    }
    function v2(t3) {
      return Math.abs(t3) > 1e-37 ? t3 : 0;
    }
    ["fill", "stroke"].forEach(function(t3) {
      var e3 = {};
      e3[t3] = function(e4) {
        if (e4 === void 0)
          return this;
        if (typeof e4 == "string" || a2.Color.isRgb(e4) || e4 && typeof e4.fill == "function")
          this.attr(t3, e4);
        else
          for (var i2 = l2[t3].length - 1; i2 >= 0; i2--)
            e4[l2[t3][i2]] != null && this.attr(l2.prefix(t3, l2[t3][i2]), e4[l2[t3][i2]]);
        return this;
      }, a2.extend(a2.Element, a2.FX, e3);
    }), a2.extend(a2.Element, a2.FX, { translate: function(t3, e3) {
      return this.transform({ x: t3, y: e3 });
    }, matrix: function(t3) {
      return this.attr("transform", new a2.Matrix(arguments.length == 6 ? [].slice.call(arguments) : t3));
    }, opacity: function(t3) {
      return this.attr("opacity", t3);
    }, dx: function(t3) {
      return this.x(new a2.Number(t3).plus(this instanceof a2.FX ? 0 : this.x()), true);
    }, dy: function(t3) {
      return this.y(new a2.Number(t3).plus(this instanceof a2.FX ? 0 : this.y()), true);
    } }), a2.extend(a2.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(t3) {
      return this.node.getPointAtLength(t3);
    } }), a2.Set = a2.invent({ create: function(t3) {
      Array.isArray(t3) ? this.members = t3 : this.clear();
    }, extend: { add: function() {
      for (var t3 = [].slice.call(arguments), e3 = 0, i2 = t3.length; e3 < i2; e3++)
        this.members.push(t3[e3]);
      return this;
    }, remove: function(t3) {
      var e3 = this.index(t3);
      return e3 > -1 && this.members.splice(e3, 1), this;
    }, each: function(t3) {
      for (var e3 = 0, i2 = this.members.length; e3 < i2; e3++)
        t3.apply(this.members[e3], [e3, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(t3) {
      return this.index(t3) >= 0;
    }, index: function(t3) {
      return this.members.indexOf(t3);
    }, get: function(t3) {
      return this.members[t3];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(t3) {
      return new a2.Set(t3);
    } } }), a2.FX.Set = a2.invent({ create: function(t3) {
      this.set = t3;
    } }), a2.Set.inherit = function() {
      var t3 = [];
      for (var e3 in a2.Shape.prototype)
        typeof a2.Shape.prototype[e3] == "function" && typeof a2.Set.prototype[e3] != "function" && t3.push(e3);
      for (var e3 in t3.forEach(function(t4) {
        a2.Set.prototype[t4] = function() {
          for (var e4 = 0, i2 = this.members.length; e4 < i2; e4++)
            this.members[e4] && typeof this.members[e4][t4] == "function" && this.members[e4][t4].apply(this.members[e4], arguments);
          return t4 == "animate" ? this.fx || (this.fx = new a2.FX.Set(this)) : this;
        };
      }), t3 = [], a2.FX.prototype)
        typeof a2.FX.prototype[e3] == "function" && typeof a2.FX.Set.prototype[e3] != "function" && t3.push(e3);
      t3.forEach(function(t4) {
        a2.FX.Set.prototype[t4] = function() {
          for (var e4 = 0, i2 = this.set.members.length; e4 < i2; e4++)
            this.set.members[e4].fx[t4].apply(this.set.members[e4].fx, arguments);
          return this;
        };
      });
    }, a2.extend(a2.Element, {}), a2.extend(a2.Element, { remember: function(t3, e3) {
      if (i(arguments[0]) === "object")
        for (var a3 in t3)
          this.remember(a3, t3[a3]);
      else {
        if (arguments.length == 1)
          return this.memory()[t3];
        this.memory()[t3] = e3;
      }
      return this;
    }, forget: function() {
      if (arguments.length == 0)
        this._memory = {};
      else
        for (var t3 = arguments.length - 1; t3 >= 0; t3--)
          delete this.memory()[arguments[t3]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), a2.get = function(t3) {
      var i2 = e2.getElementById(function(t4) {
        var e3 = (t4 || "").toString().match(a2.regex.reference);
        if (e3)
          return e3[1];
      }(t3) || t3);
      return a2.adopt(i2);
    }, a2.select = function(t3, i2) {
      return new a2.Set(a2.utils.map((i2 || e2).querySelectorAll(t3), function(t4) {
        return a2.adopt(t4);
      }));
    }, a2.extend(a2.Parent, { select: function(t3) {
      return a2.select(t3, this.node);
    } });
    var m2 = "abcdef".split("");
    if (typeof t2.CustomEvent != "function") {
      var y2 = function(t3, i2) {
        i2 = i2 || { bubbles: false, cancelable: false, detail: void 0 };
        var a3 = e2.createEvent("CustomEvent");
        return a3.initCustomEvent(t3, i2.bubbles, i2.cancelable, i2.detail), a3;
      };
      y2.prototype = t2.Event.prototype, a2.CustomEvent = y2;
    } else
      a2.CustomEvent = t2.CustomEvent;
    return a2;
  }, i(exports) === "object" && true ? module.exports = It.document ? zt(It, It.document) : function(t2) {
    return zt(t2, t2.document);
  } : It.SVG = zt(It, It.document), function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t3, e3) {
      return this.add(t3, e3), !t3.attr("in") && this.autoSetIn && t3.attr("in", this.source), t3.attr("result") || t3.attr("result", t3), t3;
    }, blend: function(t3, e3, i3) {
      return this.put(new SVG.BlendEffect(t3, e3, i3));
    }, colorMatrix: function(t3, e3) {
      return this.put(new SVG.ColorMatrixEffect(t3, e3));
    }, convolveMatrix: function(t3) {
      return this.put(new SVG.ConvolveMatrixEffect(t3));
    }, componentTransfer: function(t3) {
      return this.put(new SVG.ComponentTransferEffect(t3));
    }, composite: function(t3, e3, i3) {
      return this.put(new SVG.CompositeEffect(t3, e3, i3));
    }, flood: function(t3, e3) {
      return this.put(new SVG.FloodEffect(t3, e3));
    }, offset: function(t3, e3) {
      return this.put(new SVG.OffsetEffect(t3, e3));
    }, image: function(t3) {
      return this.put(new SVG.ImageEffect(t3));
    }, merge: function() {
      var t3 = [void 0];
      for (var e3 in arguments)
        t3.push(arguments[e3]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t3))());
    }, gaussianBlur: function(t3, e3) {
      return this.put(new SVG.GaussianBlurEffect(t3, e3));
    }, morphology: function(t3, e3) {
      return this.put(new SVG.MorphologyEffect(t3, e3));
    }, diffuseLighting: function(t3, e3, i3) {
      return this.put(new SVG.DiffuseLightingEffect(t3, e3, i3));
    }, displacementMap: function(t3, e3, i3, a3, s3) {
      return this.put(new SVG.DisplacementMapEffect(t3, e3, i3, a3, s3));
    }, specularLighting: function(t3, e3, i3, a3) {
      return this.put(new SVG.SpecularLightingEffect(t3, e3, i3, a3));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(t3, e3, i3, a3, s3) {
      return this.put(new SVG.TurbulenceEffect(t3, e3, i3, a3, s3));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(t3) {
      var e3 = this.put(new SVG.Filter());
      return typeof t3 == "function" && t3.call(e3, e3), e3;
    } }), SVG.extend(SVG.Container, { filter: function(t3) {
      return this.defs().filter(t3);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t3) {
      return this.filterer = t3 instanceof SVG.Element ? t3 : this.doc().filter(t3), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(t3) {
      return this.filterer && t3 === true && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(t3) {
      return t3 == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t3);
    }, result: function(t3) {
      return t3 == null ? this.attr("result") : this.attr("result", t3);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(t3) {
      return t3 == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t3);
    }, result: function(t3) {
      return t3 == null ? this.attr("result") : this.attr("result", t3);
    }, toString: function() {
      return this.result();
    } } });
    var t2 = { blend: function(t3, e3) {
      return this.parent() && this.parent().blend(this, t3, e3);
    }, colorMatrix: function(t3, e3) {
      return this.parent() && this.parent().colorMatrix(t3, e3).in(this);
    }, convolveMatrix: function(t3) {
      return this.parent() && this.parent().convolveMatrix(t3).in(this);
    }, componentTransfer: function(t3) {
      return this.parent() && this.parent().componentTransfer(t3).in(this);
    }, composite: function(t3, e3) {
      return this.parent() && this.parent().composite(this, t3, e3);
    }, flood: function(t3, e3) {
      return this.parent() && this.parent().flood(t3, e3);
    }, offset: function(t3, e3) {
      return this.parent() && this.parent().offset(t3, e3).in(this);
    }, image: function(t3) {
      return this.parent() && this.parent().image(t3);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(t3, e3) {
      return this.parent() && this.parent().gaussianBlur(t3, e3).in(this);
    }, morphology: function(t3, e3) {
      return this.parent() && this.parent().morphology(t3, e3).in(this);
    }, diffuseLighting: function(t3, e3, i3) {
      return this.parent() && this.parent().diffuseLighting(t3, e3, i3).in(this);
    }, displacementMap: function(t3, e3, i3, a3) {
      return this.parent() && this.parent().displacementMap(this, t3, e3, i3, a3);
    }, specularLighting: function(t3, e3, i3, a3) {
      return this.parent() && this.parent().specularLighting(t3, e3, i3, a3).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(t3, e3, i3, a3, s3) {
      return this.parent() && this.parent().turbulence(t3, e3, i3, a3, s3).in(this);
    } };
    SVG.extend(SVG.Effect, t2), SVG.extend(SVG.ParentEffect, t2), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(t3) {
      this.attr("in", t3);
    } } });
    var e2 = { blend: function(t3, e3, i3) {
      this.attr({ in: t3, in2: e3, mode: i3 || "normal" });
    }, colorMatrix: function(t3, e3) {
      t3 == "matrix" && (e3 = s2(e3)), this.attr({ type: t3, values: e3 === void 0 ? null : e3 });
    }, convolveMatrix: function(t3) {
      t3 = s2(t3), this.attr({ order: Math.sqrt(t3.split(" ").length), kernelMatrix: t3 });
    }, composite: function(t3, e3, i3) {
      this.attr({ in: t3, in2: e3, operator: i3 });
    }, flood: function(t3, e3) {
      this.attr("flood-color", t3), e3 != null && this.attr("flood-opacity", e3);
    }, offset: function(t3, e3) {
      this.attr({ dx: t3, dy: e3 });
    }, image: function(t3) {
      this.attr("href", t3, SVG.xlink);
    }, displacementMap: function(t3, e3, i3, a3, s3) {
      this.attr({ in: t3, in2: e3, scale: i3, xChannelSelector: a3, yChannelSelector: s3 });
    }, gaussianBlur: function(t3, e3) {
      t3 != null || e3 != null ? this.attr("stdDeviation", r2(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(t3, e3) {
      this.attr({ operator: t3, radius: e3 });
    }, tile: function() {
    }, turbulence: function(t3, e3, i3, a3, s3) {
      this.attr({ numOctaves: e3, seed: i3, stitchTiles: a3, baseFrequency: t3, type: s3 });
    } }, i2 = { merge: function() {
      var t3;
      if (arguments[0] instanceof SVG.Set) {
        var e3 = this;
        arguments[0].each(function(t4) {
          this instanceof SVG.MergeNode ? e3.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e3.put(new SVG.MergeNode(this));
        });
      } else {
        t3 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var i3 = 0; i3 < t3.length; i3++)
          t3[i3] instanceof SVG.MergeNode ? this.put(t3[i3]) : this.put(new SVG.MergeNode(t3[i3]));
      }
    }, componentTransfer: function(t3) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach(function(t4) {
        this[t4] = new SVG["Func" + t4.toUpperCase()]("identity"), this.rgb.add(this[t4]), this.node.appendChild(this[t4].node);
      }.bind(this)), t3)
        for (var e3 in t3.rgb && (["r", "g", "b"].forEach(function(e4) {
          this[e4].attr(t3.rgb);
        }.bind(this)), delete t3.rgb), t3)
          this[e3].attr(t3[e3]);
    }, diffuseLighting: function(t3, e3, i3) {
      this.attr({ surfaceScale: t3, diffuseConstant: e3, kernelUnitLength: i3 });
    }, specularLighting: function(t3, e3, i3, a3) {
      this.attr({ surfaceScale: t3, diffuseConstant: e3, specularExponent: i3, kernelUnitLength: a3 });
    } }, a2 = { distantLight: function(t3, e3) {
      this.attr({ azimuth: t3, elevation: e3 });
    }, pointLight: function(t3, e3, i3) {
      this.attr({ x: t3, y: e3, z: i3 });
    }, spotLight: function(t3, e3, i3, a3, s3, r3) {
      this.attr({ x: t3, y: e3, z: i3, pointsAtX: a3, pointsAtY: s3, pointsAtZ: r3 });
    }, mergeNode: function(t3) {
      this.attr("in", t3);
    } };
    function s2(t3) {
      return Array.isArray(t3) && (t3 = new SVG.Array(t3)), t3.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function r2(t3) {
      if (!Array.isArray(t3))
        return t3;
      for (var e3 = 0, i3 = t3.length, a3 = []; e3 < i3; e3++)
        a3.push(t3[e3]);
      return a3.join(" ");
    }
    function o2() {
      var t3 = function() {
      };
      for (var e3 in typeof arguments[arguments.length - 1] == "function" && (t3 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
        for (var i3 in arguments[e3])
          t3(arguments[e3][i3], i3, arguments[e3]);
    }
    ["r", "g", "b", "a"].forEach(function(t3) {
      a2["Func" + t3.toUpperCase()] = function(t4) {
        switch (this.attr("type", t4), t4) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), o2(e2, function(t3, e3) {
      var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
      SVG[i3 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), o2(i2, function(t3, e3) {
      var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
      SVG[i3 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), o2(a2, function(t3, e3) {
      var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
      SVG[i3] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(t3) {
      return t3 instanceof SVG.MergeNode ? this.add(t3, 0) : this.add(new SVG.MergeNode(t3), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t3) {
      return t3 == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t3);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }.call(void 0), function() {
    function t2(t3, s3, r2, o2, n2, l2, h3) {
      for (var c2 = t3.slice(s3, r2 || h3), d2 = o2.slice(n2, l2 || h3), g2 = 0, u2 = { pos: [0, 0], start: [0, 0] }, p3 = { pos: [0, 0], start: [0, 0] }; ; ) {
        if (c2[g2] = e2.call(u2, c2[g2]), d2[g2] = e2.call(p3, d2[g2]), c2[g2][0] != d2[g2][0] || c2[g2][0] == "M" || c2[g2][0] == "A" && (c2[g2][4] != d2[g2][4] || c2[g2][5] != d2[g2][5]) ? (Array.prototype.splice.apply(c2, [g2, 1].concat(a2.call(u2, c2[g2]))), Array.prototype.splice.apply(d2, [g2, 1].concat(a2.call(p3, d2[g2])))) : (c2[g2] = i2.call(u2, c2[g2]), d2[g2] = i2.call(p3, d2[g2])), ++g2 == c2.length && g2 == d2.length)
          break;
        g2 == c2.length && c2.push(["C", u2.pos[0], u2.pos[1], u2.pos[0], u2.pos[1], u2.pos[0], u2.pos[1]]), g2 == d2.length && d2.push(["C", p3.pos[0], p3.pos[1], p3.pos[0], p3.pos[1], p3.pos[0], p3.pos[1]]);
      }
      return { start: c2, dest: d2 };
    }
    function e2(t3) {
      switch (t3[0]) {
        case "z":
        case "Z":
          t3[0] = "L", t3[1] = this.start[0], t3[2] = this.start[1];
          break;
        case "H":
          t3[0] = "L", t3[2] = this.pos[1];
          break;
        case "V":
          t3[0] = "L", t3[2] = t3[1], t3[1] = this.pos[0];
          break;
        case "T":
          t3[0] = "Q", t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
          break;
        case "S":
          t3[0] = "C", t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
      }
      return t3;
    }
    function i2(t3) {
      var e3 = t3.length;
      return this.pos = [t3[e3 - 2], t3[e3 - 1]], "SCQT".indexOf(t3[0]) != -1 && (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
    }
    function a2(t3) {
      var e3 = [t3];
      switch (t3[0]) {
        case "M":
          return this.pos = this.start = [t3[1], t3[2]], e3;
        case "L":
          t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
          break;
        case "Q":
          t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
          break;
        case "A":
          t3 = (e3 = function(t4, e4) {
            var i3, a3, s3, r2, o2, n2, l2, h3, c2, d2, g2, u2, p3, f2, x2, b2, v2, m2, y2, w2, k2, A2, S2, C2, L2, P2, T2 = Math.abs(e4[1]), M2 = Math.abs(e4[2]), I2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], E2 = e4[6], Y2 = e4[7], F2 = new SVG.Point(t4), R2 = new SVG.Point(E2, Y2), H2 = [];
            if (T2 === 0 || M2 === 0 || F2.x === R2.x && F2.y === R2.y)
              return [["C", F2.x, F2.y, R2.x, R2.y, R2.x, R2.y]];
            i3 = new SVG.Point((F2.x - R2.x) / 2, (F2.y - R2.y) / 2).transform(new SVG.Matrix().rotate(I2)), (a3 = i3.x * i3.x / (T2 * T2) + i3.y * i3.y / (M2 * M2)) > 1 && (T2 *= a3 = Math.sqrt(a3), M2 *= a3);
            s3 = new SVG.Matrix().rotate(I2).scale(1 / T2, 1 / M2).rotate(-I2), F2 = F2.transform(s3), R2 = R2.transform(s3), r2 = [R2.x - F2.x, R2.y - F2.y], n2 = r2[0] * r2[0] + r2[1] * r2[1], o2 = Math.sqrt(n2), r2[0] /= o2, r2[1] /= o2, l2 = n2 < 4 ? Math.sqrt(1 - n2 / 4) : 0, z2 === X2 && (l2 *= -1);
            h3 = new SVG.Point((R2.x + F2.x) / 2 + l2 * -r2[1], (R2.y + F2.y) / 2 + l2 * r2[0]), c2 = new SVG.Point(F2.x - h3.x, F2.y - h3.y), d2 = new SVG.Point(R2.x - h3.x, R2.y - h3.y), g2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y < 0 && (g2 *= -1);
            u2 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y < 0 && (u2 *= -1);
            X2 && g2 > u2 && (u2 += 2 * Math.PI);
            !X2 && g2 < u2 && (u2 -= 2 * Math.PI);
            for (f2 = Math.ceil(2 * Math.abs(g2 - u2) / Math.PI), b2 = [], v2 = g2, p3 = (u2 - g2) / f2, x2 = 4 * Math.tan(p3 / 4) / 3, k2 = 0; k2 <= f2; k2++)
              y2 = Math.cos(v2), m2 = Math.sin(v2), w2 = new SVG.Point(h3.x + y2, h3.y + m2), b2[k2] = [new SVG.Point(w2.x + x2 * m2, w2.y - x2 * y2), w2, new SVG.Point(w2.x - x2 * m2, w2.y + x2 * y2)], v2 += p3;
            for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new SVG.Matrix().rotate(I2).scale(T2, M2).rotate(-I2), k2 = 0, A2 = b2.length; k2 < A2; k2++)
              b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
            for (k2 = 1, A2 = b2.length; k2 < A2; k2++)
              S2 = (w2 = b2[k2 - 1][2]).x, C2 = w2.y, L2 = (w2 = b2[k2][0]).x, P2 = w2.y, E2 = (w2 = b2[k2][1]).x, Y2 = w2.y, H2.push(["C", S2, C2, L2, P2, E2, Y2]);
            return H2;
          }(this.pos, t3))[0];
      }
      return t3[0] = "C", this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
    }
    function s2(t3, e3) {
      if (e3 === false)
        return false;
      for (var i3 = e3, a3 = t3.length; i3 < a3; ++i3)
        if (t3[i3][0] == "M")
          return i3;
      return false;
    }
    SVG.extend(SVG.PathArray, { morph: function(e3) {
      for (var i3 = this.value, a3 = this.parse(e3), r2 = 0, o2 = 0, n2 = false, l2 = false; r2 !== false || o2 !== false; ) {
        var h3;
        n2 = s2(i3, r2 !== false && r2 + 1), l2 = s2(a3, o2 !== false && o2 + 1), r2 === false && (r2 = (h3 = new SVG.PathArray(c2.start).bbox()).height == 0 || h3.width == 0 ? i3.push(i3[0]) - 1 : i3.push(["M", h3.x + h3.width / 2, h3.y + h3.height / 2]) - 1), o2 === false && (o2 = (h3 = new SVG.PathArray(c2.dest).bbox()).height == 0 || h3.width == 0 ? a3.push(a3[0]) - 1 : a3.push(["M", h3.x + h3.width / 2, h3.y + h3.height / 2]) - 1);
        var c2 = t2(i3, r2, n2, a3, o2, l2);
        i3 = i3.slice(0, r2).concat(c2.start, n2 === false ? [] : i3.slice(n2)), a3 = a3.slice(0, o2).concat(c2.dest, l2 === false ? [] : a3.slice(l2)), r2 = n2 !== false && r2 + c2.start.length, o2 = l2 !== false && o2 + c2.dest.length;
      }
      return this.value = i3, this.destination = new SVG.PathArray(), this.destination.value = a3, this;
    } });
  }(), function() {
    function t2(t3) {
      t3.remember("_draggable", this), this.el = t3;
    }
    t2.prototype.init = function(t3, e2) {
      var i2 = this;
      this.constraint = t3, this.value = e2, this.el.on("mousedown.drag", function(t4) {
        i2.start(t4);
      }), this.el.on("touchstart.drag", function(t4) {
        i2.start(t4);
      });
    }, t2.prototype.transformPoint = function(t3, e2) {
      var i2 = (t3 = t3 || window.event).changedTouches && t3.changedTouches[0] || t3;
      return this.p.x = i2.clientX - (e2 || 0), this.p.y = i2.clientY, this.p.matrixTransform(this.m);
    }, t2.prototype.getBBox = function() {
      var t3 = this.el.bbox();
      return this.el instanceof SVG.Nested && (t3 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t3.x = this.el.x(), t3.y = this.el.y()), t3;
    }, t2.prototype.start = function(t3) {
      if (t3.type != "click" && t3.type != "mousedown" && t3.type != "mousemove" || (t3.which || t3.buttons) == 1) {
        var e2 = this;
        if (this.el.fire("beforedrag", { event: t3, handler: this }), !this.el.event().defaultPrevented) {
          t3.preventDefault(), t3.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i2, a2 = this.getBBox();
          if (this.el instanceof SVG.Text)
            switch (i2 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                i2 /= 2;
                break;
              case "start":
                i2 = 0;
            }
          this.startPoints = { point: this.transformPoint(t3, i2), box: a2, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(t4) {
            e2.drag(t4);
          }), SVG.on(window, "touchmove.drag", function(t4) {
            e2.drag(t4);
          }), SVG.on(window, "mouseup.drag", function(t4) {
            e2.end(t4);
          }), SVG.on(window, "touchend.drag", function(t4) {
            e2.end(t4);
          }), this.el.fire("dragstart", { event: t3, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, t2.prototype.drag = function(t3) {
      var e2 = this.getBBox(), i2 = this.transformPoint(t3), a2 = this.startPoints.box.x + i2.x - this.startPoints.point.x, s2 = this.startPoints.box.y + i2.y - this.startPoints.point.y, r2 = this.constraint, o2 = i2.x - this.startPoints.point.x, n2 = i2.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: t3, p: i2, m: this.m, handler: this }), this.el.event().defaultPrevented)
        return i2;
      if (typeof r2 == "function") {
        var l2 = r2.call(this.el, a2, s2, this.m);
        typeof l2 == "boolean" && (l2 = { x: l2, y: l2 }), l2.x === true ? this.el.x(a2) : l2.x !== false && this.el.x(l2.x), l2.y === true ? this.el.y(s2) : l2.y !== false && this.el.y(l2.y);
      } else
        typeof r2 == "object" && (r2.minX != null && a2 < r2.minX ? o2 = (a2 = r2.minX) - this.startPoints.box.x : r2.maxX != null && a2 > r2.maxX - e2.width && (o2 = (a2 = r2.maxX - e2.width) - this.startPoints.box.x), r2.minY != null && s2 < r2.minY ? n2 = (s2 = r2.minY) - this.startPoints.box.y : r2.maxY != null && s2 > r2.maxY - e2.height && (n2 = (s2 = r2.maxY - e2.height) - this.startPoints.box.y), r2.snapToGrid != null && (a2 -= a2 % r2.snapToGrid, s2 -= s2 % r2.snapToGrid, o2 -= o2 % r2.snapToGrid, n2 -= n2 % r2.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: o2, y: n2 }, true) : this.el.move(a2, s2));
      return i2;
    }, t2.prototype.end = function(t3) {
      var e2 = this.drag(t3);
      this.el.fire("dragend", { event: t3, p: e2, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(e2, i2) {
      typeof e2 != "function" && typeof e2 != "object" || (i2 = e2, e2 = true);
      var a2 = this.remember("_draggable") || new t2(this);
      return (e2 = e2 === void 0 || e2) ? a2.init(i2 || {}, e2) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }.call(void 0), function() {
    function t2(t3) {
      this.el = t3, t3.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t4, e2, i2) {
        var a2 = typeof t4 != "string" ? t4 : e2[t4];
        return i2 ? a2 / 2 : a2;
      }, this.pointCoords = function(t4, e2) {
        var i2 = this.pointsList[t4];
        return { x: this.pointCoord(i2[0], e2, t4 === "t" || t4 === "b"), y: this.pointCoord(i2[1], e2, t4 === "r" || t4 === "l") };
      };
    }
    t2.prototype.init = function(t3, e2) {
      var i2 = this.el.bbox();
      this.options = {};
      var a2 = this.el.selectize.defaults.points;
      for (var s2 in this.el.selectize.defaults)
        this.options[s2] = this.el.selectize.defaults[s2], e2[s2] !== void 0 && (this.options[s2] = e2[s2]);
      var r2 = ["points", "pointsExclude"];
      for (var s2 in r2) {
        var o2 = this.options[r2[s2]];
        typeof o2 == "string" ? o2 = o2.length > 0 ? o2.split(/\s*,\s*/i) : [] : typeof o2 == "boolean" && r2[s2] === "points" && (o2 = o2 ? a2 : []), this.options[r2[s2]] = o2;
      }
      this.options.points = [a2, this.options.points].reduce(function(t4, e3) {
        return t4.filter(function(t5) {
          return e3.indexOf(t5) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(t4, e3) {
        return t4.filter(function(t5) {
          return e3.indexOf(t5) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i2.x, i2.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(t3) : this.selectRect(t3), this.observe(), this.cleanup();
    }, t2.prototype.selectPoints = function(t3) {
      return this.pointSelection.isSelected = t3, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, t2.prototype.getPointArray = function() {
      var t3 = this.el.bbox();
      return this.el.array().valueOf().map(function(e2) {
        return [e2[0] - t3.x, e2[1] - t3.y];
      });
    }, t2.prototype.drawPoints = function() {
      for (var t3 = this, e2 = this.getPointArray(), i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
        var s2 = function(e3) {
          return function(i3) {
            (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
            var a3 = i3.pageX || i3.touches[0].pageX, s3 = i3.pageY || i3.touches[0].pageY;
            t3.el.fire("point", { x: a3, y: s3, i: e3, event: i3 });
          };
        }(i2), r2 = this.drawPoint(e2[i2][0], e2[i2][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s2).on("mousedown", s2);
        this.pointSelection.set.add(r2);
      }
    }, t2.prototype.drawPoint = function(t3, e2) {
      var i2 = this.options.pointType;
      switch (i2) {
        case "circle":
          return this.drawCircle(t3, e2);
        case "rect":
          return this.drawRect(t3, e2);
        default:
          if (typeof i2 == "function")
            return i2.call(this, t3, e2);
          throw new Error("Unknown " + i2 + " point type!");
      }
    }, t2.prototype.drawCircle = function(t3, e2) {
      return this.nested.circle(this.options.pointSize).center(t3, e2);
    }, t2.prototype.drawRect = function(t3, e2) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t3, e2);
    }, t2.prototype.updatePointSelection = function() {
      var t3 = this.getPointArray();
      this.pointSelection.set.each(function(e2) {
        this.cx() === t3[e2][0] && this.cy() === t3[e2][1] || this.center(t3[e2][0], t3[e2][1]);
      });
    }, t2.prototype.updateRectSelection = function() {
      var t3 = this, e2 = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: e2.width, height: e2.height }), this.options.points.length && this.options.points.map(function(i3, a2) {
        var s2 = t3.pointCoords(i3, e2);
        t3.rectSelection.set.get(a2 + 1).center(s2.x, s2.y);
      }), this.options.rotationPoint) {
        var i2 = this.rectSelection.set.length();
        this.rectSelection.set.get(i2 - 1).center(e2.width / 2, 20);
      }
    }, t2.prototype.selectRect = function(t3) {
      var e2 = this, i2 = this.el.bbox();
      function a2(t4) {
        return function(i3) {
          (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
          var a3 = i3.pageX || i3.touches[0].pageX, s3 = i3.pageY || i3.touches[0].pageY;
          e2.el.fire(t4, { x: a3, y: s3, event: i3 });
        };
      }
      if (this.rectSelection.isSelected = t3, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i2.width, i2.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
        this.options.points.map(function(t4, s3) {
          var r3 = e2.pointCoords(t4, i2), o2 = e2.drawPoint(r3.x, r3.y).attr("class", e2.options.classPoints + "_" + t4).on("mousedown", a2(t4)).on("touchstart", a2(t4));
          e2.rectSelection.set.add(o2);
        }), this.rectSelection.set.each(function() {
          this.addClass(e2.options.classPoints);
        });
      }
      if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var s2 = function(t4) {
          (t4 = t4 || window.event).preventDefault ? t4.preventDefault() : t4.returnValue = false, t4.stopPropagation();
          var i3 = t4.pageX || t4.touches[0].pageX, a3 = t4.pageY || t4.touches[0].pageY;
          e2.el.fire("rot", { x: i3, y: a3, event: t4 });
        }, r2 = this.drawPoint(i2.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s2).on("mousedown", s2);
        this.rectSelection.set.add(r2);
      }
    }, t2.prototype.handler = function() {
      var t3 = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t3.x, t3.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, t2.prototype.observe = function() {
      var t3 = this;
      if (MutationObserver)
        if (this.rectSelection.isSelected || this.pointSelection.isSelected)
          this.observerInst = this.observerInst || new MutationObserver(function() {
            t3.handler();
          }), this.observerInst.observe(this.el.node, { attributes: true });
        else
          try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch (t4) {
          }
      else
        this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
          t3.handler();
        });
    }, t2.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(e2, i2) {
      return typeof e2 == "object" && (i2 = e2, e2 = true), (this.remember("_selectHandler") || new t2(this)).init(e2 === void 0 || e2, i2 || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
  }(), function() {
    (function() {
      function t2(t3) {
        t3.remember("_resizeHandler", this), this.el = t3, this.parameters = {}, this.lastUpdateCall = null, this.p = t3.doc().node.createSVGPoint();
      }
      t2.prototype.transformPoint = function(t3, e2, i2) {
        return this.p.x = t3 - (this.offset.x - window.pageXOffset), this.p.y = e2 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i2 || this.m);
      }, t2.prototype._extractPosition = function(t3) {
        return { x: t3.clientX != null ? t3.clientX : t3.touches[0].clientX, y: t3.clientY != null ? t3.clientY : t3.touches[0].clientY };
      }, t2.prototype.init = function(t3) {
        var e2 = this;
        if (this.stop(), t3 !== "stop") {
          for (var i2 in this.options = {}, this.el.resize.defaults)
            this.options[i2] = this.el.resize.defaults[i2], t3[i2] !== void 0 && (this.options[i2] = t3[i2]);
          this.el.on("lt.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("rt.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("rb.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("lb.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("t.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("r.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("b.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("l.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("rot.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.el.on("point.resize", function(t4) {
            e2.resize(t4 || window.event);
          }), this.update();
        }
      }, t2.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, t2.prototype.resize = function(t3) {
        var e2 = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var i2 = this._extractPosition(t3.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(i2.x, i2.y), x: t3.detail.x, y: t3.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), t3.detail.i !== void 0) {
          var a2 = this.el.array().valueOf();
          this.parameters.i = t3.detail.i, this.parameters.pointCoords = [a2[t3.detail.i][0], a2[t3.detail.i][1]];
        }
        switch (t3.type) {
          case "lt":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3);
              if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y + i3[1]).size(this.parameters.box.width - i3[0], this.parameters.box.height - i3[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 2);
              if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).size(this.parameters.box.width + i3[0], this.parameters.box.height - i3[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 0);
              if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i3[0], this.parameters.box.height + i3[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 1);
              if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).size(this.parameters.box.width - i3[0], this.parameters.box.height + i3[1]);
              }
            };
            break;
          case "t":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 2);
              if (this.parameters.box.height - i3[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).height(this.parameters.box.height - i3[1]);
              }
            };
            break;
          case "r":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 0);
              if (this.parameters.box.width + i3[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i3[0]);
              }
            };
            break;
          case "b":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 0);
              if (this.parameters.box.height + i3[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i3[1]);
              }
            };
            break;
          case "l":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, 1);
              if (this.parameters.box.width - i3[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).width(this.parameters.box.width - i3[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(t4, e3) {
              var i3 = t4 + this.parameters.p.x, a3 = e3 + this.parameters.p.y, s2 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r2 = Math.atan2(a3 - this.parameters.box.y - this.parameters.box.height / 2, i3 - this.parameters.box.x - this.parameters.box.width / 2), o2 = this.parameters.rotation + 180 * (r2 - s2) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o2 - o2 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(t4, e3) {
              var i3 = this.snapToGrid(t4, e3, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a3 = this.el.array().valueOf();
              a3[this.parameters.i][0] = this.parameters.pointCoords[0] + i3[0], a3[this.parameters.i][1] = this.parameters.pointCoords[1] + i3[1], this.el.plot(a3);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t3 }), SVG.on(window, "touchmove.resize", function(t4) {
          e2.update(t4 || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          e2.done();
        }), SVG.on(window, "mousemove.resize", function(t4) {
          e2.update(t4 || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          e2.done();
        });
      }, t2.prototype.update = function(t3) {
        if (t3) {
          var e2 = this._extractPosition(t3), i2 = this.transformPoint(e2.x, e2.y), a2 = i2.x - this.parameters.p.x, s2 = i2.y - this.parameters.p.y;
          this.lastUpdateCall = [a2, s2], this.calc(a2, s2), this.el.fire("resizing", { dx: a2, dy: s2, event: t3 });
        } else
          this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, t2.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, t2.prototype.snapToGrid = function(t3, e2, i2, a2) {
        var s2;
        return a2 !== void 0 ? s2 = [(i2 + t3) % this.options.snapToGrid, (a2 + e2) % this.options.snapToGrid] : (i2 = i2 == null ? 3 : i2, s2 = [(this.parameters.box.x + t3 + (1 & i2 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e2 + (2 & i2 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t3 < 0 && (s2[0] -= this.options.snapToGrid), e2 < 0 && (s2[1] -= this.options.snapToGrid), t3 -= Math.abs(s2[0]) < this.options.snapToGrid / 2 ? s2[0] : s2[0] - (t3 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e2 -= Math.abs(s2[1]) < this.options.snapToGrid / 2 ? s2[1] : s2[1] - (e2 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t3, e2, i2, a2);
      }, t2.prototype.constraintToBox = function(t3, e2, i2, a2) {
        var s2, r2, o2 = this.options.constraint || {};
        return a2 !== void 0 ? (s2 = i2, r2 = a2) : (s2 = this.parameters.box.x + (1 & i2 ? 0 : this.parameters.box.width), r2 = this.parameters.box.y + (2 & i2 ? 0 : this.parameters.box.height)), o2.minX !== void 0 && s2 + t3 < o2.minX && (t3 = o2.minX - s2), o2.maxX !== void 0 && s2 + t3 > o2.maxX && (t3 = o2.maxX - s2), o2.minY !== void 0 && r2 + e2 < o2.minY && (e2 = o2.minY - r2), o2.maxY !== void 0 && r2 + e2 > o2.maxY && (e2 = o2.maxY - r2), [t3, e2];
      }, t2.prototype.checkAspectRatio = function(t3, e2) {
        if (!this.options.saveAspectRatio)
          return t3;
        var i2 = t3.slice(), a2 = this.parameters.box.width / this.parameters.box.height, s2 = this.parameters.box.width + t3[0], r2 = this.parameters.box.height - t3[1], o2 = s2 / r2;
        return o2 < a2 ? (i2[1] = s2 / a2 - this.parameters.box.height, e2 && (i2[1] = -i2[1])) : o2 > a2 && (i2[0] = this.parameters.box.width - r2 * a2, e2 && (i2[0] = -i2[0])), i2;
      }, SVG.extend(SVG.Element, { resize: function(e2) {
        return (this.remember("_resizeHandler") || new t2(this)).init(e2 || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
    }).call(this);
  }(), window.Apex === void 0 && (window.Apex = {});
  var Rt = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new b(this.ctx), this.ctx.axes = new K(this.ctx), this.ctx.core = new Yt(this.ctx.el, this.ctx), this.ctx.config = new N({}), this.ctx.data = new B(this.ctx), this.ctx.grid = new U(this.ctx), this.ctx.graphics = new m(this.ctx), this.ctx.coreUtils = new y(this.ctx), this.ctx.crosshairs = new tt(this.ctx), this.ctx.events = new J(this.ctx), this.ctx.exports = new j(this.ctx), this.ctx.localization = new Q(this.ctx), this.ctx.options = new L(), this.ctx.responsive = new et(this.ctx), this.ctx.series = new E(this.ctx), this.ctx.theme = new it(this.ctx), this.ctx.formatters = new V(this.ctx), this.ctx.titleSubtitle = new at(this.ctx), this.ctx.legend = new ct(this.ctx), this.ctx.toolbar = new dt(this.ctx), this.ctx.dimensions = new lt(this.ctx), this.ctx.updateHelpers = new Ft(this.ctx), this.ctx.zoomPanSelection = new gt(this.ctx), this.ctx.w.globals.tooltip = new mt(this.ctx);
    } }]), t2;
  }(), Ht = function() {
    function t2(e2) {
      a(this, t2), this.ctx = e2, this.w = e2.w;
    }
    return r(t2, [{ key: "clear", value: function(t3) {
      var e2 = t3.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
    } }, { key: "killSVG", value: function(t3) {
      t3.each(function(t4, e2) {
        this.removeClass("*"), this.off(), this.stop();
      }, true), t3.ungroup(), t3.clear();
    } }, { key: "clearDomElements", value: function(t3) {
      var e2 = this, i2 = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
      a2.parentNode && a2.parentNode.parentNode && !i2 && (a2.parentNode.parentNode.style.minHeight = "unset");
      var s2 = this.w.globals.dom.baseEl;
      s2 && this.ctx.eventList.forEach(function(t4) {
        s2.removeEventListener(t4, e2.ctx.events.documentEvent);
      });
      var r2 = this.w.globals.dom;
      if (this.ctx.el !== null)
        for (; this.ctx.el.firstChild; )
          this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elAnnotations = null, r2.elLegendWrap = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
    } }]), t2;
  }(), Dt = /* @__PURE__ */ new WeakMap();
  var Nt = function() {
    function t2(e2, i2) {
      a(this, t2), this.opts = i2, this.ctx = this, this.w = new W(i2).init(), this.el = e2, this.w.globals.cuid = x.randomId(), this.w.globals.chartID = this.w.config.chart.id ? x.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Rt(this).initModules(), this.create = x.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return r(t2, [{ key: "render", value: function() {
      var t3 = this;
      return new Promise(function(e2, i2) {
        if (t3.el !== null) {
          Apex._chartInstances === void 0 && (Apex._chartInstances = []), t3.w.config.chart.id && Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
          var a2 = t3.w.config.chart.events.beforeMount;
          if (typeof a2 == "function" && a2(t3, t3.w), t3.events.fireEvent("beforeMount", [t3, t3.w]), window.addEventListener("resize", t3.windowResizeHandler), function(t4, e3) {
            var i3 = false, a3 = t4.getBoundingClientRect();
            t4.style.display !== "none" && a3.width !== 0 || (i3 = true);
            var s3 = new ResizeObserver(function(a4) {
              i3 && e3.call(t4, a4), i3 = true;
            });
            t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach(function(t5) {
              return s3.observe(t5);
            }) : s3.observe(t4), Dt.set(e3, s3);
          }(t3.el.parentNode, t3.parentResizeHandler), !t3.css) {
            var s2 = t3.el.getRootNode && t3.el.getRootNode(), r2 = x.is("ShadowRoot", s2), o2 = t3.el.ownerDocument, n2 = o2.getElementById("apexcharts-css");
            !r2 && n2 || (t3.css = document.createElement("style"), t3.css.id = "apexcharts-css", t3.css.textContent = '.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-title:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-goals-group, \n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  display: flex;\n}\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-box, .apexcharts-custom-tooltip {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}', r2 ? s2.prepend(t3.css) : o2.head.appendChild(t3.css));
          }
          var l2 = t3.create(t3.w.config.series, {});
          if (!l2)
            return e2(t3);
          t3.mount(l2).then(function() {
            typeof t3.w.config.chart.events.mounted == "function" && t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent("mounted", [t3, t3.w]), e2(l2);
          }).catch(function(t4) {
            i2(t4);
          });
        } else
          i2(new Error("Element not found"));
      });
    } }, { key: "create", value: function(t3, e2) {
      var i2 = this.w;
      new Rt(this).initModules();
      var a2 = this.w.globals;
      (a2.noData = false, a2.animationEnded = false, this.responsive.checkResponsiveConfig(e2), i2.config.xaxis.convertedCatToNumeric) && new D(i2.config).convertCatToNumericXaxis(i2.config, this.ctx);
      if (this.el === null)
        return a2.animationEnded = true, null;
      if (this.core.setupElements(), i2.config.chart.type === "treemap" && (i2.config.grid.show = false, i2.config.yaxis[0].show = false), a2.svgWidth === 0)
        return a2.animationEnded = true, null;
      var s2 = y.checkComboSeries(t3);
      a2.comboCharts = s2.comboCharts, a2.comboBarCount = s2.comboBarCount;
      var r2 = t3.every(function(t4) {
        return t4.data && t4.data.length === 0;
      });
      (t3.length === 0 || r2) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t3), this.theme.init(), new M(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a2.noData && a2.collapsedSeries.length !== a2.series.length && !i2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a2.axisCharts && (this.core.coreCalculations(), i2.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i2.globals.minX, this.ctx.toolbar.maxX = i2.globals.maxX), this.formatters.heatmapLabelFormatters(), new y(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var o2 = this.core.xySettings();
      this.grid.createGridMask();
      var n2 = this.core.plotChartType(t3, o2), l2 = new z(this);
      l2.bringForward(), i2.config.dataLabels.background.enabled && l2.dataLabelsBackground(), this.core.shiftGraphPosition();
      var h3 = { plot: { left: i2.globals.translateX, top: i2.globals.translateY, width: i2.globals.gridWidth, height: i2.globals.gridHeight } };
      return { elGraph: n2, xyRatios: o2, elInner: i2.globals.dom.elGraphical, dimensions: h3 };
    } }, { key: "mount", value: function() {
      var t3 = this, e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i2 = this, a2 = i2.w;
      return new Promise(function(s2, r2) {
        if (i2.el === null)
          return r2(new Error("Not enough data to display or target element not found"));
        (e2 === null || a2.globals.allSeriesCollapsed) && i2.series.handleNoData(), a2.config.chart.type !== "treemap" && i2.axes.drawAxis(a2.config.chart.type, e2.xyRatios), i2.grid = new U(i2);
        var o2 = i2.grid.drawGrid();
        i2.annotations = new P(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), a2.config.grid.position === "back" && o2 && a2.globals.dom.elGraphical.add(o2.el);
        var n2 = new _(t3.ctx), l2 = new $(t3.ctx);
        if (o2 !== null && (n2.xAxisLabelCorrections(o2.xAxisTickWidth), l2.setYAxisTextAlignments(), a2.config.yaxis.map(function(t4, e3) {
          a2.globals.ignoreYAxisIndexes.indexOf(e3) === -1 && l2.yAxisTitleRotate(e3, t4.opposite);
        })), a2.config.annotations.position === "back" && (a2.globals.dom.Paper.add(a2.globals.dom.elAnnotations), i2.annotations.drawAxesAnnotations()), Array.isArray(e2.elGraph))
          for (var h3 = 0; h3 < e2.elGraph.length; h3++)
            a2.globals.dom.elGraphical.add(e2.elGraph[h3]);
        else
          a2.globals.dom.elGraphical.add(e2.elGraph);
        if (a2.config.grid.position === "front" && o2 && a2.globals.dom.elGraphical.add(o2.el), a2.config.xaxis.crosshairs.position === "front" && i2.crosshairs.drawXCrosshairs(), a2.config.yaxis[0].crosshairs.position === "front" && i2.crosshairs.drawYCrosshairs(), a2.config.annotations.position === "front" && (a2.globals.dom.Paper.add(a2.globals.dom.elAnnotations), i2.annotations.drawAxesAnnotations()), !a2.globals.noData) {
          if (a2.config.tooltip.enabled && !a2.globals.noData && i2.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar))
            (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i2.zoomPanSelection.init({ xyRatios: e2.xyRatios });
          else {
            var c2 = a2.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t4) {
              c2[t4] = false;
            });
          }
          a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i2.toolbar.createToolbar();
        }
        a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach(function(t4) {
          t4.method(t4.params, false, t4.context);
        }), a2.globals.axisCharts || a2.globals.noData || i2.core.resizeNonAxisCharts(), s2(i2);
      });
    } }, { key: "destroy", value: function() {
      var t3, e2;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t3 = this.parentResizeHandler, (e2 = Dt.get(t3)) && (e2.disconnect(), Dt.delete(t3));
      var i2 = this.w.config.chart.id;
      i2 && Apex._chartInstances.forEach(function(t4, e3) {
        t4.id === x.escapeString(i2) && Apex._chartInstances.splice(e3, 1);
      }), new Ht(this.ctx).clear({ isUpdating: false });
    } }, { key: "updateOptions", value: function(t3) {
      var e2 = this, i2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], a2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], s2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], r2 = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], o2 = this.w;
      return o2.globals.selection = void 0, t3.series && (this.series.resetSeries(false, true, false), t3.series.length && t3.series[0].data && (t3.series = t3.series.map(function(t4, i3) {
        return e2.updateHelpers._extendSeries(t4, i3);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis && (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis && (t3 = this.updateHelpers.forceYAxisUpdate(t3)), o2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t3.theme && (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i2, a2, s2, r2);
    } }, { key: "updateSeries", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
      return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i2);
    } }, { key: "appendSeries", value: function(t3) {
      var e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a2 = this.w.config.series.slice();
      return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i2);
    } }, { key: "appendData", value: function(t3) {
      var e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = this;
      i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
      for (var a2 = i2.w.config.series.slice(), s2 = 0; s2 < a2.length; s2++)
        if (t3[s2] !== null && t3[s2] !== void 0)
          for (var r2 = 0; r2 < t3[s2].data.length; r2++)
            a2[s2].data.push(t3[s2].data[r2]);
      return i2.w.config.series = a2, e2 && (i2.w.globals.initialSeries = x.clone(i2.w.config.series)), this.update();
    } }, { key: "update", value: function(t3) {
      var e2 = this;
      return new Promise(function(i2, a2) {
        new Ht(e2.ctx).clear({ isUpdating: true });
        var s2 = e2.create(e2.w.config.series, t3);
        if (!s2)
          return i2(e2);
        e2.mount(s2).then(function() {
          typeof e2.w.config.chart.events.updated == "function" && e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent("updated", [e2, e2.w]), e2.w.globals.isDirty = true, i2(e2);
        }).catch(function(t4) {
          a2(t4);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var t3 = this.getGroupedCharts(), e2 = [this];
      return t3.length && (e2 = [], t3.forEach(function(t4) {
        e2.push(t4);
      })), e2;
    } }, { key: "getGroupedCharts", value: function() {
      var t3 = this;
      return Apex._chartInstances.filter(function(t4) {
        if (t4.group)
          return true;
      }).map(function(e2) {
        return t3.w.config.chart.group === e2.group ? e2.chart : t3;
      });
    } }, { key: "toggleSeries", value: function(t3) {
      return this.series.toggleSeries(t3);
    } }, { key: "highlightSeriesOnLegendHover", value: function(t3, e2) {
      return this.series.toggleSeriesOnHover(t3, e2);
    } }, { key: "showSeries", value: function(t3) {
      this.series.showSeries(t3);
    } }, { key: "hideSeries", value: function(t3) {
      this.series.hideSeries(t3);
    } }, { key: "resetSeries", value: function() {
      var t3 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
      this.series.resetSeries(t3, e2);
    } }, { key: "addEventListener", value: function(t3, e2) {
      this.events.addEventListener(t3, e2);
    } }, { key: "removeEventListener", value: function(t3, e2) {
      this.events.removeEventListener(t3, e2);
    } }, { key: "addXaxisAnnotation", value: function(t3) {
      var e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, a2 = this;
      i2 && (a2 = i2), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
    } }, { key: "addYaxisAnnotation", value: function(t3) {
      var e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, a2 = this;
      i2 && (a2 = i2), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
    } }, { key: "addPointAnnotation", value: function(t3) {
      var e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, a2 = this;
      i2 && (a2 = i2), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
    } }, { key: "clearAnnotations", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, e2 = this;
      t3 && (e2 = t3), e2.annotations.clearAnnotations(e2);
    } }, { key: "removeAnnotation", value: function(t3) {
      var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i2 = this;
      e2 && (i2 = e2), i2.annotations.removeAnnotation(i2, t3);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(t3, e2) {
      return this.coreUtils.getSeriesTotalsXRange(t3, e2);
    } }, { key: "getHighestValueInSeries", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e2 = new Z(this.ctx);
      return e2.getMinYMaxY(t3).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e2 = new Z(this.ctx);
      return e2.getMinYMaxY(t3).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
      return this.updateHelpers.toggleDataPointSelection(t3, e2);
    } }, { key: "zoomX", value: function(t3, e2) {
      this.ctx.toolbar.zoomUpdateOptions(t3, e2);
    } }, { key: "setLocale", value: function(t3) {
      this.localization.setCurrentLocaleValues(t3);
    } }, { key: "dataURI", value: function(t3) {
      return new j(this.ctx).dataURI(t3);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var t3 = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var t3 = this.w.config.chart.redrawOnWindowResize;
      typeof t3 == "function" && (t3 = t3()), t3 && this._windowResize();
    } }], [{ key: "getChartByID", value: function(t3) {
      var e2 = x.escapeString(t3), i2 = Apex._chartInstances.filter(function(t4) {
        return t4.id === e2;
      })[0];
      return i2 && i2.chart;
    } }, { key: "initOnLoad", value: function() {
      for (var e2 = document.querySelectorAll("[data-apexcharts]"), i2 = 0; i2 < e2.length; i2++) {
        new t2(e2[i2], JSON.parse(e2[i2].getAttribute("data-options"))).render();
      }
    } }, { key: "exec", value: function(t3, e2) {
      var i2 = this.getChartByID(t3);
      if (i2) {
        i2.w.globals.isExecCalled = true;
        var a2 = null;
        if (i2.publicMethods.indexOf(e2) !== -1) {
          for (var s2 = arguments.length, r2 = new Array(s2 > 2 ? s2 - 2 : 0), o2 = 2; o2 < s2; o2++)
            r2[o2 - 2] = arguments[o2];
          a2 = i2[e2].apply(i2, r2);
        }
        return a2;
      }
    } }, { key: "merge", value: function(t3, e2) {
      return x.extend(t3, e2);
    } }]), t2;
  }();
  module.exports = Nt;
})(apexcharts_common, apexcharts_common.exports);
(function(module) {
  module.exports = function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) {
        return installedModules[moduleId].exports;
      }
      var module2 = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {}
      };
      modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
      module2.l = true;
      return module2.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
      if (!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, { enumerable: true, get: getter });
      }
    };
    __webpack_require__.r = function(exports) {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      }
      Object.defineProperty(exports, "__esModule", { value: true });
    };
    __webpack_require__.t = function(value, mode) {
      if (mode & 1)
        value = __webpack_require__(value);
      if (mode & 8)
        return value;
      if (mode & 4 && typeof value === "object" && value && value.__esModule)
        return value;
      var ns = /* @__PURE__ */ Object.create(null);
      __webpack_require__.r(ns);
      Object.defineProperty(ns, "default", { enumerable: true, value });
      if (mode & 2 && typeof value != "string")
        for (var key in value)
          __webpack_require__.d(ns, key, function(key2) {
            return value[key2];
          }.bind(null, key));
      return ns;
    };
    __webpack_require__.n = function(module2) {
      var getter = module2 && module2.__esModule ? function getDefault() {
        return module2["default"];
      } : function getModuleExports() {
        return module2;
      };
      __webpack_require__.d(getter, "a", getter);
      return getter;
    };
    __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = "fb15");
  }({
    "8875": function(module2, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function(root, factory) {
        {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
      })(typeof self !== "undefined" ? self : this, function() {
        function getCurrentScript() {
          var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
          if (!descriptor && "currentScript" in document && document.currentScript) {
            return document.currentScript;
          }
          if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
            return document.currentScript;
          }
          try {
            throw new Error();
          } catch (err) {
            var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
            if (scriptLocation === currentLocation) {
              pageSource = document.documentElement.outerHTML;
              inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
              inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
            }
            for (var i = 0; i < scripts.length; i++) {
              if (scripts[i].readyState === "interactive") {
                return scripts[i];
              }
              if (scripts[i].src === scriptLocation) {
                return scripts[i];
              }
              if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                return scripts[i];
              }
            }
            return null;
          }
        }
        return getCurrentScript;
      });
    },
    "8bbf": function(module2, exports) {
      module2.exports = require$$0;
    },
    "95e6": function(module2, exports) {
      module2.exports = apexcharts_common.exports;
    },
    "fb15": function(module2, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      if (typeof window !== "undefined") {
        var currentScript = window.document.currentScript;
        {
          var getCurrentScript = __webpack_require__("8875");
          currentScript = getCurrentScript();
          if (!("currentScript" in document)) {
            Object.defineProperty(document, "currentScript", { get: getCurrentScript });
          }
        }
        var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
        if (src) {
          __webpack_require__.p = src[1];
        }
      }
      var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
      var external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_ = __webpack_require__("95e6");
      var external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_default = /* @__PURE__ */ __webpack_require__.n(external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_);
      const events = [
        "animationEnd",
        "beforeMount",
        "mounted",
        "updated",
        "click",
        "mouseMove",
        "legendClick",
        "markerClick",
        "selection",
        "dataPointSelection",
        "dataPointMouseEnter",
        "dataPointMouseLeave",
        "beforeZoom",
        "beforeResetZoom",
        "zoomed",
        "scrolled",
        "scrolled"
      ];
      const vueApexcharts = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
        name: "apexchart",
        props: {
          options: {
            type: Object
          },
          type: {
            type: String
          },
          series: {
            type: Array,
            required: true
          },
          width: {
            default: "100%"
          },
          height: {
            default: "auto"
          }
        },
        emits: events,
        setup(props, { emit }) {
          const __el = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
          const chart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
          const isObject2 = (item) => {
            return item && typeof item === "object" && !Array.isArray(item) && item != null;
          };
          const extend2 = (target, source) => {
            if (typeof Object.assign !== "function") {
              (function() {
                Object.assign = function(target2) {
                  if (target2 === void 0 || target2 === null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                  }
                  let output2 = Object(target2);
                  for (let index = 1; index < arguments.length; index++) {
                    let source2 = arguments[index];
                    if (source2 !== void 0 && source2 !== null) {
                      for (let nextKey in source2) {
                        if (source2.hasOwnProperty(nextKey)) {
                          output2[nextKey] = source2[nextKey];
                        }
                      }
                    }
                  }
                  return output2;
                };
              })();
            }
            let output = Object.assign({}, target);
            if (isObject2(target) && isObject2(source)) {
              Object.keys(source).forEach((key) => {
                if (isObject2(source[key])) {
                  if (!(key in target)) {
                    Object.assign(output, {
                      [key]: source[key]
                    });
                  } else {
                    output[key] = extend2(target[key], source[key]);
                  }
                } else {
                  Object.assign(output, {
                    [key]: source[key]
                  });
                }
              });
            }
            return output;
          };
          const init = async () => {
            await Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])();
            const newOptions = {
              chart: {
                type: props.type || props.options.chart.type || "line",
                height: props.height,
                width: props.width,
                events: {}
              },
              series: props.series
            };
            events.forEach((event) => {
              let callback = (...args) => emit(event, ...args);
              newOptions.chart.events[event] = callback;
            });
            const config = extend2(props.options, newOptions);
            chart.value = new external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_default.a(__el.value, config);
            return chart.value.render();
          };
          const refresh = () => {
            destroy();
            return init();
          };
          const destroy = () => {
            chart.value.destroy();
          };
          const updateSeries = (newSeries, animate) => {
            return chart.value.updateSeries(newSeries, animate);
          };
          const updateOptions = (newOptions, redrawPaths, animate, updateSyncedCharts) => {
            return chart.value.updateOptions(newOptions, redrawPaths, animate, updateSyncedCharts);
          };
          const toggleSeries = (seriesName) => {
            return chart.value.toggleSeries(seriesName);
          };
          const showSeries = (seriesName) => {
            chart.value.showSeries(seriesName);
          };
          const hideSeries = (seriesName) => {
            chart.value.hideSeries(seriesName);
          };
          const appendSeries = (newSeries, animate) => {
            return chart.value.appendSeries(newSeries, animate);
          };
          const resetSeries = () => {
            chart.value.resetSeries();
          };
          const toggleDataPointSelection = (seriesIndex, dataPointIndex) => {
            chart.value.toggleDataPointSelection(seriesIndex, dataPointIndex);
          };
          const appendData = (newData) => {
            return chart.value.appendData(newData);
          };
          const zoomX = (start, end) => {
            return chart.value.zoomX(start, end);
          };
          const dataURI = () => {
            return chart.value.dataURI();
          };
          const addXaxisAnnotation = (options, pushToMemory) => {
            chart.value.addXaxisAnnotation(options, pushToMemory);
          };
          const addYaxisAnnotation = (options, pushToMemory) => {
            chart.value.addYaxisAnnotation(options, pushToMemory);
          };
          const addPointAnnotation = (options, pushToMemory) => {
            chart.value.addPointAnnotation(options, pushToMemory);
          };
          const removeAnnotation = (id, options) => {
            chart.value.removeAnnotation(id, options);
          };
          const clearAnnotations = () => {
            chart.value.clearAnnotations();
          };
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(() => {
            window.ApexCharts = external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_default.a;
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
            __el.value = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])().proxy.$el;
            init();
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
            if (!chart.value) {
              return;
            }
            destroy();
          });
          const reactiveProps = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props);
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.options, () => {
            if (!chart.value && props.options) {
              init();
            } else {
              chart.value.updateOptions(props.options);
            }
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.series, () => {
            if (!chart.value && props.series) {
              init();
            } else {
              chart.value.updateSeries(props.series);
            }
          }, { deep: true });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.type, () => {
            refresh();
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.width, () => {
            refresh();
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.height, () => {
            refresh();
          });
          return {
            chart,
            init,
            refresh,
            destroy,
            updateOptions,
            updateSeries,
            toggleSeries,
            showSeries,
            hideSeries,
            resetSeries,
            zoomX,
            toggleDataPointSelection,
            appendData,
            appendSeries,
            addXaxisAnnotation,
            addYaxisAnnotation,
            addPointAnnotation,
            removeAnnotation,
            clearAnnotations,
            dataURI
          };
        },
        render() {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            class: "vue-apexcharts"
          });
        }
      });
      var vue3_apexcharts = vueApexcharts;
      const install = (app2) => {
        app2.component(vue3_apexcharts.name, vue3_apexcharts);
      };
      vue3_apexcharts.install = install;
      var src_0 = vue3_apexcharts;
      __webpack_exports__["default"] = src_0;
    }
  });
})(vue3Apexcharts_common);
var VueApexCharts = /* @__PURE__ */ getDefaultExportFromCjs(vue3Apexcharts_common.exports);
const ALIAS = Symbol.for("yaml.alias");
const DOC = Symbol.for("yaml.document");
const MAP = Symbol.for("yaml.map");
const PAIR = Symbol.for("yaml.pair");
const SCALAR$1 = Symbol.for("yaml.scalar");
const SEQ = Symbol.for("yaml.seq");
const NODE_TYPE = Symbol.for("yaml.node.type");
const isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
class NodeBase {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
}
const BREAK = Symbol("break visit");
const SKIP = Symbol("skip children");
const REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a = visitor.Map) === null || _a === void 0 ? void 0 : _a.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) === null || _b === void 0 ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) === null || _c === void 0 ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) === null || _d === void 0 ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) === null || _e === void 0 ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
const escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
class Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version2] = parts;
        if (version2 === "1.1" || version2 === "1.2") {
          this.yaml.version = version2;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version2);
          onError(6, `Unsupported YAML version ${version2}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc2) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc2 && tagEntries.length > 0 && isNode(doc2.contents)) {
      const tags = {};
      visit(doc2.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc2 || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
}
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc2, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc2);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref2 = sourceObjects.get(source);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar(ref2.node) || isCollection(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
class Alias extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  resolve(doc2) {
    let found = void 0;
    visit(doc2, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc: doc2, maxAliasCount } = ctx;
    const source = this.resolve(doc2);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc2, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
}
function getAliasCount(doc2, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc2);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc2, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc2, node.key, anchors);
    const vc = getAliasCount(doc2, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx === null || ctx === void 0 ? void 0 : ctx.keep))
    return Number(value);
  return value;
}
const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
class Scalar extends NodeBase {
  constructor(value) {
    super(SCALAR$1);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx === null || ctx === void 0 ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
const defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) !== null && _a !== void 0 ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a2;
    return ((_a2 = t.identify) === null || _a2 === void 0 ? void 0 : _a2.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref2 = sourceObjects.get(value);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value);
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value, ref2);
    }
  }
  if (tagName === null || tagName === void 0 ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref2)
        ref2.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref2)
    ref2.node = node;
  return node;
}
function collectionFromPath(schema2, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
class Collection extends NodeBase {
  constructor(type, schema2) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  clone(schema2) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy.schema = schema2;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema2) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
}
Collection.maxFlowStringSingleLineLength = 60;
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
const FOLD_FLOW = "flow";
const FOLD_BLOCK = "block";
const FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}
const getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat === null || compat === void 0 ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc2, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc2.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: doc2,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) !== null && _a !== void 0 ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) === null || _a2 === void 0 ? void 0 : _a2.call(t, obj);
    });
    tagObj = (_b = match.find((t) => t.format === item.format)) !== null && _b !== void 0 ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj === null || obj === void 0 ? void 0 : obj.constructor) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc: doc2 }) {
  if (!doc2.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc2.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) === null || _a === void 0 ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) !== null && _b !== void 0 ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc: doc2, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc2.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    if (valueStr === "" && !ctx.inFlow)
      ws = vcb === "\n" ? "\n\n" : vcb;
    else
      ws = `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
const MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
const isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
class Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema2) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx === null || ctx === void 0 ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx === null || ctx === void 0 ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
}
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) !== null && _a !== void 0 ? _a : collection.flow;
  const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify2(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
class YAMLMap extends Collection {
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) === null || _a === void 0 ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it === null || it === void 0 ? void 0 : it.value;
    return !keepScalar && isScalar(node) ? node.value : node;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : (ctx === null || ctx === void 0 ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx === null || ctx === void 0 ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
}
function createMap(schema2, obj, ctx) {
  const { keepUndefined, replacer: replacer2 } = ctx;
  const map2 = new YAMLMap(schema2);
  const add2 = (key, value) => {
    if (typeof replacer2 === "function")
      value = replacer2.call(obj, key, value);
    else if (Array.isArray(replacer2) && !replacer2.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add2(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add2(key, obj[key]);
  }
  if (typeof schema2.sortMapEntries === "function") {
    map2.items.sort(schema2.sortMapEntries);
  }
  return map2;
}
const map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};
class YAMLSeq extends Collection {
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx === null || ctx === void 0 ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
}
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function createSeq(schema2, obj, ctx) {
  const { replacer: replacer2 } = ctx;
  const seq2 = new YAMLSeq(schema2);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer2 === "function") {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer2.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
const seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};
const string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
const nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};
const boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
const floatNaN$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
const float$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};
const intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
const intResolve$1 = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify$1(node, radix, prefix) {
  const { value } = node;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
const intOct$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
  stringify: (node) => intStringify$1(node, 8, "0o")
};
const int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
  stringify: (node) => intStringify$1(node, 16, "0x")
};
const schema$2 = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
const jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
const schema$1 = [map, seq].concat(jsonScalars, jsonError);
const binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer2[i] = str.charCodeAt(i);
      return buffer2;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) !== null && _a !== void 0 ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer: replacer2 } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer2 === "function")
        it = replacer2.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
const pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
class YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx === null || ctx === void 0 ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
}
YAMLOMap.tag = "tag:yaml.org,2002:omap";
const omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
const falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};
const floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
const float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};
const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
const intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
  stringify: (node) => intStringify(node, 2, "0b")
};
const intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
  stringify: (node) => intStringify(node, 8, "0")
};
const int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};
class YAMLSet extends YAMLMap {
  constructor(schema2) {
    super(schema2);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
}
YAMLSet.tag = "tag:yaml.org,2002:set";
const set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema2, iterable, ctx) {
    const { replacer: replacer2 } = ctx;
    const set2 = new YAMLSet(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer2 === "function")
          value = replacer2.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
}
const intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
const schema = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];
const schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
const tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
const coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults !== null && toStringDefaults !== void 0 ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
}
function stringifyDocument(doc2, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc2.directives) {
    const dir = doc2.directives.toString(doc2);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc2.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc2, options);
  const { commentString } = ctx.options;
  if (doc2.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc2.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc2.contents) {
    if (isNode(doc2.contents)) {
      if (doc2.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc2.contents.commentBefore) {
        const cs = commentString(doc2.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc2.comment;
      contentComment = doc2.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc2.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc2.contents, ctx));
  }
  if ((_a = doc2.directives) === null || _a === void 0 ? void 0 : _a.docEnd) {
    if (doc2.comment) {
      const cs = commentString(doc2.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc2.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
class Document {
  constructor(value, replacer2, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer2 === "function" || Array.isArray(replacer2)) {
      _replacer = replacer2;
    } else if (options === void 0 && replacer2) {
      options = replacer2;
      replacer2 = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version: version2 } = opt;
    if (options === null || options === void 0 ? void 0 : options.directives) {
      this.directives = options.directives.atDocument();
      if (this.directives.yaml.explicit)
        version2 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version2 });
    this.setSchema(version2, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer2, options) {
    let _replacer = void 0;
    if (typeof replacer2 === "function") {
      value = replacer2.call({ "": value }, "", value);
      _replacer = replacer2;
    } else if (Array.isArray(replacer2)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer2.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer2 = replacer2.concat(asStr);
      _replacer = replacer2;
    } else if (options === void 0 && replacer2) {
      options = replacer2;
      replacer2 = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options !== null && options !== void 0 ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  setSchema(version2, options = {}) {
    if (typeof version2 === "number")
      version2 = String(version2);
    let opt;
    switch (version2) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version2;
        else
          this.directives = new Directives({ version: version2 });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version2);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify
    };
    const res = toJS(this.contents, jsonArg !== null && jsonArg !== void 0 ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
}
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
class YAMLError extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
}
class YAMLParseError extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
}
class YAMLWarning extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
}
const prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow !== null && flow !== void 0 ? flow : "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start !== null && start !== void 0 ? start : end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError) {
  if ((fc === null || fc === void 0 ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
const startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key !== null && key !== void 0 ? key : sep === null || sep === void 0 ? void 0 : sep[0],
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key !== null && key !== void 0 ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep !== null && sep !== void 0 ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset, offset];
  return map2;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    offset = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, offset];
  return seq2;
}
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}
const blockMsg = "Block collections are not allowed within flow collections";
const isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  var _a;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key !== null && key !== void 0 ? key : sep === null || sep === void 0 ? void 0 : sep[0],
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_a = prev.value) !== null && _a !== void 0 ? _a : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep !== null && sep !== void 0 ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag === null || tag === void 0 ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m === null || m === void 0 ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + ((_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
const escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken !== null && tagToken !== void 0 ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken !== null && tagToken !== void 0 ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ directives, schema: schema2 }, value, token, onError) {
  var _a;
  const tag = schema2.tags.find((tag2) => {
    var _a2;
    return tag2.default && ((_a2 = tag2.test) === null || _a2 === void 0 ? void 0 : _a2.test(value));
  }) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = (_a = schema2.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) === null || _a2 === void 0 ? void 0 : _a2.test(value));
    })) !== null && _a !== void 0 ? _a : schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment)
    node.comment = comment;
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ directives }, options);
  const doc2 = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc2.directives,
    options: doc2.options,
    schema: doc2.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value !== null && value !== void 0 ? value : end === null || end === void 0 ? void 0 : end[0],
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc2.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc2.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc2.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc2.comment = re.comment;
  doc2.range = [offset, contentEnd, re.offset];
  return doc2;
}
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
class Composer {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc2, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc2.contents;
      if (afterDoc) {
        doc2.comment = doc2.comment ? `${doc2.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc2.directives.docStart || !dc) {
        doc2.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc2.errors, this.errors);
      Array.prototype.push.apply(doc2.warnings, this.warnings);
    } else {
      doc2.errors = this.errors;
      doc2.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc2 = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc2.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc2, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc2;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ directives: this.directives }, this.options);
      const doc2 = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc2.range = [0, endOffset, endOffset];
      this.decorate(doc2, false);
      yield doc2;
    }
  }
}
const BOM = "\uFEFF";
const DOCUMENT = "";
const FLOW_END = "";
const SCALAR = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
const hexDigits = "0123456789ABCDEFabcdef".split("");
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
const invalidFlowScalarChars = ",[]{}".split("");
const invalidAnchorChars = " ,[]{}\n\r	".split("");
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
class Lexer {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) !== null && _a !== void 0 ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        const lastChar = i;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
}
class LineCounter {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
}
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token === null || token === void 0 ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) !== null && _a !== void 0 ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
class Parser {
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error !== null && error !== void 0 ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc2 = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc2.start.push(this.sourceToken);
        this.stack.push(doc2);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc2) {
    if (doc2.value)
      return yield* this.lineEnd(doc2);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc2.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc2.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc2.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc2);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it.start, "explicit-key-ind")) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key, delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
}
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc2 = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc2)
      doc2 = _doc;
    else if (doc2.options.logLevel !== "silent") {
      doc2.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc2.errors.forEach(prettifyError(source, lineCounter));
    doc2.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc2;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc2 = parseDocument(src, options);
  if (!doc2)
    return null;
  doc2.warnings.forEach((warning) => warn(doc2.options.logLevel, warning));
  if (doc2.errors.length > 0) {
    if (doc2.options.logLevel !== "silent")
      throw doc2.errors[0];
    else
      doc2.errors = [];
  }
  return doc2.toJS(Object.assign({ reviver: _reviver }, options));
}
const maxUnixTSInSeconds = 9999999999;
function ParseDate(d) {
  if (d instanceof Date)
    return d;
  if (typeof d === "number") {
    if (d > maxUnixTSInSeconds)
      return new Date(d);
    return new Date(d * 1e3);
  }
  return new Date(d);
}
function ParseNumber(v, isInt = false) {
  if (!v)
    return 0;
  if (typeof v === "number")
    return v;
  return (isInt ? parseInt(v) : parseFloat(v)) || 0;
}
function ToObject(o, typeOrCfg = {}, child = false) {
  if (o == null)
    return null;
  if (typeof o.toObject === "function" && child)
    return o.toObject();
  switch (typeof o) {
    case "string":
      return typeOrCfg === "number" ? ParseNumber(o) : o;
    case "boolean":
    case "number":
      return o;
  }
  if (o instanceof Date) {
    return typeOrCfg === "string" ? o.toISOString() : Math.floor(o.getTime() / 1e3);
  }
  if (Array.isArray(o))
    return o.map((v) => ToObject(v, typeOrCfg, true));
  const d = {};
  for (const k of Object.keys(o)) {
    const v = o[k];
    if (v === void 0)
      continue;
    if (v === null)
      continue;
    d[k] = ToObject(v, typeOrCfg[k] || {}, true);
  }
  return d;
}
class ChartDisplay {
  constructor(data) {
    __publicField(this, "fullWidth");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.fullWidth = "fullWidth" in d ? d.fullWidth : false;
  }
  toObject() {
    const cfg = {};
    return ToObject(this, cfg);
  }
}
class Chart$1 {
  constructor(data) {
    __publicField(this, "name");
    __publicField(this, "description");
    __publicField(this, "package");
    __publicField(this, "benchmarks");
    __publicField(this, "metrics");
    __publicField(this, "display");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.name = "name" in d ? d.name : "";
    this.description = "description" in d ? d.description : "";
    this.package = "package" in d ? d.package : "";
    this.benchmarks = "benchmarks" in d ? d.benchmarks : null;
    this.metrics = "metrics" in d ? d.metrics : {};
    this.display = "display" in d ? new ChartDisplay(d.display) : null;
  }
  toObject() {
    const cfg = {};
    return ToObject(this, cfg);
  }
}
class ChartGroup$1 {
  constructor(data) {
    __publicField(this, "name");
    __publicField(this, "description");
    __publicField(this, "charts");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.name = "name" in d ? d.name : "";
    this.description = "description" in d ? d.description : "";
    this.charts = Array.isArray(d.charts) ? d.charts.map((v) => new Chart$1(v)) : null;
  }
  toObject() {
    const cfg = {};
    return ToObject(this, cfg);
  }
}
class Config {
  constructor(data) {
    __publicField(this, "title");
    __publicField(this, "description");
    __publicField(this, "repository");
    __publicField(this, "benchmarksFile");
    __publicField(this, "chartGroups");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.title = "title" in d ? d.title : "";
    this.description = "description" in d ? d.description : "";
    this.repository = "repository" in d ? d.repository : "";
    this.benchmarksFile = "benchmarksFile" in d ? d.benchmarksFile : null;
    this.chartGroups = Array.isArray(d.chartGroups) ? d.chartGroups.map((v) => new ChartGroup$1(v)) : null;
  }
  toObject() {
    const cfg = {};
    return ToObject(this, cfg);
  }
}
class Mem {
  constructor(data) {
    __publicField(this, "BytesPerOp");
    __publicField(this, "AllocsPerOp");
    __publicField(this, "MBPerSec");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.BytesPerOp = "BytesPerOp" in d ? d.BytesPerOp : 0;
    this.AllocsPerOp = "AllocsPerOp" in d ? d.AllocsPerOp : 0;
    this.MBPerSec = "MBPerSec" in d ? d.MBPerSec : 0;
  }
  toObject() {
    const cfg = {};
    cfg.BytesPerOp = "number";
    cfg.AllocsPerOp = "number";
    cfg.MBPerSec = "number";
    return ToObject(this, cfg);
  }
}
class Benchmark {
  constructor(data) {
    __publicField(this, "Name");
    __publicField(this, "Runs");
    __publicField(this, "NsPerOp");
    __publicField(this, "Mem");
    __publicField(this, "Custom");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.Name = "Name" in d ? d.Name : "";
    this.Runs = "Runs" in d ? d.Runs : 0;
    this.NsPerOp = "NsPerOp" in d ? d.NsPerOp : 0;
    this.Mem = new Mem(d.Mem);
    this.Custom = "Custom" in d ? d.Custom : {};
  }
  toObject() {
    const cfg = {};
    cfg.Runs = "number";
    cfg.NsPerOp = "number";
    return ToObject(this, cfg);
  }
}
class Suite {
  constructor(data) {
    __publicField(this, "Goos");
    __publicField(this, "Goarch");
    __publicField(this, "Pkg");
    __publicField(this, "Benchmarks");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.Goos = "Goos" in d ? d.Goos : "";
    this.Goarch = "Goarch" in d ? d.Goarch : "";
    this.Pkg = "Pkg" in d ? d.Pkg : "";
    this.Benchmarks = Array.isArray(d.Benchmarks) ? d.Benchmarks.map((v) => new Benchmark(v)) : null;
  }
  toObject() {
    const cfg = {};
    return ToObject(this, cfg);
  }
}
class Run {
  constructor(data) {
    __publicField(this, "Version");
    __publicField(this, "Date");
    __publicField(this, "Tags");
    __publicField(this, "Suites");
    const d = data && typeof data === "object" ? ToObject(data) : {};
    this.Version = "Version" in d ? d.Version : "";
    this.Date = "Date" in d ? d.Date : 0;
    this.Tags = "Tags" in d ? d.Tags : null;
    this.Suites = Array.isArray(d.Suites) ? d.Suites.map((v) => new Suite(v)) : null;
  }
  toObject() {
    const cfg = {};
    cfg.Date = "number";
    return ToObject(this, cfg);
  }
}
const defaultMetrics = {
  ["NsPerOp"]: true,
  ["Mem.BytesPerOp"]: true,
  ["Mem.AllocsPerOp"]: true
};
function iterateSuites(runs, func) {
  for (let rID = 0; rID < runs.length; rID += 1) {
    const run = runs[rID];
    for (let sID = 0; sID < run.Suites.length; sID += 1) {
      func(run.Suites[sID], run);
    }
  }
}
function iterateBenchmarks(runs, func, pkg) {
  iterateSuites(runs, (suite, run) => {
    if (pkg && !pkg.test(suite.Pkg))
      return;
    for (let bID = 0; bID < suite.Benchmarks.length; bID += 1) {
      func(suite.Benchmarks[bID], suite, run);
    }
  });
}
function benchName(b) {
  return b.replace(/^(Benchmark)/, "");
}
function generateSeries(runs, pkg, benches, metrics = defaultMetrics) {
  if (Object.keys(metrics).length === 0) {
    metrics = defaultMetrics;
  }
  const metricKeys = Object.keys(metrics).filter((m) => metrics[m]);
  const index = metricKeys.reduce((acc, cur) => {
    acc[cur] = [];
    return acc;
  }, {});
  const xaxis = metricKeys.reduce((acc, cur) => {
    acc[cur] = {};
    return acc;
  }, {});
  iterateBenchmarks(runs, (bench, _, run) => {
    for (let i = 0; i < benches.length; i += 1) {
      const benchMatch = benches[i];
      if (!benchMatch.test(bench.Name))
        continue;
      for (let mID = 0; mID < metricKeys.length; mID += 1) {
        const metric = metricKeys[mID];
        const existingSeries = index[metric].filter((v) => v.name === benchName(bench.Name)).pop();
        if (!existingSeries) {
          index[metric].push({
            name: benchName(bench.Name),
            data: []
          });
        }
        const series = existingSeries || index[metric][index[metric].length - 1];
        const push = (y) => {
          series.data.push({ x: run.Date, y });
          xaxis[metric][run.Date] = true;
        };
        switch (metric) {
          case "NsPerOp":
            push(bench.NsPerOp);
            break;
          case "Mem.AllocsPerOp":
            push(bench.Mem.AllocsPerOp);
            break;
          case "Mem.BytesPerOp":
            push(bench.Mem.BytesPerOp);
            break;
          case "Mem.MBPerSec":
            push(bench.Mem.MBPerSec);
            break;
          default:
            if (bench.Custom && metric in bench.Custom) {
              push(bench.Custom[metric]);
            }
        }
      }
    }
  }, pkg);
  const xaxisArrays = {};
  metricKeys.forEach((metric) => {
    xaxisArrays[metric] = Object.keys(xaxis[metric]).map((k) => parseInt(k));
    xaxisArrays[metric].sort();
  });
  metricKeys.forEach((metric) => {
    const seriesX = index[metric].reduce((acc, series) => {
      acc[series.name || "?"] = series.data.reduce((acc2, point) => {
        acc2[point.x] = true;
        return acc2;
      }, {});
      return acc;
    }, {});
    const seriesNames = Object.keys(seriesX);
    xaxisArrays[metric].forEach((x) => {
      seriesNames.forEach((s) => {
        var _a;
        if (!seriesX[s][x]) {
          (_a = index[metric].filter((series) => series.name === s).pop()) == null ? void 0 : _a.data.push({ x, y: null });
        }
      });
    });
    index[metric].forEach((s) => {
      s.data.sort((p1, p2) => p1.x < p2.x ? -1 : 1);
    });
  });
  return {
    charts: index,
    xaxis: xaxisArrays
  };
}
var Chart_vue_vue_type_style_index_0_lang = "";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$2 = defineComponent({
  name: "LineChart",
  props: {
    repo: { type: String, required: true },
    config: {
      type: Object,
      required: true
    },
    runs: {
      type: Array,
      required: true
    }
  },
  data: () => ({ error: void 0 }),
  computed: {
    description() {
      return this.config.description || `"Package": "${this.config.package}", "Benchmarks": ${JSON.stringify(this.config.benchmarks)}`;
    }
  },
  methods: {
    generateCharts() {
      var _a;
      try {
        const pkgMatcher = new RegExp(this.config.package || ".");
        const benchMatchers = ((_a = this.config.benchmarks) == null ? void 0 : _a.map((b) => new RegExp(b || "."))) || [];
        if (benchMatchers.length === 0)
          benchMatchers.push(new RegExp("."));
        const series = generateSeries(this.runs, pkgMatcher, benchMatchers, this.config.metrics);
        console.log(`chart ${this.config.name}`, series);
        return Object.keys(series.charts).map((m) => ({
          metric: m,
          options: {
            chart: {
              type: "line",
              events: {
                markerClick: (event, chartContext, config) => {
                  if (!this.repo)
                    return;
                  const { dataPointIndex: x } = config;
                  const d = ParseDate(series.xaxis[m][x]);
                  const r = this.runs.find((r2) => {
                    return ParseDate(r2.Date).valueOf() === d.valueOf();
                  });
                  if (r)
                    window.open(`${this.repo}/commit/${r.Version}`);
                }
              },
              toolbar: {
                tools: {
                  zoom: false,
                  selection: false
                }
              }
            },
            responsive: [
              {
                breakpoint: 769,
                options: {
                  chart: {
                    height: 300
                  }
                }
              }
            ],
            dataLabels: {
              enabled: false
            },
            xaxis: {
              type: "category",
              categories: series.xaxis[m],
              sorted: true,
              tooltip: { enabled: false },
              labels: {
                show: false,
                formatter: (date) => {
                  const d = ParseDate(date);
                  const r = this.runs.find((r2) => {
                    return ParseDate(r2.Date).valueOf() === d.valueOf();
                  });
                  const formatted = `${d.toDateString()} ${("0" + d.getHours()).slice(-2)}:${("0" + d.getMinutes()).slice(-2)}`;
                  return r && r.Version ? `${formatted} (${r.Version.substring(0, 9)})` : formatted;
                }
              }
            },
            tooltip: {
              enabled: true,
              shared: true,
              onDatasetHover: {
                highlightDataSeries: true
              },
              fixed: {
                enabled: true,
                position: "topLeft"
              }
            },
            series: series.charts[m].map((s) => {
              s.data = s.data.map((p2) => p2.y);
              return s;
            })
          }
        })) || [];
      } catch (err) {
        console.error(`chart ${this.config.name}`, this.config, err);
        return [];
      }
    }
  }
});
const _hoisted_1$2 = { class: "chart" };
const _hoisted_2$2 = ["innerHTML"];
const _hoisted_3$1 = { key: 0 };
const _hoisted_4$1 = {
  key: 1,
  class: "chart-set"
};
const _hoisted_5$1 = { class: "chart-container" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_apexchart = resolveComponent("apexchart");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    createBaseVNode("h3", null, toDisplayString(_ctx.config.name), 1),
    createBaseVNode("p", { innerHTML: _ctx.description }, null, 8, _hoisted_2$2),
    _ctx.error ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString(_ctx.error), 1)) : (openBlock(), createElementBlock("div", _hoisted_4$1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.generateCharts(), (c) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["metric", { "full-width": _ctx.config.display && _ctx.config.display.fullWidth }]),
          key: c.metric
        }, [
          createBaseVNode("h5", null, toDisplayString(c.metric), 1),
          createBaseVNode("div", _hoisted_5$1, [
            createVNode(_component_apexchart, {
              options: c.options,
              series: c.options.series,
              height: _ctx.config.display && _ctx.config.display.fullWidth ? 300 : "auto"
            }, null, 8, ["options", "series", "height"])
          ])
        ], 2);
      }), 128))
    ]))
  ]);
}
var Chart = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
var ChartGroup_vue_vue_type_style_index_0_lang = "";
const _sfc_main$1 = defineComponent({
  name: "ChartGroup",
  components: {
    Chart
  },
  props: {
    repo: { type: String, required: true },
    group: {
      type: Object,
      required: true
    },
    runs: {
      type: Array,
      required: true
    }
  }
});
const _hoisted_1$1 = { class: "chart-group" };
const _hoisted_2$1 = ["innerHTML"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Chart = resolveComponent("Chart");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createBaseVNode("h2", null, toDisplayString(_ctx.group.name), 1),
    createBaseVNode("p", {
      innerHTML: _ctx.group.description
    }, null, 8, _hoisted_2$1),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.charts, (c) => {
      return openBlock(), createElementBlock("div", {
        key: c.name,
        class: "chart"
      }, [
        createVNode(_component_Chart, {
          config: c,
          runs: _ctx.runs,
          repo: _ctx.repo
        }, null, 8, ["config", "runs", "repo"])
      ]);
    }), 128))
  ]);
}
var ChartGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var App_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "App",
  components: {
    ChartGroup
  },
  data: () => ({
    loading: true,
    config: new Config(),
    benchmarks: [],
    error: void 0
  }),
  computed: {
    groups() {
      if (this.config.chartGroups && this.config.chartGroups.length > 0)
        return this.config.chartGroups;
      const suites = {};
      iterateSuites(this.benchmarks, (s) => {
        suites[s.Pkg] = true;
      });
      const packages = Object.keys(suites).sort();
      console.log("no chart groups configured - detected packages", packages);
      return [
        new ChartGroup$1({
          name: "Benchmarks by package",
          description: "All detected benchmarks, grouped by Package",
          charts: packages.map((pkg) => new Chart$1({
            name: pkg,
            package: `^${pkg}$`,
            benchmarks: []
          }))
        })
      ];
    }
  },
  created() {
    this.load();
  },
  methods: {
    async load() {
      try {
        const configResp = await fetch("./gobenchdata-web.yml");
        if (configResp.status > 400) {
          console.error(configResp);
          throw new Error(`${configResp.status}: failed to load config`);
        }
        const raw = await configResp.text();
        console.log(raw);
        const config = new Config(parse(raw));
        const benchmarksResp = await fetch(`./${config.benchmarksFile || "benchmarks.json"}`);
        if (benchmarksResp.status > 400) {
          console.error(benchmarksResp);
          throw new Error(`${benchmarksResp.status}: failed to load benchmarks`);
        }
        const runs = await benchmarksResp.json();
        this.benchmarks = runs.map((r) => new Run(r));
        this.config = config;
        console.log("data loaded", { config, runs: this.benchmarks.length });
      } catch (err) {
        this.error = err;
      }
      this.loading = false;
    }
  }
});
const _hoisted_1 = { class: "app" };
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { key: 1 };
const _hoisted_4 = { key: 2 };
const _hoisted_5 = ["innerHTML"];
const _hoisted_6 = /* @__PURE__ */ createBaseVNode("div", { class: "footer" }, [
  /* @__PURE__ */ createBaseVNode("p", null, [
    /* @__PURE__ */ createTextVNode(" generated using "),
    /* @__PURE__ */ createBaseVNode("a", { href: "https://bobheadxi.dev/r/gobenchdata" }, "gobenchdata")
  ])
], -1);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChartGroup = resolveComponent("ChartGroup");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    _ctx.loading ? (openBlock(), createElementBlock("div", _hoisted_2, "loading...")) : createCommentVNode("", true),
    _ctx.error ? (openBlock(), createElementBlock("div", _hoisted_3, toDisplayString(_ctx.error), 1)) : createCommentVNode("", true),
    !_ctx.loading && !_ctx.error ? (openBlock(), createElementBlock("div", _hoisted_4, [
      createBaseVNode("h1", null, toDisplayString(_ctx.config.title), 1),
      createBaseVNode("h3", {
        innerHTML: _ctx.config.description
      }, null, 8, _hoisted_5),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.groups, (g) => {
        return openBlock(), createElementBlock("div", {
          key: g.name
        }, [
          createVNode(_component_ChartGroup, {
            group: g,
            runs: _ctx.benchmarks,
            repo: _ctx.config.repository
          }, null, 8, ["group", "runs", "repo"])
        ]);
      }), 128))
    ])) : createCommentVNode("", true),
    _hoisted_6
  ]);
}
var App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const app = createApp(App);
app.use(VueApexCharts);
app.mount("#app");
